/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_gulp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/gulp.js */ \"./src/js/modules/gulp.js\");\n/* harmony import */ var _libs_swipers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/swipers.js */ \"./src/js/libs/swipers.js\");\n/* harmony import */ var _libs_inputmask_min_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/inputmask.min.js */ \"./src/js/libs/inputmask.min.js\");\n/* harmony import */ var _scripts_dropdown_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/dropdown.js */ \"./src/js/scripts/dropdown.js\");\n/* harmony import */ var _scripts_swiper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scripts/swiper.js */ \"./src/js/scripts/swiper.js\");\n/* harmony import */ var _scripts_datalist_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scripts/datalist.js */ \"./src/js/scripts/datalist.js\");\n/* harmony import */ var _scripts_modal_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scripts/modal.js */ \"./src/js/scripts/modal.js\");\n/* harmony import */ var _scripts_script_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scripts/script.js */ \"./src/js/scripts/script.js\");\n\n\n\n\n\n\n\n\n\n\n\n_modules_gulp_js__WEBPACK_IMPORTED_MODULE_0__.isWebp();\n\n\n//# sourceURL=webpack://boarding-houses/./src/js/app.js?");

/***/ }),

/***/ "./src/js/libs/inputmask.min.js":
/*!**************************************!*\
  !*** ./src/js/libs/inputmask.min.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/*!\n * dist/inputmask.min\n * https://github.com/RobinHerbots/Inputmask\n * Copyright (c) 2010 - 2019 Robin Herbots\n * Licensed under the MIT license\n * Version: 5.0.2-beta.1\n */\n!(function webpackUniversalModuleDefinition(root, factory) {\n  if ('object' == typeof exports && 'object' == typeof module) module.exports = factory();\n  else if ('function' == typeof define && define.amd) define([], factory);\n  else {\n    var a = factory();\n    for (var i in a) ('object' == typeof exports ? exports : root)[i] = a[i];\n  }\n})(window, function () {\n  return (\n    (modules = [\n      function (module) {\n        module.exports = JSON.parse(\n          '{\"BACKSPACE\":8,\"BACKSPACE_SAFARI\":127,\"DELETE\":46,\"DOWN\":40,\"END\":35,\"ENTER\":13,\"ESCAPE\":27,\"HOME\":36,\"INSERT\":45,\"LEFT\":37,\"PAGE_DOWN\":34,\"PAGE_UP\":33,\"RIGHT\":39,\"SPACE\":32,\"TAB\":9,\"UP\":38,\"X\":88,\"CONTROL\":17}'\n        );\n      },\n      function (module, exports, __nested_webpack_require_910__) {\n        'use strict';\n        function _typeof(obj) {\n          return (\n            (_typeof =\n              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\n                ? function _typeof(obj) {\n                    return typeof obj;\n                  }\n                : function _typeof(obj) {\n                    return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype\n                      ? 'symbol'\n                      : typeof obj;\n                  }),\n            _typeof(obj)\n          );\n        }\n        var $ = __nested_webpack_require_910__(2),\n          window = __nested_webpack_require_910__(3),\n          document = window.document,\n          generateMaskSet = __nested_webpack_require_910__(4).generateMaskSet,\n          analyseMask = __nested_webpack_require_910__(4).analyseMask,\n          maskScope = __nested_webpack_require_910__(7);\n        function Inputmask(alias, options, internal) {\n          if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal);\n          (this.el = void 0),\n            (this.events = {}),\n            (this.maskset = void 0),\n            (this.refreshValue = !1),\n            !0 !== internal &&\n              ($.isPlainObject(alias)\n                ? (options = alias)\n                : ((options = options || {}), alias && (options.alias = alias)),\n              (this.opts = $.extend(!0, {}, this.defaults, options)),\n              (this.noMasksCache = options && void 0 !== options.definitions),\n              (this.userOptions = options || {}),\n              resolveAlias(this.opts.alias, options, this.opts),\n              (this.isRTL = this.opts.numericInput));\n        }\n        function resolveAlias(aliasStr, options, opts) {\n          var aliasDefinition = Inputmask.prototype.aliases[aliasStr];\n          return aliasDefinition\n            ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, void 0, opts),\n              $.extend(!0, opts, aliasDefinition),\n              $.extend(!0, opts, options),\n              !0)\n            : (null === opts.mask && (opts.mask = aliasStr), !1);\n        }\n        function importAttributeOptions(npt, opts, userOptions, dataAttribute) {\n          function importOption(option, optionData) {\n            (optionData = void 0 !== optionData ? optionData : npt.getAttribute(dataAttribute + '-' + option)),\n              null !== optionData &&\n                ('string' == typeof optionData &&\n                  (0 === option.indexOf('on')\n                    ? (optionData = window[optionData])\n                    : 'false' === optionData\n                    ? (optionData = !1)\n                    : 'true' === optionData && (optionData = !0)),\n                (userOptions[option] = optionData));\n          }\n          if (!0 === opts.importDataAttributes) {\n            var attrOptions = npt.getAttribute(dataAttribute),\n              option,\n              dataoptions,\n              optionData,\n              p;\n            if (\n              (attrOptions &&\n                '' !== attrOptions &&\n                ((attrOptions = attrOptions.replace(/'/g, '\"')), (dataoptions = JSON.parse('{' + attrOptions + '}'))),\n              dataoptions)\n            )\n              for (p in ((optionData = void 0), dataoptions))\n                if ('alias' === p.toLowerCase()) {\n                  optionData = dataoptions[p];\n                  break;\n                }\n            for (option in (importOption('alias', optionData),\n            userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts),\n            opts)) {\n              if (dataoptions)\n                for (p in ((optionData = void 0), dataoptions))\n                  if (p.toLowerCase() === option.toLowerCase()) {\n                    optionData = dataoptions[p];\n                    break;\n                  }\n              importOption(option, optionData);\n            }\n          }\n          return (\n            $.extend(!0, opts, userOptions),\n            ('rtl' !== npt.dir && !opts.rightAlign) || (npt.style.textAlign = 'right'),\n            ('rtl' !== npt.dir && !opts.numericInput) ||\n              ((npt.dir = 'ltr'), npt.removeAttribute('dir'), (opts.isRTL = !0)),\n            Object.keys(userOptions).length\n          );\n        }\n        (Inputmask.prototype = {\n          dataAttribute: 'data-inputmask',\n          defaults: {\n            _maxTestPos: 500,\n            placeholder: '_',\n            optionalmarker: ['[', ']'],\n            quantifiermarker: ['{', '}'],\n            groupmarker: ['(', ')'],\n            alternatormarker: '|',\n            escapeChar: '\\\\',\n            mask: null,\n            regex: null,\n            oncomplete: $.noop,\n            onincomplete: $.noop,\n            oncleared: $.noop,\n            repeat: 0,\n            greedy: !1,\n            autoUnmask: !1,\n            removeMaskOnSubmit: !1,\n            clearMaskOnLostFocus: !0,\n            insertMode: !0,\n            insertModeVisual: !0,\n            clearIncomplete: !1,\n            alias: null,\n            onKeyDown: $.noop,\n            onBeforeMask: null,\n            onBeforePaste: function onBeforePaste(pastedValue, opts) {\n              return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;\n            },\n            onBeforeWrite: null,\n            onUnMask: null,\n            showMaskOnFocus: !0,\n            showMaskOnHover: !0,\n            onKeyValidation: $.noop,\n            skipOptionalPartCharacter: ' ',\n            numericInput: !1,\n            rightAlign: !1,\n            undoOnEscape: !0,\n            radixPoint: '',\n            _radixDance: !1,\n            groupSeparator: '',\n            keepStatic: null,\n            positionCaretOnTab: !0,\n            tabThrough: !1,\n            supportsInputType: ['text', 'tel', 'url', 'password', 'search'],\n            ignorables: [\n              8, 9, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120,\n              121, 122, 123, 0, 229,\n            ],\n            isComplete: null,\n            preValidation: null,\n            postValidation: null,\n            staticDefinitionSymbol: void 0,\n            jitMasking: !1,\n            nullable: !0,\n            inputEventOnly: !1,\n            noValuePatching: !1,\n            positionCaretOnClick: 'lvp',\n            casing: null,\n            inputmode: 'text',\n            importDataAttributes: !0,\n            shiftPositions: !0,\n          },\n          definitions: {\n            9: { validator: '[0-9\\uff11-\\uff19]', definitionSymbol: '*' },\n            a: { validator: '[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]', definitionSymbol: '*' },\n            '*': { validator: '[0-9\\uff11-\\uff19A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]' },\n          },\n          aliases: {},\n          masksCache: {},\n          mask: function mask(elems) {\n            var that = this;\n            return (\n              'string' == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)),\n              (elems = elems.nodeName ? [elems] : elems),\n              $.each(elems, function (ndx, el) {\n                var scopedOpts = $.extend(!0, {}, that.opts);\n                if (importAttributeOptions(el, scopedOpts, $.extend(!0, {}, that.userOptions), that.dataAttribute)) {\n                  var maskset = generateMaskSet(scopedOpts, that.noMasksCache);\n                  void 0 !== maskset &&\n                    (void 0 !== el.inputmask && ((el.inputmask.opts.autoUnmask = !0), el.inputmask.remove()),\n                    (el.inputmask = new Inputmask(void 0, void 0, !0)),\n                    (el.inputmask.opts = scopedOpts),\n                    (el.inputmask.noMasksCache = that.noMasksCache),\n                    (el.inputmask.userOptions = $.extend(!0, {}, that.userOptions)),\n                    (el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput),\n                    (el.inputmask.el = el),\n                    (el.inputmask.maskset = maskset),\n                    $.data(el, '_inputmask_opts', scopedOpts),\n                    maskScope.call(el.inputmask, { action: 'mask' }));\n                }\n              }),\n              (elems && elems[0] && elems[0].inputmask) || this\n            );\n          },\n          option: function option(options, noremask) {\n            return 'string' == typeof options\n              ? this.opts[options]\n              : 'object' === _typeof(options)\n              ? ($.extend(this.userOptions, options), this.el && !0 !== noremask && this.mask(this.el), this)\n              : void 0;\n          },\n          unmaskedvalue: function unmaskedvalue(value) {\n            return (\n              (this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache)),\n              maskScope.call(this, { action: 'unmaskedvalue', value: value })\n            );\n          },\n          remove: function remove() {\n            return maskScope.call(this, { action: 'remove' });\n          },\n          getemptymask: function getemptymask() {\n            return (\n              (this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache)),\n              maskScope.call(this, { action: 'getemptymask' })\n            );\n          },\n          hasMaskedValue: function hasMaskedValue() {\n            return !this.opts.autoUnmask;\n          },\n          isComplete: function isComplete() {\n            return (\n              (this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache)),\n              maskScope.call(this, { action: 'isComplete' })\n            );\n          },\n          getmetadata: function getmetadata() {\n            return (\n              (this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache)),\n              maskScope.call(this, { action: 'getmetadata' })\n            );\n          },\n          isValid: function isValid(value) {\n            return (\n              (this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache)),\n              maskScope.call(this, { action: 'isValid', value: value })\n            );\n          },\n          format: function format(value, metadata) {\n            return (\n              (this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache)),\n              maskScope.call(this, { action: 'format', value: value, metadata: metadata })\n            );\n          },\n          setValue: function setValue(value) {\n            this.el && $(this.el).trigger('setvalue', [value]);\n          },\n          analyseMask: analyseMask,\n        }),\n          (Inputmask.extendDefaults = function (options) {\n            $.extend(!0, Inputmask.prototype.defaults, options);\n          }),\n          (Inputmask.extendDefinitions = function (definition) {\n            $.extend(!0, Inputmask.prototype.definitions, definition);\n          }),\n          (Inputmask.extendAliases = function (alias) {\n            $.extend(!0, Inputmask.prototype.aliases, alias);\n          }),\n          (Inputmask.format = function (value, options, metadata) {\n            return Inputmask(options).format(value, metadata);\n          }),\n          (Inputmask.unmask = function (value, options) {\n            return Inputmask(options).unmaskedvalue(value);\n          }),\n          (Inputmask.isValid = function (value, options) {\n            return Inputmask(options).isValid(value);\n          }),\n          (Inputmask.remove = function (elems) {\n            'string' == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)),\n              (elems = elems.nodeName ? [elems] : elems),\n              $.each(elems, function (ndx, el) {\n                el.inputmask && el.inputmask.remove();\n              });\n          }),\n          (Inputmask.setValue = function (elems, value) {\n            'string' == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)),\n              (elems = elems.nodeName ? [elems] : elems),\n              $.each(elems, function (ndx, el) {\n                el.inputmask ? el.inputmask.setValue(value) : $(el).trigger('setvalue', [value]);\n              });\n          });\n        var escapeRegexRegex = new RegExp(\n          '(\\\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\', '$', '^'].join('|\\\\') + ')',\n          'gim'\n        );\n        (Inputmask.escapeRegex = function (str) {\n          return str.replace(escapeRegexRegex, '\\\\$1');\n        }),\n          (Inputmask.dependencyLib = $),\n          (window.Inputmask = Inputmask),\n          (module.exports = Inputmask);\n      },\n      function (module, exports, __nested_webpack_require_13614__) {\n        'use strict';\n        function _typeof(obj) {\n          return (\n            (_typeof =\n              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\n                ? function _typeof(obj) {\n                    return typeof obj;\n                  }\n                : function _typeof(obj) {\n                    return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype\n                      ? 'symbol'\n                      : typeof obj;\n                  }),\n            _typeof(obj)\n          );\n        }\n        var window = __nested_webpack_require_13614__(3),\n          document = window.document;\n        function indexOf(list, elem) {\n          for (var i = 0, len = list.length; i < len; i++) if (list[i] === elem) return i;\n          return -1;\n        }\n        function isWindow(obj) {\n          return null != obj && obj === obj.window;\n        }\n        function isArraylike(obj) {\n          var length = 'length' in obj && obj.length,\n            ltype = _typeof(obj);\n          return (\n            'function' !== ltype &&\n            !isWindow(obj) &&\n            (!(1 !== obj.nodeType || !length) ||\n              'array' === ltype ||\n              0 === length ||\n              ('number' == typeof length && 0 < length && length - 1 in obj))\n          );\n        }\n        function isValidElement(elem) {\n          return elem instanceof Element;\n        }\n        function DependencyLib(elem) {\n          return elem instanceof DependencyLib\n            ? elem\n            : this instanceof DependencyLib\n            ? void (\n                null != elem &&\n                elem !== window &&\n                ((this[0] = elem.nodeName\n                  ? elem\n                  : void 0 !== elem[0] && elem[0].nodeName\n                  ? elem[0]\n                  : document.querySelector(elem)),\n                void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))\n              )\n            : new DependencyLib(elem);\n        }\n        (DependencyLib.prototype = {\n          on: function on(events, handler) {\n            function addEvent(ev, namespace) {\n              elem.addEventListener\n                ? elem.addEventListener(ev, handler, !1)\n                : elem.attachEvent && elem.attachEvent('on' + ev, handler),\n                (eventRegistry[ev] = eventRegistry[ev] || {}),\n                (eventRegistry[ev][namespace] = eventRegistry[ev][namespace] || []),\n                eventRegistry[ev][namespace].push(handler);\n            }\n            if (isValidElement(this[0]))\n              for (\n                var eventRegistry = this[0].eventRegistry, elem = this[0], _events = events.split(' '), endx = 0;\n                endx < _events.length;\n                endx++\n              ) {\n                var nsEvent = _events[endx].split('.'),\n                  ev = nsEvent[0],\n                  namespace = nsEvent[1] || 'global';\n                addEvent(ev, namespace);\n              }\n            return this;\n          },\n          off: function off(events, handler) {\n            var eventRegistry, elem;\n            function removeEvent(ev, namespace, handler) {\n              if (ev in eventRegistry == !0)\n                if (\n                  (elem.removeEventListener\n                    ? elem.removeEventListener(ev, handler, !1)\n                    : elem.detachEvent && elem.detachEvent('on' + ev, handler),\n                  'global' === namespace)\n                )\n                  for (var nmsp in eventRegistry[ev])\n                    eventRegistry[ev][nmsp].splice(eventRegistry[ev][nmsp].indexOf(handler), 1);\n                else eventRegistry[ev][namespace].splice(eventRegistry[ev][namespace].indexOf(handler), 1);\n            }\n            function resolveNamespace(ev, namespace) {\n              var evts = [],\n                hndx,\n                hndL;\n              if (0 < ev.length)\n                if (void 0 === handler)\n                  for (hndx = 0, hndL = eventRegistry[ev][namespace].length; hndx < hndL; hndx++)\n                    evts.push({\n                      ev: ev,\n                      namespace: namespace && 0 < namespace.length ? namespace : 'global',\n                      handler: eventRegistry[ev][namespace][hndx],\n                    });\n                else\n                  evts.push({\n                    ev: ev,\n                    namespace: namespace && 0 < namespace.length ? namespace : 'global',\n                    handler: handler,\n                  });\n              else if (0 < namespace.length)\n                for (var evNdx in eventRegistry)\n                  for (var nmsp in eventRegistry[evNdx])\n                    if (nmsp === namespace)\n                      if (void 0 === handler)\n                        for (hndx = 0, hndL = eventRegistry[evNdx][nmsp].length; hndx < hndL; hndx++)\n                          evts.push({ ev: evNdx, namespace: nmsp, handler: eventRegistry[evNdx][nmsp][hndx] });\n                      else evts.push({ ev: evNdx, namespace: nmsp, handler: handler });\n              return evts;\n            }\n            if (isValidElement(this[0])) {\n              (eventRegistry = this[0].eventRegistry), (elem = this[0]);\n              for (var _events = events.split(' '), endx = 0; endx < _events.length; endx++)\n                for (\n                  var nsEvent = _events[endx].split('.'),\n                    offEvents = resolveNamespace(nsEvent[0], nsEvent[1]),\n                    i = 0,\n                    offEventsL = offEvents.length;\n                  i < offEventsL;\n                  i++\n                )\n                  removeEvent(offEvents[i].ev, offEvents[i].namespace, offEvents[i].handler);\n            }\n            return this;\n          },\n          trigger: function trigger(events, argument_1) {\n            if (isValidElement(this[0]))\n              for (\n                var eventRegistry = this[0].eventRegistry,\n                  elem = this[0],\n                  _events = 'string' == typeof events ? events.split(' ') : [events.type],\n                  endx = 0;\n                endx < _events.length;\n                endx++\n              ) {\n                var nsEvent = _events[endx].split('.'),\n                  ev = nsEvent[0],\n                  namespace = nsEvent[1] || 'global';\n                if (void 0 !== document && 'global' === namespace) {\n                  var evnt,\n                    i,\n                    params = { bubbles: !0, cancelable: !0, detail: argument_1 };\n                  if (document.createEvent) {\n                    try {\n                      evnt = new CustomEvent(ev, params);\n                    } catch (e) {\n                      (evnt = document.createEvent('CustomEvent')),\n                        evnt.initCustomEvent(ev, params.bubbles, params.cancelable, params.detail);\n                    }\n                    events.type && DependencyLib.extend(evnt, events), elem.dispatchEvent(evnt);\n                  } else\n                    (evnt = document.createEventObject()),\n                      (evnt.eventType = ev),\n                      (evnt.detail = argument_1),\n                      events.type && DependencyLib.extend(evnt, events),\n                      elem.fireEvent('on' + evnt.eventType, evnt);\n                } else if (void 0 !== eventRegistry[ev])\n                  if (\n                    ((events = events.type ? events : DependencyLib.Event(events)),\n                    (events.detail = arguments.slice(1)),\n                    'global' === namespace)\n                  )\n                    for (var nmsp in eventRegistry[ev])\n                      for (i = 0; i < eventRegistry[ev][nmsp].length; i++)\n                        eventRegistry[ev][nmsp][i].apply(elem, arguments);\n                  else\n                    for (i = 0; i < eventRegistry[ev][namespace].length; i++)\n                      eventRegistry[ev][namespace][i].apply(elem, arguments);\n              }\n            return this;\n          },\n        }),\n          (DependencyLib.isFunction = function (obj) {\n            return 'function' == typeof obj;\n          }),\n          (DependencyLib.noop = function () {}),\n          (DependencyLib.isArray = Array.isArray),\n          (DependencyLib.inArray = function (elem, arr, i) {\n            return null == arr ? -1 : indexOf(arr, elem, i);\n          }),\n          (DependencyLib.valHooks = void 0),\n          (DependencyLib.isPlainObject = function (obj) {\n            return (\n              'object' === _typeof(obj) &&\n              !obj.nodeType &&\n              !isWindow(obj) &&\n              !(obj.constructor && !Object.hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf'))\n            );\n          }),\n          (DependencyLib.extend = function () {\n            var options,\n              name,\n              src,\n              copy,\n              copyIsArray,\n              clone,\n              target = arguments[0] || {},\n              i = 1,\n              length = arguments.length,\n              deep = !1;\n            for (\n              'boolean' == typeof target && ((deep = target), (target = arguments[i] || {}), i++),\n                'object' === _typeof(target) || DependencyLib.isFunction(target) || (target = {}),\n                i === length && ((target = this), i--);\n              i < length;\n              i++\n            )\n              if (null != (options = arguments[i]))\n                for (name in options)\n                  (src = target[name]),\n                    (copy = options[name]),\n                    target !== copy &&\n                      (deep &&\n                      copy &&\n                      (DependencyLib.isPlainObject(copy) || (copyIsArray = DependencyLib.isArray(copy)))\n                        ? ((clone = copyIsArray\n                            ? ((copyIsArray = !1), src && DependencyLib.isArray(src) ? src : [])\n                            : src && DependencyLib.isPlainObject(src)\n                            ? src\n                            : {}),\n                          (target[name] = DependencyLib.extend(deep, clone, copy)))\n                        : void 0 !== copy && (target[name] = copy));\n            return target;\n          }),\n          (DependencyLib.each = function (obj, callback) {\n            var value,\n              i = 0;\n            if (isArraylike(obj))\n              for (\n                var length = obj.length;\n                i < length && ((value = callback.call(obj[i], i, obj[i])), !1 !== value);\n                i++\n              );\n            else for (i in obj) if (((value = callback.call(obj[i], i, obj[i])), !1 === value)) break;\n            return obj;\n          }),\n          (DependencyLib.data = function (owner, key, value) {\n            if (void 0 === value) return owner.__data ? owner.__data[key] : null;\n            (owner.__data = owner.__data || {}), (owner.__data[key] = value);\n          }),\n          'function' == typeof window.CustomEvent\n            ? (DependencyLib.Event = window.CustomEvent)\n            : ((DependencyLib.Event = function (event, params) {\n                params = params || { bubbles: !1, cancelable: !1, detail: void 0 };\n                var evt = document.createEvent('CustomEvent');\n                return evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail), evt;\n              }),\n              (DependencyLib.Event.prototype = window.Event.prototype)),\n          (module.exports = DependencyLib);\n      },\n      function (module, exports, __nested_webpack_require_25235__) {\n        'use strict';\n        var __WEBPACK_AMD_DEFINE_RESULT__;\n        function _typeof(obj) {\n          return (\n            (_typeof =\n              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\n                ? function _typeof(obj) {\n                    return typeof obj;\n                  }\n                : function _typeof(obj) {\n                    return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype\n                      ? 'symbol'\n                      : typeof obj;\n                  }),\n            _typeof(obj)\n          );\n        }\n        (__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n          return 'undefined' != typeof window ? window : new (eval(\"require('jsdom').JSDOM\"))('').window;\n        }.call(exports, __nested_webpack_require_25235__, exports, module)),\n          void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);\n      },\n      function (module, exports, __nested_webpack_require_26250__) {\n        'use strict';\n        var $ = __nested_webpack_require_26250__(2);\n        function generateMaskSet(opts, nocache) {\n          var ms;\n          function generateMask(mask, metadata, opts) {\n            var regexMask = !1,\n              masksetDefinition,\n              maskdefKey;\n            if (\n              ((null !== mask && '' !== mask) ||\n                ((regexMask = null !== opts.regex),\n                (mask = regexMask\n                  ? ((mask = opts.regex), mask.replace(/^(\\^)(.*)(\\$)$/, '$2'))\n                  : ((regexMask = !0), '.*'))),\n              1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = ''),\n              0 < opts.repeat || '*' === opts.repeat || '+' === opts.repeat)\n            ) {\n              var repeatStart = '*' === opts.repeat ? 0 : '+' === opts.repeat ? 1 : opts.repeat;\n              mask =\n                opts.groupmarker[0] +\n                mask +\n                opts.groupmarker[1] +\n                opts.quantifiermarker[0] +\n                repeatStart +\n                ',' +\n                opts.repeat +\n                opts.quantifiermarker[1];\n            }\n            return (\n              (maskdefKey = regexMask\n                ? 'regex_' + opts.regex\n                : opts.numericInput\n                ? mask.split('').reverse().join('')\n                : mask),\n              !1 !== opts.keepStatic && (maskdefKey = 'ks_' + maskdefKey),\n              void 0 === Inputmask.prototype.masksCache[maskdefKey] || !0 === nocache\n                ? ((masksetDefinition = {\n                    mask: mask,\n                    maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),\n                    validPositions: {},\n                    _buffer: void 0,\n                    buffer: void 0,\n                    tests: {},\n                    excludes: {},\n                    metadata: metadata,\n                    maskLength: void 0,\n                    jitOffset: {},\n                  }),\n                  !0 !== nocache &&\n                    ((Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition),\n                    (masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))))\n                : (masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey])),\n              masksetDefinition\n            );\n          }\n          if (($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask))) {\n            if (1 < opts.mask.length) {\n              null === opts.keepStatic && (opts.keepStatic = !0);\n              var altMask = opts.groupmarker[0];\n              return (\n                $.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function (ndx, msk) {\n                  1 < altMask.length && (altMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0]),\n                    void 0 === msk.mask || $.isFunction(msk.mask) ? (altMask += msk) : (altMask += msk.mask);\n                }),\n                (altMask += opts.groupmarker[1]),\n                generateMask(altMask, opts.mask, opts)\n              );\n            }\n            opts.mask = opts.mask.pop();\n          }\n          return (\n            null === opts.keepStatic && (opts.keepStatic = !1),\n            (ms =\n              opts.mask && void 0 !== opts.mask.mask && !$.isFunction(opts.mask.mask)\n                ? generateMask(opts.mask.mask, opts.mask, opts)\n                : generateMask(opts.mask, opts.mask, opts)),\n            ms\n          );\n        }\n        function analyseMask(mask, regexMask, opts) {\n          var tokenizer = /(?:[?*+]|\\{[0-9+*]+(?:,[0-9+*]*)?(?:\\|[0-9+*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g,\n            regexTokenizer =\n              /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\n            escaped = !1,\n            currentToken = new MaskToken(),\n            match,\n            m,\n            openenings = [],\n            maskTokens = [],\n            openingToken,\n            currentOpeningToken,\n            alternator,\n            lastMatch,\n            closeRegexGroup = !1;\n          function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\n            (this.matches = []),\n              (this.openGroup = isGroup || !1),\n              (this.alternatorGroup = !1),\n              (this.isGroup = isGroup || !1),\n              (this.isOptional = isOptional || !1),\n              (this.isQuantifier = isQuantifier || !1),\n              (this.isAlternator = isAlternator || !1),\n              (this.quantifier = { min: 1, max: 1 });\n          }\n          function insertTestDefinition(mtoken, element, position) {\n            position = void 0 !== position ? position : mtoken.matches.length;\n            var prevMatch = mtoken.matches[position - 1];\n            if (regexMask)\n              0 === element.indexOf('[') || (escaped && /\\\\d|\\\\s|\\\\w]/i.test(element)) || '.' === element\n                ? mtoken.matches.splice(position++, 0, {\n                    fn: new RegExp(element, opts.casing ? 'i' : ''),\n                    static: !1,\n                    optionality: !1,\n                    newBlockMarker: void 0 === prevMatch ? 'master' : prevMatch.def !== element,\n                    casing: null,\n                    def: element,\n                    placeholder: void 0,\n                    nativeDef: element,\n                  })\n                : (escaped && (element = element[element.length - 1]),\n                  $.each(element.split(''), function (ndx, lmnt) {\n                    (prevMatch = mtoken.matches[position - 1]),\n                      mtoken.matches.splice(position++, 0, {\n                        fn: /[a-z]/i.test(opts.staticDefinitionSymbol || lmnt)\n                          ? new RegExp('[' + (opts.staticDefinitionSymbol || lmnt) + ']', opts.casing ? 'i' : '')\n                          : null,\n                        static: !0,\n                        optionality: !1,\n                        newBlockMarker:\n                          void 0 === prevMatch ? 'master' : prevMatch.def !== lmnt && !0 !== prevMatch.static,\n                        casing: null,\n                        def: opts.staticDefinitionSymbol || lmnt,\n                        placeholder: void 0 !== opts.staticDefinitionSymbol ? lmnt : void 0,\n                        nativeDef: (escaped ? \"'\" : '') + lmnt,\n                      });\n                  })),\n                (escaped = !1);\n            else {\n              var maskdef =\n                (opts.definitions ? opts.definitions[element] : void 0) || Inputmask.prototype.definitions[element];\n              maskdef && !escaped\n                ? mtoken.matches.splice(position++, 0, {\n                    fn: maskdef.validator\n                      ? 'string' == typeof maskdef.validator\n                        ? new RegExp(maskdef.validator, opts.casing ? 'i' : '')\n                        : new (function () {\n                            this.test = maskdef.validator;\n                          })()\n                      : new RegExp('.'),\n                    static: maskdef.static || !1,\n                    optionality: !1,\n                    newBlockMarker:\n                      void 0 === prevMatch ? 'master' : prevMatch.def !== (maskdef.definitionSymbol || element),\n                    casing: maskdef.casing,\n                    def: maskdef.definitionSymbol || element,\n                    placeholder: maskdef.placeholder,\n                    nativeDef: element,\n                    generated: maskdef.generated,\n                  })\n                : (mtoken.matches.splice(position++, 0, {\n                    fn: /[a-z]/i.test(opts.staticDefinitionSymbol || element)\n                      ? new RegExp('[' + (opts.staticDefinitionSymbol || element) + ']', opts.casing ? 'i' : '')\n                      : null,\n                    static: !0,\n                    optionality: !1,\n                    newBlockMarker:\n                      void 0 === prevMatch ? 'master' : prevMatch.def !== element && !0 !== prevMatch.static,\n                    casing: null,\n                    def: opts.staticDefinitionSymbol || element,\n                    placeholder: void 0 !== opts.staticDefinitionSymbol ? element : void 0,\n                    nativeDef: (escaped ? \"'\" : '') + element,\n                  }),\n                  (escaped = !1));\n            }\n          }\n          function verifyGroupMarker(maskToken) {\n            maskToken &&\n              maskToken.matches &&\n              $.each(maskToken.matches, function (ndx, token) {\n                var nextToken = maskToken.matches[ndx + 1];\n                (void 0 === nextToken || void 0 === nextToken.matches || !1 === nextToken.isQuantifier) &&\n                  token &&\n                  token.isGroup &&\n                  ((token.isGroup = !1),\n                  regexMask ||\n                    (insertTestDefinition(token, opts.groupmarker[0], 0),\n                    !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker[1]))),\n                  verifyGroupMarker(token);\n              });\n          }\n          function defaultCase() {\n            if (0 < openenings.length) {\n              if (\n                ((currentOpeningToken = openenings[openenings.length - 1]),\n                insertTestDefinition(currentOpeningToken, m),\n                currentOpeningToken.isAlternator)\n              ) {\n                alternator = openenings.pop();\n                for (var mndx = 0; mndx < alternator.matches.length; mndx++)\n                  alternator.matches[mndx].isGroup && (alternator.matches[mndx].isGroup = !1);\n                0 < openenings.length\n                  ? ((currentOpeningToken = openenings[openenings.length - 1]),\n                    currentOpeningToken.matches.push(alternator))\n                  : currentToken.matches.push(alternator);\n              }\n            } else insertTestDefinition(currentToken, m);\n          }\n          function reverseTokens(maskToken) {\n            function reverseStatic(st) {\n              return (\n                st === opts.optionalmarker[0]\n                  ? (st = opts.optionalmarker[1])\n                  : st === opts.optionalmarker[1]\n                  ? (st = opts.optionalmarker[0])\n                  : st === opts.groupmarker[0]\n                  ? (st = opts.groupmarker[1])\n                  : st === opts.groupmarker[1] && (st = opts.groupmarker[0]),\n                st\n              );\n            }\n            for (var match in ((maskToken.matches = maskToken.matches.reverse()), maskToken.matches))\n              if (Object.prototype.hasOwnProperty.call(maskToken.matches, match)) {\n                var intMatch = parseInt(match);\n                if (\n                  maskToken.matches[match].isQuantifier &&\n                  maskToken.matches[intMatch + 1] &&\n                  maskToken.matches[intMatch + 1].isGroup\n                ) {\n                  var qt = maskToken.matches[match];\n                  maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt);\n                }\n                void 0 !== maskToken.matches[match].matches\n                  ? (maskToken.matches[match] = reverseTokens(maskToken.matches[match]))\n                  : (maskToken.matches[match] = reverseStatic(maskToken.matches[match]));\n              }\n            return maskToken;\n          }\n          function groupify(matches) {\n            var groupToken = new MaskToken(!0);\n            return (groupToken.openGroup = !1), (groupToken.matches = matches), groupToken;\n          }\n          function closeGroup() {\n            if (((openingToken = openenings.pop()), (openingToken.openGroup = !1), void 0 !== openingToken))\n              if (0 < openenings.length) {\n                if (\n                  ((currentOpeningToken = openenings[openenings.length - 1]),\n                  currentOpeningToken.matches.push(openingToken),\n                  currentOpeningToken.isAlternator)\n                ) {\n                  alternator = openenings.pop();\n                  for (var mndx = 0; mndx < alternator.matches.length; mndx++)\n                    (alternator.matches[mndx].isGroup = !1), (alternator.matches[mndx].alternatorGroup = !1);\n                  0 < openenings.length\n                    ? ((currentOpeningToken = openenings[openenings.length - 1]),\n                      currentOpeningToken.matches.push(alternator))\n                    : currentToken.matches.push(alternator);\n                }\n              } else currentToken.matches.push(openingToken);\n            else defaultCase();\n          }\n          function groupQuantifier(matches) {\n            var lastMatch = matches.pop();\n            return lastMatch.isQuantifier && (lastMatch = groupify([matches.pop(), lastMatch])), lastMatch;\n          }\n          for (\n            regexMask && ((opts.optionalmarker[0] = void 0), (opts.optionalmarker[1] = void 0));\n            (match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask));\n\n          ) {\n            if (((m = match[0]), regexMask))\n              switch (m.charAt(0)) {\n                case '?':\n                  m = '{0,1}';\n                  break;\n                case '+':\n                case '*':\n                  m = '{' + m + '}';\n                  break;\n                case '|':\n                  if (0 === openenings.length) {\n                    var altRegexGroup = groupify(currentToken.matches);\n                    (altRegexGroup.openGroup = !0),\n                      openenings.push(altRegexGroup),\n                      (currentToken.matches = []),\n                      (closeRegexGroup = !0);\n                  }\n                  break;\n              }\n            if (escaped) defaultCase();\n            else\n              switch (m.charAt(0)) {\n                case '(?=':\n                  break;\n                case '(?!':\n                  break;\n                case '(?<=':\n                  break;\n                case '(?<!':\n                  break;\n                case opts.escapeChar:\n                  (escaped = !0), regexMask && defaultCase();\n                  break;\n                case opts.optionalmarker[1]:\n                case opts.groupmarker[1]:\n                  closeGroup();\n                  break;\n                case opts.optionalmarker[0]:\n                  openenings.push(new MaskToken(!1, !0));\n                  break;\n                case opts.groupmarker[0]:\n                  openenings.push(new MaskToken(!0));\n                  break;\n                case opts.quantifiermarker[0]:\n                  var quantifier = new MaskToken(!1, !1, !0);\n                  m = m.replace(/[{}]/g, '');\n                  var mqj = m.split('|'),\n                    mq = mqj[0].split(','),\n                    mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),\n                    mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);\n                  ('*' !== mq0 && '+' !== mq0) || (mq0 = '*' === mq1 ? 0 : 1),\n                    (quantifier.quantifier = { min: mq0, max: mq1, jit: mqj[1] });\n                  var matches =\n                    0 < openenings.length ? openenings[openenings.length - 1].matches : currentToken.matches;\n                  if (((match = matches.pop()), match.isAlternator)) {\n                    matches.push(match), (matches = match.matches);\n                    var groupToken = new MaskToken(!0),\n                      tmpMatch = matches.pop();\n                    matches.push(groupToken), (matches = groupToken.matches), (match = tmpMatch);\n                  }\n                  match.isGroup || (match = groupify([match])), matches.push(match), matches.push(quantifier);\n                  break;\n                case opts.alternatormarker:\n                  if (0 < openenings.length) {\n                    currentOpeningToken = openenings[openenings.length - 1];\n                    var subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];\n                    lastMatch =\n                      currentOpeningToken.openGroup &&\n                      (void 0 === subToken.matches || (!1 === subToken.isGroup && !1 === subToken.isAlternator))\n                        ? openenings.pop()\n                        : groupQuantifier(currentOpeningToken.matches);\n                  } else lastMatch = groupQuantifier(currentToken.matches);\n                  if (lastMatch.isAlternator) openenings.push(lastMatch);\n                  else if (\n                    (lastMatch.alternatorGroup\n                      ? ((alternator = openenings.pop()), (lastMatch.alternatorGroup = !1))\n                      : (alternator = new MaskToken(!1, !1, !1, !0)),\n                    alternator.matches.push(lastMatch),\n                    openenings.push(alternator),\n                    lastMatch.openGroup)\n                  ) {\n                    lastMatch.openGroup = !1;\n                    var alternatorGroup = new MaskToken(!0);\n                    (alternatorGroup.alternatorGroup = !0), openenings.push(alternatorGroup);\n                  }\n                  break;\n                default:\n                  defaultCase();\n              }\n          }\n          for (closeRegexGroup && closeGroup(); 0 < openenings.length; )\n            (openingToken = openenings.pop()), currentToken.matches.push(openingToken);\n          return (\n            0 < currentToken.matches.length && (verifyGroupMarker(currentToken), maskTokens.push(currentToken)),\n            (opts.numericInput || opts.isRTL) && reverseTokens(maskTokens[0]),\n            maskTokens\n          );\n        }\n        module.exports = { generateMaskSet: generateMaskSet, analyseMask: analyseMask };\n      },\n      function (module, exports, __nested_webpack_require_44220__) {\n        'use strict';\n        __nested_webpack_require_44220__(6),\n          __nested_webpack_require_44220__(8),\n          __nested_webpack_require_44220__(9),\n          __nested_webpack_require_44220__(10),\n          (module.exports = __nested_webpack_require_44220__(1));\n      },\n      function (module, exports, __nested_webpack_require_44495__) {\n        'use strict';\n        var Inputmask = __nested_webpack_require_44495__(1);\n        Inputmask.extendDefinitions({\n          A: { validator: '[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]', casing: 'upper' },\n          '&': { validator: '[0-9A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]', casing: 'upper' },\n          '#': { validator: '[0-9A-Fa-f]', casing: 'upper' },\n        });\n        var ipValidatorRegex = new RegExp('25[0-5]|2[0-4][0-9]|[01][0-9][0-9]');\n        function ipValidator(chrs, maskset, pos, strict, opts) {\n          return (\n            (chrs =\n              -1 < pos - 1 && '.' !== maskset.buffer[pos - 1]\n                ? ((chrs = maskset.buffer[pos - 1] + chrs),\n                  -1 < pos - 2 && '.' !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : '0' + chrs)\n                : '00' + chrs),\n            ipValidatorRegex.test(chrs)\n          );\n        }\n        Inputmask.extendAliases({\n          cssunit: { regex: '[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)' },\n          url: { regex: '(https?|ftp)//.*', autoUnmask: !1 },\n          ip: {\n            mask: 'i[i[i]].j[j[j]].k[k[k]].l[l[l]]',\n            definitions: {\n              i: { validator: ipValidator },\n              j: { validator: ipValidator },\n              k: { validator: ipValidator },\n              l: { validator: ipValidator },\n            },\n            onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {\n              return maskedValue;\n            },\n            inputmode: 'numeric',\n          },\n          email: {\n            mask: '*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]',\n            greedy: !1,\n            casing: 'lower',\n            onBeforePaste: function onBeforePaste(pastedValue, opts) {\n              return (pastedValue = pastedValue.toLowerCase()), pastedValue.replace('mailto:', '');\n            },\n            definitions: {\n              '*': { validator: \"[0-9\\uff11-\\uff19A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5!#$%&'*+/=?^_`{|}~-]\" },\n              '-': { validator: '[0-9A-Za-z-]' },\n            },\n            onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {\n              return maskedValue;\n            },\n            inputmode: 'email',\n          },\n          mac: { mask: '##:##:##:##:##:##' },\n          vin: {\n            mask: 'V{13}9{4}',\n            definitions: { V: { validator: '[A-HJ-NPR-Za-hj-npr-z\\\\d]', casing: 'upper' } },\n            clearIncomplete: !0,\n            autoUnmask: !0,\n          },\n          ssn: {\n            mask: '999-99-9999',\n            postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) {\n              return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(buffer.join(''));\n            },\n          },\n        }),\n          (module.exports = Inputmask);\n      },\n      function (module, exports, __nested_webpack_require_47454__) {\n        'use strict';\n        function _typeof(obj) {\n          return (\n            (_typeof =\n              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\n                ? function _typeof(obj) {\n                    return typeof obj;\n                  }\n                : function _typeof(obj) {\n                    return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype\n                      ? 'symbol'\n                      : typeof obj;\n                  }),\n            _typeof(obj)\n          );\n        }\n        var $ = __nested_webpack_require_47454__(2),\n          window = __nested_webpack_require_47454__(3),\n          document = window.document,\n          ua = (window.navigator && window.navigator.userAgent) || '',\n          ie = 0 < ua.indexOf('MSIE ') || 0 < ua.indexOf('Trident/'),\n          mobile = 'ontouchstart' in window,\n          iemobile = /iemobile/i.test(ua),\n          iphone = /iphone/i.test(ua) && !iemobile,\n          keyCode = __nested_webpack_require_47454__(0);\n        module.exports = function maskScope(actionObj, maskset, opts) {\n          (maskset = maskset || this.maskset), (opts = opts || this.opts);\n          var inputmask = this,\n            el = this.el,\n            isRTL = this.isRTL || (this.isRTL = opts.numericInput),\n            undoValue,\n            $el,\n            skipKeyPressEvent = !1,\n            skipInputEvent = !1,\n            validationEvent = !1,\n            ignorable = !1,\n            maxLength,\n            mouseEnter = !1,\n            originalPlaceholder = void 0;\n          function getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {\n            var greedy = opts.greedy;\n            clearOptionalTail && (opts.greedy = !1), (minimalPos = minimalPos || 0);\n            var maskTemplate = [],\n              ndxIntlzr,\n              pos = 0,\n              test,\n              testPos,\n              jitRenderStatic;\n            do {\n              if (!0 === baseOnInput && maskset.validPositions[pos])\n                (testPos =\n                  clearOptionalTail &&\n                  !0 === maskset.validPositions[pos].match.optionality &&\n                  void 0 === maskset.validPositions[pos + 1] &&\n                  (!0 === maskset.validPositions[pos].generatedInput ||\n                    (maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && 0 < pos))\n                    ? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1))\n                    : maskset.validPositions[pos]),\n                  (test = testPos.match),\n                  (ndxIntlzr = testPos.locator.slice()),\n                  maskTemplate.push(\n                    !0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder(pos, test)\n                  );\n              else {\n                (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1)),\n                  (test = testPos.match),\n                  (ndxIntlzr = testPos.locator.slice());\n                var jitMasking = !0 !== noJit && (!1 !== opts.jitMasking ? opts.jitMasking : test.jit);\n                (jitRenderStatic =\n                  (jitRenderStatic && test.static && test.def !== opts.groupSeparator && null === test.fn) ||\n                  (maskset.validPositions[pos - 1] &&\n                    test.static &&\n                    test.def !== opts.groupSeparator &&\n                    null === test.fn)),\n                  jitRenderStatic ||\n                  !1 === jitMasking ||\n                  void 0 === jitMasking ||\n                  ('number' == typeof jitMasking && isFinite(jitMasking) && pos < jitMasking)\n                    ? maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder(pos, test))\n                    : (jitRenderStatic = !1);\n              }\n              pos++;\n            } while (\n              ((void 0 === maxLength || pos < maxLength) && (!0 !== test.static || '' !== test.def)) ||\n              pos < minimalPos\n            );\n            return (\n              '' === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(),\n              (!1 === includeMode && void 0 !== maskset.maskLength) || (maskset.maskLength = pos - 1),\n              (opts.greedy = greedy),\n              maskTemplate\n            );\n          }\n          function resetMaskSet(soft) {\n            (maskset.buffer = void 0), !0 !== soft && ((maskset.validPositions = {}), (maskset.p = 0));\n          }\n          function getLastValidPosition(closestTo, strict, validPositions) {\n            var before = -1,\n              after = -1,\n              valids = validPositions || maskset.validPositions;\n            for (var posNdx in (void 0 === closestTo && (closestTo = -1), valids)) {\n              var psNdx = parseInt(posNdx);\n              valids[psNdx] &&\n                (strict || !0 !== valids[psNdx].generatedInput) &&\n                (psNdx <= closestTo && (before = psNdx), closestTo <= psNdx && (after = psNdx));\n            }\n            return -1 === before || before == closestTo\n              ? after\n              : -1 == after\n              ? before\n              : closestTo - before < after - closestTo\n              ? before\n              : after;\n          }\n          function getDecisionTaker(tst) {\n            var decisionTaker = tst.locator[tst.alternation];\n            return (\n              'string' == typeof decisionTaker &&\n                0 < decisionTaker.length &&\n                (decisionTaker = decisionTaker.split(',')[0]),\n              void 0 !== decisionTaker ? decisionTaker.toString() : ''\n            );\n          }\n          function getLocator(tst, align) {\n            var locator = (null != tst.alternation ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join('');\n            if ('' !== locator) for (; locator.length < align; ) locator += '0';\n            return locator;\n          }\n          function determineTestTemplate(pos, tests) {\n            pos = 0 < pos ? pos - 1 : 0;\n            for (\n              var altTest = getTest(pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch, ndx = 0;\n              ndx < tests.length;\n              ndx++\n            ) {\n              var tst = tests[ndx];\n              tstLocator = getLocator(tst, targetLocator.length);\n              var distance = Math.abs(tstLocator - targetLocator);\n              (void 0 === closest ||\n                ('' !== tstLocator && distance < closest) ||\n                (bestMatch &&\n                  !opts.greedy &&\n                  bestMatch.match.optionality &&\n                  'master' === bestMatch.match.newBlockMarker &&\n                  (!tst.match.optionality || !tst.match.newBlockMarker)) ||\n                (bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier)) &&\n                ((closest = distance), (bestMatch = tst));\n            }\n            return bestMatch;\n          }\n          function getTestTemplate(pos, ndxIntlzr, tstPs) {\n            return (\n              maskset.validPositions[pos] ||\n              determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs))\n            );\n          }\n          function getTest(pos, tests) {\n            return maskset.validPositions[pos] ? maskset.validPositions[pos] : (tests || getTests(pos))[0];\n          }\n          function positionCanMatchDefinition(pos, testDefinition, opts) {\n            for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++) {\n              if (\n                tests[tndx].match &&\n                (!(\n                  tests[tndx].match.nativeDef !== testDefinition.match[opts.shiftPositions ? 'def' : 'nativeDef'] ||\n                  (opts.shiftPositions && testDefinition.match.static)\n                ) ||\n                  tests[tndx].match.nativeDef === testDefinition.match.nativeDef)\n              ) {\n                valid = !0;\n                break;\n              }\n              if (tests[tndx].match && tests[tndx].match.def === testDefinition.match.nativeDef) {\n                valid = void 0;\n                break;\n              }\n            }\n            return (\n              !1 === valid &&\n                void 0 !== maskset.jitOffset[pos] &&\n                (valid = positionCanMatchDefinition(pos + maskset.jitOffset[pos], testDefinition, opts)),\n              valid\n            );\n          }\n          function getTests(pos, ndxIntlzr, tstPs) {\n            var maskTokens = maskset.maskToken,\n              testPos = ndxIntlzr ? tstPs : 0,\n              ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],\n              matches = [],\n              insertStop = !1,\n              latestMatch,\n              cacheDependency = ndxIntlzr ? ndxIntlzr.join('') : '';\n            function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {\n              function handleMatch(match, loopNdx, quantifierRecurse) {\n                function isFirstMatch(latestMatch, tokenGroup) {\n                  var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches);\n                  return (\n                    firstMatch ||\n                      $.each(tokenGroup.matches, function (ndx, match) {\n                        if (\n                          (!0 === match.isQuantifier\n                            ? (firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]))\n                            : Object.prototype.hasOwnProperty.call(match, 'matches') &&\n                              (firstMatch = isFirstMatch(latestMatch, match)),\n                          firstMatch)\n                        )\n                          return !1;\n                      }),\n                    firstMatch\n                  );\n                }\n                function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {\n                  var bestMatch, indexPos;\n                  if (\n                    ((maskset.tests[pos] || maskset.validPositions[pos]) &&\n                      $.each(maskset.tests[pos] || [maskset.validPositions[pos]], function (ndx, lmnt) {\n                        if (lmnt.mloc[alternateNdx]) return (bestMatch = lmnt), !1;\n                        var alternation = void 0 !== targetAlternation ? targetAlternation : lmnt.alternation,\n                          ndxPos =\n                            void 0 !== lmnt.locator[alternation]\n                              ? lmnt.locator[alternation].toString().indexOf(alternateNdx)\n                              : -1;\n                        (void 0 === indexPos || ndxPos < indexPos) &&\n                          -1 !== ndxPos &&\n                          ((bestMatch = lmnt), (indexPos = ndxPos));\n                      }),\n                    bestMatch)\n                  ) {\n                    var bestMatchAltIndex = bestMatch.locator[bestMatch.alternation],\n                      locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;\n                    return locator.slice(\n                      (void 0 !== targetAlternation ? targetAlternation : bestMatch.alternation) + 1\n                    );\n                  }\n                  return void 0 !== targetAlternation ? resolveNdxInitializer(pos, alternateNdx) : void 0;\n                }\n                function isSubsetOf(source, target) {\n                  function expand(pattern) {\n                    for (var expanded = [], start = -1, end, i = 0, l = pattern.length; i < l; i++)\n                      if ('-' === pattern.charAt(i))\n                        for (end = pattern.charCodeAt(i + 1); ++start < end; )\n                          expanded.push(String.fromCharCode(start));\n                      else (start = pattern.charCodeAt(i)), expanded.push(pattern.charAt(i));\n                    return expanded.join('');\n                  }\n                  return (\n                    source.match.def === target.match.nativeDef ||\n                    (!(\n                      !(opts.regex || (source.match.fn instanceof RegExp && target.match.fn instanceof RegExp)) ||\n                      !0 === source.match.static ||\n                      !0 === target.match.static\n                    ) &&\n                      -1 !==\n                        expand(target.match.fn.toString().replace(/[[\\]/]/g, '')).indexOf(\n                          expand(source.match.fn.toString().replace(/[[\\]/]/g, ''))\n                        ))\n                  );\n                }\n                function staticCanMatchDefinition(source, target) {\n                  return (\n                    !0 === source.match.static &&\n                    !0 !== target.match.static &&\n                    target.match.fn.test(source.match.def, maskset, pos, !1, opts, !1)\n                  );\n                }\n                function setMergeLocators(targetMatch, altMatch) {\n                  var alternationNdx = targetMatch.alternation,\n                    shouldMerge =\n                      void 0 === altMatch ||\n                      (alternationNdx === altMatch.alternation &&\n                        -1 ===\n                          targetMatch.locator[alternationNdx].toString().indexOf(altMatch.locator[alternationNdx]));\n                  if (!shouldMerge && alternationNdx > altMatch.alternation)\n                    for (var i = altMatch.alternation; i < alternationNdx; i++)\n                      if (targetMatch.locator[i] !== altMatch.locator[i]) {\n                        (alternationNdx = i), (shouldMerge = !0);\n                        break;\n                      }\n                  if (shouldMerge) {\n                    targetMatch.mloc = targetMatch.mloc || {};\n                    var locNdx = targetMatch.locator[alternationNdx];\n                    if (void 0 !== locNdx) {\n                      if (\n                        ('string' == typeof locNdx && (locNdx = locNdx.split(',')[0]),\n                        void 0 === targetMatch.mloc[locNdx] && (targetMatch.mloc[locNdx] = targetMatch.locator.slice()),\n                        void 0 !== altMatch)\n                      ) {\n                        for (var ndx in altMatch.mloc)\n                          'string' == typeof ndx && (ndx = ndx.split(',')[0]),\n                            void 0 === targetMatch.mloc[ndx] && (targetMatch.mloc[ndx] = altMatch.mloc[ndx]);\n                        targetMatch.locator[alternationNdx] = Object.keys(targetMatch.mloc).join(',');\n                      }\n                      return !0;\n                    }\n                    targetMatch.alternation = void 0;\n                  }\n                  return !1;\n                }\n                if (testPos > opts._maxTestPos && void 0 !== quantifierRecurse)\n                  throw (\n                    'Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. ' +\n                    maskset.mask\n                  );\n                if (testPos === pos && void 0 === match.matches)\n                  return matches.push({ match: match, locator: loopNdx.reverse(), cd: cacheDependency, mloc: {} }), !0;\n                if (void 0 !== match.matches) {\n                  if (match.isGroup && quantifierRecurse !== match) {\n                    if (\n                      ((match = handleMatch(\n                        maskToken.matches[$.inArray(match, maskToken.matches) + 1],\n                        loopNdx,\n                        quantifierRecurse\n                      )),\n                      match)\n                    )\n                      return !0;\n                  } else if (match.isOptional) {\n                    var optionalToken = match,\n                      mtchsNdx = matches.length;\n                    if (((match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)), match)) {\n                      if (\n                        ($.each(matches, function (ndx, mtch) {\n                          mtchsNdx <= ndx && (mtch.match.optionality = !0);\n                        }),\n                        (latestMatch = matches[matches.length - 1].match),\n                        void 0 !== quantifierRecurse || !isFirstMatch(latestMatch, optionalToken))\n                      )\n                        return !0;\n                      (insertStop = !0), (testPos = pos);\n                    }\n                  } else if (match.isAlternator) {\n                    var alternateToken = match,\n                      malternateMatches = [],\n                      maltMatches,\n                      currentMatches = matches.slice(),\n                      loopNdxCnt = loopNdx.length,\n                      altIndex = 0 < ndxInitializer.length ? ndxInitializer.shift() : -1;\n                    if (-1 === altIndex || 'string' == typeof altIndex) {\n                      var currentPos = testPos,\n                        ndxInitializerClone = ndxInitializer.slice(),\n                        altIndexArr = [],\n                        amndx;\n                      if ('string' == typeof altIndex) altIndexArr = altIndex.split(',');\n                      else\n                        for (amndx = 0; amndx < alternateToken.matches.length; amndx++)\n                          altIndexArr.push(amndx.toString());\n                      if (void 0 !== maskset.excludes[pos]) {\n                        for (\n                          var altIndexArrClone = altIndexArr.slice(), i = 0, el = maskset.excludes[pos].length;\n                          i < el;\n                          i++\n                        ) {\n                          var excludeSet = maskset.excludes[pos][i].toString().split(':');\n                          loopNdx.length == excludeSet[1] && altIndexArr.splice(altIndexArr.indexOf(excludeSet[0]), 1);\n                        }\n                        0 === altIndexArr.length && (delete maskset.excludes[pos], (altIndexArr = altIndexArrClone));\n                      }\n                      (!0 === opts.keepStatic ||\n                        (isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic)) &&\n                        (altIndexArr = altIndexArr.slice(0, 1));\n                      for (var unMatchedAlternation = !1, ndx = 0; ndx < altIndexArr.length; ndx++) {\n                        (amndx = parseInt(altIndexArr[ndx])),\n                          (matches = []),\n                          (ndxInitializer =\n                            ('string' == typeof altIndex && resolveNdxInitializer(testPos, amndx, loopNdxCnt)) ||\n                            ndxInitializerClone.slice()),\n                          alternateToken.matches[amndx] &&\n                          handleMatch(alternateToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse)\n                            ? (match = !0)\n                            : 0 === ndx && (unMatchedAlternation = !0),\n                          (maltMatches = matches.slice()),\n                          (testPos = currentPos),\n                          (matches = []);\n                        for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\n                          var altMatch = maltMatches[ndx1],\n                            dropMatch = !1;\n                          (altMatch.match.jit = altMatch.match.jit || unMatchedAlternation),\n                            (altMatch.alternation = altMatch.alternation || loopNdxCnt),\n                            setMergeLocators(altMatch);\n                          for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\n                            var altMatch2 = malternateMatches[ndx2];\n                            if (\n                              'string' != typeof altIndex ||\n                              (void 0 !== altMatch.alternation &&\n                                -1 !== $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr))\n                            ) {\n                              if (altMatch.match.nativeDef === altMatch2.match.nativeDef) {\n                                (dropMatch = !0), setMergeLocators(altMatch2, altMatch);\n                                break;\n                              }\n                              if (isSubsetOf(altMatch, altMatch2)) {\n                                setMergeLocators(altMatch, altMatch2) &&\n                                  ((dropMatch = !0),\n                                  malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));\n                                break;\n                              }\n                              if (isSubsetOf(altMatch2, altMatch)) {\n                                setMergeLocators(altMatch2, altMatch);\n                                break;\n                              }\n                              if (staticCanMatchDefinition(altMatch, altMatch2)) {\n                                setMergeLocators(altMatch, altMatch2) &&\n                                  ((dropMatch = !0),\n                                  malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));\n                                break;\n                              }\n                            }\n                          }\n                          dropMatch || malternateMatches.push(altMatch);\n                        }\n                      }\n                      (matches = currentMatches.concat(malternateMatches)),\n                        (testPos = pos),\n                        (insertStop = 0 < matches.length),\n                        (match = 0 < malternateMatches.length),\n                        (ndxInitializer = ndxInitializerClone.slice());\n                    } else\n                      match = handleMatch(\n                        alternateToken.matches[altIndex] || maskToken.matches[altIndex],\n                        [altIndex].concat(loopNdx),\n                        quantifierRecurse\n                      );\n                    if (match) return !0;\n                  } else if (\n                    match.isQuantifier &&\n                    quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]\n                  )\n                    for (\n                      var qt = match, qndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0;\n                      qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos;\n                      qndx++\n                    ) {\n                      var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\n                      if (((match = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup)), match)) {\n                        if (\n                          ((latestMatch = matches[matches.length - 1].match),\n                          (latestMatch.optionalQuantifier = qndx >= qt.quantifier.min),\n                          (latestMatch.jit =\n                            (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit),\n                          latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup))\n                        ) {\n                          (insertStop = !0), (testPos = pos);\n                          break;\n                        }\n                        return (\n                          latestMatch.jit &&\n                            (maskset.jitOffset[pos] =\n                              tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch)),\n                          !0\n                        );\n                      }\n                    }\n                  else if (((match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)), match))\n                    return !0;\n                } else testPos++;\n              }\n              for (\n                var tndx = 0 < ndxInitializer.length ? ndxInitializer.shift() : 0;\n                tndx < maskToken.matches.length;\n                tndx++\n              )\n                if (!0 !== maskToken.matches[tndx].isQuantifier) {\n                  var match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);\n                  if (match && testPos === pos) return match;\n                  if (pos < testPos) break;\n                }\n            }\n            function mergeLocators(pos, tests) {\n              var locator = [];\n              return (\n                $.isArray(tests) || (tests = [tests]),\n                0 < tests.length &&\n                  (void 0 === tests[0].alternation || !0 === opts.keepStatic\n                    ? ((locator = determineTestTemplate(pos, tests.slice()).locator.slice()),\n                      0 === locator.length && (locator = tests[0].locator.slice()))\n                    : $.each(tests, function (ndx, tst) {\n                        if ('' !== tst.def)\n                          if (0 === locator.length) locator = tst.locator.slice();\n                          else\n                            for (var i = 0; i < locator.length; i++)\n                              tst.locator[i] &&\n                                -1 === locator[i].toString().indexOf(tst.locator[i]) &&\n                                (locator[i] += ',' + tst.locator[i]);\n                      })),\n                locator\n              );\n            }\n            if (-1 < pos && (void 0 === maxLength || pos < maxLength)) {\n              if (void 0 === ndxIntlzr) {\n                for (\n                  var previousPos = pos - 1, test;\n                  void 0 === (test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) &&\n                  -1 < previousPos;\n\n                )\n                  previousPos--;\n                void 0 !== test &&\n                  -1 < previousPos &&\n                  ((ndxInitializer = mergeLocators(previousPos, test)),\n                  (cacheDependency = ndxInitializer.join('')),\n                  (testPos = previousPos));\n              }\n              if (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) return maskset.tests[pos];\n              for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\n                var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);\n                if ((match && testPos === pos) || pos < testPos) break;\n              }\n            }\n            return (\n              (0 !== matches.length && !insertStop) ||\n                matches.push({\n                  match: { fn: null, static: !0, optionality: !1, casing: null, def: '', placeholder: '' },\n                  locator: [],\n                  mloc: {},\n                  cd: cacheDependency,\n                }),\n              void 0 !== ndxIntlzr && maskset.tests[pos]\n                ? $.extend(!0, [], matches)\n                : ((maskset.tests[pos] = $.extend(!0, [], matches)), maskset.tests[pos])\n            );\n          }\n          function getBufferTemplate() {\n            return (\n              void 0 === maskset._buffer &&\n                ((maskset._buffer = getMaskTemplate(!1, 1)),\n                void 0 === maskset.buffer && (maskset.buffer = maskset._buffer.slice())),\n              maskset._buffer\n            );\n          }\n          function getBuffer(noCache) {\n            return (\n              (void 0 !== maskset.buffer && !0 !== noCache) ||\n                ((maskset.buffer = getMaskTemplate(!0, getLastValidPosition(), !0)),\n                void 0 === maskset._buffer && (maskset._buffer = maskset.buffer.slice())),\n              maskset.buffer\n            );\n          }\n          function refreshFromBuffer(start, end, buffer) {\n            var i,\n              p,\n              skipOptionalPartCharacter = opts.skipOptionalPartCharacter,\n              bffr = isRTL ? buffer.slice().reverse() : buffer;\n            if (((opts.skipOptionalPartCharacter = ''), !0 === start))\n              resetMaskSet(),\n                (maskset.tests = {}),\n                (start = 0),\n                (end = buffer.length),\n                (p = determineNewCaretPosition({ begin: 0, end: 0 }, !1).begin);\n            else {\n              for (i = start; i < end; i++) delete maskset.validPositions[i];\n              p = start;\n            }\n            var keypress = new $.Event('keypress');\n            for (i = start; i < end; i++) {\n              (keypress.which = bffr[i].toString().charCodeAt(0)), (ignorable = !1);\n              var valResult = EventHandlers.keypressEvent.call(el, keypress, !0, !1, !1, p);\n              !1 !== valResult && (p = valResult.forwardPosition);\n            }\n            opts.skipOptionalPartCharacter = skipOptionalPartCharacter;\n          }\n          function casing(elem, test, pos) {\n            switch (opts.casing || test.casing) {\n              case 'upper':\n                elem = elem.toUpperCase();\n                break;\n              case 'lower':\n                elem = elem.toLowerCase();\n                break;\n              case 'title':\n                var posBefore = maskset.validPositions[pos - 1];\n                elem =\n                  0 === pos || (posBefore && posBefore.input === String.fromCharCode(keyCode.SPACE))\n                    ? elem.toUpperCase()\n                    : elem.toLowerCase();\n                break;\n              default:\n                if ($.isFunction(opts.casing)) {\n                  var args = Array.prototype.slice.call(arguments);\n                  args.push(maskset.validPositions), (elem = opts.casing.apply(this, args));\n                }\n            }\n            return elem;\n          }\n          function checkAlternationMatch(altArr1, altArr2, na) {\n            for (\n              var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),\n                isMatch = !1,\n                naArr = void 0 !== na ? na.split(',') : [],\n                naNdx,\n                i = 0;\n              i < naArr.length;\n              i++\n            )\n              -1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1);\n            for (var alndx = 0; alndx < altArr1.length; alndx++)\n              if (-1 !== $.inArray(altArr1[alndx], altArrC)) {\n                isMatch = !0;\n                break;\n              }\n            return isMatch;\n          }\n          function alternate(maskPos, c, strict, fromIsValid, rAltPos, selection) {\n            var validPsClone = $.extend(!0, {}, maskset.validPositions),\n              tstClone = $.extend(!0, {}, maskset.tests),\n              lastAlt,\n              alternation,\n              isValidRslt = !1,\n              returnRslt = !1,\n              altPos,\n              prevAltPos,\n              i,\n              validPos,\n              decisionPos,\n              lAltPos = void 0 !== rAltPos ? rAltPos : getLastValidPosition(),\n              nextPos,\n              input,\n              begin,\n              end;\n            if (\n              (selection &&\n                ((begin = selection.begin),\n                (end = selection.end),\n                selection.begin > selection.end && ((begin = selection.end), (end = selection.begin))),\n              -1 === lAltPos && void 0 === rAltPos)\n            )\n              (lastAlt = 0), (prevAltPos = getTest(lastAlt)), (alternation = prevAltPos.alternation);\n            else\n              for (; 0 <= lAltPos; lAltPos--)\n                if (((altPos = maskset.validPositions[lAltPos]), altPos && void 0 !== altPos.alternation)) {\n                  if (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation])\n                    break;\n                  (lastAlt = lAltPos),\n                    (alternation = maskset.validPositions[lastAlt].alternation),\n                    (prevAltPos = altPos);\n                }\n            if (void 0 !== alternation) {\n              (decisionPos = parseInt(lastAlt)),\n                (maskset.excludes[decisionPos] = maskset.excludes[decisionPos] || []),\n                !0 !== maskPos &&\n                  maskset.excludes[decisionPos].push(getDecisionTaker(prevAltPos) + ':' + prevAltPos.alternation);\n              var validInputs = [],\n                resultPos = -1;\n              for (i = decisionPos; i < getLastValidPosition(void 0, !0) + 1; i++)\n                -1 === resultPos &&\n                  maskPos <= i &&\n                  void 0 !== c &&\n                  (validInputs.push(c), (resultPos = validInputs.length - 1)),\n                  (validPos = maskset.validPositions[i]),\n                  validPos &&\n                    !0 !== validPos.generatedInput &&\n                    (void 0 === selection || i < begin || end <= i) &&\n                    validInputs.push(validPos.input),\n                  delete maskset.validPositions[i];\n              for (\n                -1 === resultPos && void 0 !== c && (validInputs.push(c), (resultPos = validInputs.length - 1));\n                void 0 !== maskset.excludes[decisionPos] && maskset.excludes[decisionPos].length < 10;\n\n              ) {\n                for (\n                  maskset.tests = {}, resetMaskSet(!0), isValidRslt = !0, i = 0;\n                  i < validInputs.length &&\n                  ((nextPos = isValidRslt.caret || getLastValidPosition(void 0, !0) + 1),\n                  (input = validInputs[i]),\n                  (isValidRslt = isValid(nextPos, input, !1, fromIsValid, !0)));\n                  i++\n                )\n                  i === resultPos && (returnRslt = isValidRslt),\n                    1 == maskPos && isValidRslt && (returnRslt = { caretPos: i });\n                if (isValidRslt) break;\n                if (\n                  (resetMaskSet(),\n                  (prevAltPos = getTest(decisionPos)),\n                  (maskset.validPositions = $.extend(!0, {}, validPsClone)),\n                  (maskset.tests = $.extend(!0, {}, tstClone)),\n                  !maskset.excludes[decisionPos])\n                ) {\n                  returnRslt = alternate(maskPos, c, strict, fromIsValid, decisionPos - 1, selection);\n                  break;\n                }\n                var decisionTaker = getDecisionTaker(prevAltPos);\n                if (-1 !== maskset.excludes[decisionPos].indexOf(decisionTaker + ':' + prevAltPos.alternation)) {\n                  returnRslt = alternate(maskPos, c, strict, fromIsValid, decisionPos - 1, selection);\n                  break;\n                }\n                for (\n                  maskset.excludes[decisionPos].push(decisionTaker + ':' + prevAltPos.alternation), i = decisionPos;\n                  i < getLastValidPosition(void 0, !0) + 1;\n                  i++\n                )\n                  delete maskset.validPositions[i];\n              }\n            }\n            return (returnRslt && !1 === opts.keepStatic) || delete maskset.excludes[decisionPos], returnRslt;\n          }\n          function isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly) {\n            function isSelection(posObj) {\n              return isRTL\n                ? 1 < posObj.begin - posObj.end || posObj.begin - posObj.end == 1\n                : 1 < posObj.end - posObj.begin || posObj.end - posObj.begin == 1;\n            }\n            strict = !0 === strict;\n            var maskPos = pos;\n            function processCommandObject(commandObj) {\n              if (void 0 !== commandObj) {\n                if (\n                  (void 0 !== commandObj.remove &&\n                    ($.isArray(commandObj.remove) || (commandObj.remove = [commandObj.remove]),\n                    $.each(\n                      commandObj.remove.sort(function (a, b) {\n                        return b.pos - a.pos;\n                      }),\n                      function (ndx, lmnt) {\n                        revalidateMask({ begin: lmnt, end: lmnt + 1 });\n                      }\n                    ),\n                    (commandObj.remove = void 0)),\n                  void 0 !== commandObj.insert &&\n                    ($.isArray(commandObj.insert) || (commandObj.insert = [commandObj.insert]),\n                    $.each(\n                      commandObj.insert.sort(function (a, b) {\n                        return a.pos - b.pos;\n                      }),\n                      function (ndx, lmnt) {\n                        '' !== lmnt.c &&\n                          isValid(\n                            lmnt.pos,\n                            lmnt.c,\n                            void 0 === lmnt.strict || lmnt.strict,\n                            void 0 !== lmnt.fromIsValid ? lmnt.fromIsValid : fromIsValid\n                          );\n                      }\n                    ),\n                    (commandObj.insert = void 0)),\n                  commandObj.refreshFromBuffer && commandObj.buffer)\n                ) {\n                  var refresh = commandObj.refreshFromBuffer;\n                  refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, commandObj.buffer),\n                    (commandObj.refreshFromBuffer = void 0);\n                }\n                void 0 !== commandObj.rewritePosition && ((maskPos = commandObj.rewritePosition), (commandObj = !0));\n              }\n              return commandObj;\n            }\n            function _isValid(position, c, strict) {\n              var rslt = !1;\n              return (\n                $.each(getTests(position), function (ndx, tst) {\n                  var test = tst.match;\n                  if (\n                    (getBuffer(!0),\n                    (rslt =\n                      null != test.fn\n                        ? test.fn.test(c, maskset, position, strict, opts, isSelection(pos))\n                        : (c === test.def || c === opts.skipOptionalPartCharacter) &&\n                          '' !== test.def && { c: getPlaceholder(position, test, !0) || test.def, pos: position }),\n                    !1 !== rslt)\n                  ) {\n                    var elem = void 0 !== rslt.c ? rslt.c : c,\n                      validatedPos = position;\n                    return (\n                      (elem =\n                        elem === opts.skipOptionalPartCharacter && !0 === test.static\n                          ? getPlaceholder(position, test, !0) || test.def\n                          : elem),\n                      (rslt = processCommandObject(rslt)),\n                      !0 !== rslt && void 0 !== rslt.pos && rslt.pos !== position && (validatedPos = rslt.pos),\n                      !0 !== rslt && void 0 === rslt.pos && void 0 === rslt.c\n                        ? !1\n                        : (!1 ===\n                            revalidateMask(\n                              pos,\n                              $.extend({}, tst, { input: casing(elem, test, validatedPos) }),\n                              fromIsValid,\n                              validatedPos\n                            ) && (rslt = !1),\n                          !1)\n                    );\n                  }\n                }),\n                rslt\n              );\n            }\n            void 0 !== pos.begin && (maskPos = isRTL ? pos.end : pos.begin);\n            var result = !0,\n              positionsClone = $.extend(!0, {}, maskset.validPositions);\n            if (\n              !1 === opts.keepStatic &&\n              void 0 !== maskset.excludes[maskPos] &&\n              !0 !== fromAlternate &&\n              !0 !== fromIsValid\n            )\n              for (var i = maskPos; i < (isRTL ? pos.begin : pos.end); i++)\n                void 0 !== maskset.excludes[i] && ((maskset.excludes[i] = void 0), delete maskset.tests[i]);\n            if (\n              ($.isFunction(opts.preValidation) &&\n                !0 !== fromIsValid &&\n                !0 !== validateOnly &&\n                ((result = opts.preValidation.call(\n                  el,\n                  getBuffer(),\n                  maskPos,\n                  c,\n                  isSelection(pos),\n                  opts,\n                  maskset,\n                  pos,\n                  strict || fromAlternate\n                )),\n                (result = processCommandObject(result))),\n              !0 === result)\n            ) {\n              if (void 0 === maxLength || maskPos < maxLength) {\n                if (\n                  ((result = _isValid(maskPos, c, strict)),\n                  (!strict || !0 === fromIsValid) && !1 === result && !0 !== validateOnly)\n                ) {\n                  var currentPosValid = maskset.validPositions[maskPos];\n                  if (\n                    !currentPosValid ||\n                    !0 !== currentPosValid.match.static ||\n                    (currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter)\n                  ) {\n                    if (opts.insertMode || void 0 === maskset.validPositions[seekNext(maskPos)] || pos.end > maskPos) {\n                      var skip = !1;\n                      if (\n                        (maskset.jitOffset[maskPos] &&\n                          void 0 === maskset.validPositions[seekNext(maskPos)] &&\n                          ((result = isValid(maskPos + maskset.jitOffset[maskPos], c, !0)),\n                          !1 !== result && (!0 !== fromAlternate && (result.caret = maskPos), (skip = !0))),\n                        pos.end > maskPos && (maskset.validPositions[maskPos] = void 0),\n                        !skip && !isMask(maskPos, opts.keepStatic))\n                      )\n                        for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++)\n                          if (((result = _isValid(nPos, c, strict)), !1 !== result)) {\n                            (result = trackbackPositions(maskPos, void 0 !== result.pos ? result.pos : nPos) || result),\n                              (maskPos = nPos);\n                            break;\n                          }\n                    }\n                  } else result = { caret: seekNext(maskPos) };\n                }\n              } else result = !1;\n              !1 !== result ||\n              !opts.keepStatic ||\n              (!isComplete(getBuffer()) && 0 !== maskPos) ||\n              strict ||\n              !0 === fromAlternate\n                ? isSelection(pos) &&\n                  maskset.tests[maskPos] &&\n                  1 < maskset.tests[maskPos].length &&\n                  opts.keepStatic &&\n                  !strict &&\n                  !0 !== fromAlternate &&\n                  (result = alternate(!0))\n                : (result = alternate(maskPos, c, strict, fromIsValid, void 0, pos)),\n                !0 === result && (result = { pos: maskPos });\n            }\n            if ($.isFunction(opts.postValidation) && !0 !== fromIsValid && !0 !== validateOnly) {\n              var postResult = opts.postValidation.call(\n                el,\n                getBuffer(!0),\n                void 0 !== pos.begin ? (isRTL ? pos.end : pos.begin) : pos,\n                c,\n                result,\n                opts,\n                maskset,\n                strict\n              );\n              void 0 !== postResult && (result = !0 === postResult ? result : postResult);\n            }\n            result && void 0 === result.pos && (result.pos = maskPos),\n              !1 === result || !0 === validateOnly\n                ? (resetMaskSet(!0), (maskset.validPositions = $.extend(!0, {}, positionsClone)))\n                : trackbackPositions(void 0, maskPos, !0);\n            var endResult = processCommandObject(result);\n            return endResult;\n          }\n          function trackbackPositions(originalPos, newPos, fillOnly) {\n            if (void 0 === originalPos)\n              for (originalPos = newPos - 1; 0 < originalPos && !maskset.validPositions[originalPos]; originalPos--);\n            for (var ps = originalPos; ps < newPos; ps++)\n              if (void 0 === maskset.validPositions[ps] && !isMask(ps, !0)) {\n                var vp = 0 == ps ? getTest(ps) : maskset.validPositions[ps - 1];\n                if (vp) {\n                  var tests = getTests(ps).slice();\n                  '' === tests[tests.length - 1].match.def && tests.pop();\n                  var bestMatch = determineTestTemplate(ps, tests),\n                    np;\n                  if (\n                    bestMatch &&\n                    (!0 !== bestMatch.match.jit ||\n                      ('master' === bestMatch.match.newBlockMarker &&\n                        (np = maskset.validPositions[ps + 1]) &&\n                        !0 === np.match.optionalQuantifier)) &&\n                    ((bestMatch = $.extend({}, bestMatch, {\n                      input: getPlaceholder(ps, bestMatch.match, !0) || bestMatch.match.def,\n                    })),\n                    (bestMatch.generatedInput = !0),\n                    revalidateMask(ps, bestMatch, !0),\n                    !0 !== fillOnly)\n                  ) {\n                    var cvpInput = maskset.validPositions[newPos].input;\n                    return (maskset.validPositions[newPos] = void 0), isValid(newPos, cvpInput, !0, !0);\n                  }\n                }\n              }\n          }\n          function revalidateMask(pos, validTest, fromIsValid, validatedPos) {\n            function IsEnclosedStatic(pos, valids, selection) {\n              var posMatch = valids[pos];\n              if (\n                void 0 === posMatch ||\n                !0 !== posMatch.match.static ||\n                !0 === posMatch.match.optionality ||\n                (void 0 !== valids[0] && void 0 !== valids[0].alternation)\n              )\n                return !1;\n              var prevMatch =\n                  selection.begin <= pos - 1\n                    ? valids[pos - 1] && !0 === valids[pos - 1].match.static && valids[pos - 1]\n                    : valids[pos - 1],\n                nextMatch =\n                  selection.end > pos + 1\n                    ? valids[pos + 1] && !0 === valids[pos + 1].match.static && valids[pos + 1]\n                    : valids[pos + 1];\n              return prevMatch && nextMatch;\n            }\n            var offset = 0,\n              begin = void 0 !== pos.begin ? pos.begin : pos,\n              end = void 0 !== pos.end ? pos.end : pos;\n            if (\n              (pos.begin > pos.end && ((begin = pos.end), (end = pos.begin)),\n              (validatedPos = void 0 !== validatedPos ? validatedPos : begin),\n              begin !== end ||\n                (opts.insertMode && void 0 !== maskset.validPositions[validatedPos] && void 0 === fromIsValid) ||\n                void 0 === validTest)\n            ) {\n              var positionsClone = $.extend(!0, {}, maskset.validPositions),\n                lvp = getLastValidPosition(void 0, !0),\n                i;\n              for (maskset.p = begin, i = lvp; begin <= i; i--)\n                delete maskset.validPositions[i], void 0 === validTest && delete maskset.tests[i + 1];\n              var valid = !0,\n                j = validatedPos,\n                posMatch = j,\n                t,\n                canMatch;\n              for (\n                i = j,\n                  validTest &&\n                    ((maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest)),\n                    posMatch++,\n                    j++,\n                    begin < end && i++);\n                i <= lvp;\n                i++\n              ) {\n                if (\n                  void 0 !== (t = positionsClone[i]) &&\n                  !0 !== t.generatedInput &&\n                  (end <= i || (begin <= i && IsEnclosedStatic(i, positionsClone, { begin: begin, end: end })))\n                ) {\n                  for (; '' !== getTest(posMatch).match.def; ) {\n                    if (!1 !== (canMatch = positionCanMatchDefinition(posMatch, t, opts)) || '+' === t.match.def) {\n                      '+' === t.match.def && getBuffer(!0);\n                      var result = isValid(posMatch, t.input, '+' !== t.match.def, '+' !== t.match.def);\n                      if (((valid = !1 !== result), (j = (result.pos || posMatch) + 1), !valid && canMatch)) break;\n                    } else valid = !1;\n                    if (valid) {\n                      void 0 === validTest && t.match.static && i === pos.begin && offset++;\n                      break;\n                    }\n                    if (!valid && posMatch > maskset.maskLength) break;\n                    posMatch++;\n                  }\n                  '' == getTest(posMatch).match.def && (valid = !1), (posMatch = j);\n                }\n                if (!valid) break;\n              }\n              if (!valid) return (maskset.validPositions = $.extend(!0, {}, positionsClone)), resetMaskSet(!0), !1;\n            } else\n              validTest &&\n                getTest(validatedPos).match.cd === validTest.match.cd &&\n                (maskset.validPositions[validatedPos] = $.extend(!0, {}, validTest));\n            return resetMaskSet(!0), offset;\n          }\n          function isMask(pos, strict, fuzzy) {\n            var test = getTestTemplate(pos).match;\n            if (('' === test.def && (test = getTest(pos).match), !0 !== test.static)) return test.fn;\n            if (\n              !0 === fuzzy &&\n              void 0 !== maskset.validPositions[pos] &&\n              !0 !== maskset.validPositions[pos].generatedInput\n            )\n              return !0;\n            if (!0 !== strict && -1 < pos) {\n              if (fuzzy) {\n                var tests = getTests(pos);\n                return tests.length > 1 + ('' === tests[tests.length - 1].match.def ? 1 : 0);\n              }\n              var testTemplate = determineTestTemplate(pos, getTests(pos)),\n                testPlaceHolder = getPlaceholder(pos, testTemplate.match);\n              return testTemplate.match.def !== testPlaceHolder;\n            }\n            return !1;\n          }\n          function seekNext(pos, newBlock, fuzzy) {\n            void 0 === fuzzy && (fuzzy = !0);\n            for (\n              var position = pos + 1;\n              '' !== getTest(position).match.def &&\n              ((!0 === newBlock && (!0 !== getTest(position).match.newBlockMarker || !isMask(position, void 0, !0))) ||\n                (!0 !== newBlock && !isMask(position, void 0, fuzzy)));\n\n            )\n              position++;\n            return position;\n          }\n          function seekPrevious(pos, newBlock) {\n            var position = pos,\n              tests;\n            if (position <= 0) return 0;\n            for (\n              ;\n              0 < --position &&\n              ((!0 === newBlock && !0 !== getTest(position).match.newBlockMarker) ||\n                (!0 !== newBlock &&\n                  !isMask(position, void 0, !0) &&\n                  ((tests = getTests(position)),\n                  tests.length < 2 || (2 === tests.length && '' === tests[1].match.def))));\n\n            );\n            return position;\n          }\n          function writeBuffer(input, buffer, caretPos, event, triggerEvents) {\n            if (event && $.isFunction(opts.onBeforeWrite)) {\n              var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);\n              if (result) {\n                if (result.refreshFromBuffer) {\n                  var refresh = result.refreshFromBuffer;\n                  refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer),\n                    (buffer = getBuffer(!0));\n                }\n                void 0 !== caretPos && (caretPos = void 0 !== result.caret ? result.caret : caretPos);\n              }\n            }\n            if (\n              void 0 !== input &&\n              (input.inputmask._valueSet(buffer.join('')),\n              void 0 === caretPos ||\n                (void 0 !== event && 'blur' === event.type) ||\n                caret(\n                  input,\n                  caretPos,\n                  void 0,\n                  void 0,\n                  void 0 !== event &&\n                    'keydown' === event.type &&\n                    (event.keyCode === keyCode.DELETE || event.keyCode === keyCode.BACKSPACE)\n                ),\n              !0 === triggerEvents)\n            ) {\n              var $input = $(input),\n                nptVal = input.inputmask._valueGet();\n              (skipInputEvent = !0),\n                $input.trigger('input'),\n                setTimeout(function () {\n                  nptVal === getBufferTemplate().join('')\n                    ? $input.trigger('cleared')\n                    : !0 === isComplete(buffer) && $input.trigger('complete');\n                }, 0);\n            }\n          }\n          function getPlaceholder(pos, test, returnPL) {\n            if (((test = test || getTest(pos).match), void 0 !== test.placeholder || !0 === returnPL))\n              return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;\n            if (!0 !== test.static) return opts.placeholder.charAt(pos % opts.placeholder.length);\n            if (-1 < pos && void 0 === maskset.validPositions[pos]) {\n              var tests = getTests(pos),\n                staticAlternations = [],\n                prevTest;\n              if (tests.length > 1 + ('' === tests[tests.length - 1].match.def ? 1 : 0))\n                for (var i = 0; i < tests.length; i++)\n                  if (\n                    '' !== tests[i].match.def &&\n                    !0 !== tests[i].match.optionality &&\n                    !0 !== tests[i].match.optionalQuantifier &&\n                    (!0 === tests[i].match.static ||\n                      void 0 === prevTest ||\n                      !1 !== tests[i].match.fn.test(prevTest.match.def, maskset, pos, !0, opts)) &&\n                    (staticAlternations.push(tests[i]),\n                    !0 === tests[i].match.static && (prevTest = tests[i]),\n                    1 < staticAlternations.length && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))\n                  )\n                    return opts.placeholder.charAt(pos % opts.placeholder.length);\n            }\n            return test.def;\n          }\n          function HandleNativePlaceholder(npt, value) {\n            if (ie) {\n              if (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || '' === npt.placeholder)) {\n                var buffer = getBuffer().slice(),\n                  nptValue = npt.inputmask._valueGet();\n                if (nptValue !== value) {\n                  var lvp = getLastValidPosition();\n                  -1 === lvp && nptValue === getBufferTemplate().join('')\n                    ? (buffer = [])\n                    : -1 !== lvp && clearOptionalTail(buffer),\n                    writeBuffer(npt, buffer);\n                }\n              }\n            } else\n              npt.placeholder !== value &&\n                ((npt.placeholder = value), '' === npt.placeholder && npt.removeAttribute('placeholder'));\n          }\n          function determineNewCaretPosition(selectedCaret, tabbed) {\n            function doRadixFocus(clickPos) {\n              if ('' !== opts.radixPoint && 0 !== opts.digits) {\n                var vps = maskset.validPositions;\n                if (void 0 === vps[clickPos] || vps[clickPos].input === getPlaceholder(clickPos)) {\n                  if (clickPos < seekNext(-1)) return !0;\n                  var radixPos = $.inArray(opts.radixPoint, getBuffer());\n                  if (-1 !== radixPos) {\n                    for (var vp in vps) if (vps[vp] && radixPos < vp && vps[vp].input !== getPlaceholder(vp)) return !1;\n                    return !0;\n                  }\n                }\n              }\n              return !1;\n            }\n            if (\n              (tabbed &&\n                (isRTL ? (selectedCaret.end = selectedCaret.begin) : (selectedCaret.begin = selectedCaret.end)),\n              selectedCaret.begin === selectedCaret.end)\n            ) {\n              switch (opts.positionCaretOnClick) {\n                case 'none':\n                  break;\n                case 'select':\n                  selectedCaret = { begin: 0, end: getBuffer().length };\n                  break;\n                case 'ignore':\n                  selectedCaret.end = selectedCaret.begin = seekNext(getLastValidPosition());\n                  break;\n                case 'radixFocus':\n                  if (doRadixFocus(selectedCaret.begin)) {\n                    var radixPos = getBuffer().join('').indexOf(opts.radixPoint);\n                    selectedCaret.end = selectedCaret.begin = opts.numericInput ? seekNext(radixPos) : radixPos;\n                    break;\n                  }\n                default:\n                  var clickPosition = selectedCaret.begin,\n                    lvclickPosition = getLastValidPosition(clickPosition, !0),\n                    lastPosition = seekNext(-1 !== lvclickPosition || isMask(0) ? lvclickPosition : 0);\n                  if (clickPosition < lastPosition)\n                    selectedCaret.end = selectedCaret.begin =\n                      isMask(clickPosition, !0) || isMask(clickPosition - 1, !0)\n                        ? clickPosition\n                        : seekNext(clickPosition);\n                  else {\n                    var lvp = maskset.validPositions[lvclickPosition],\n                      tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : void 0, lvp),\n                      placeholder = getPlaceholder(lastPosition, tt.match);\n                    if (\n                      ('' !== placeholder &&\n                        getBuffer()[lastPosition] !== placeholder &&\n                        !0 !== tt.match.optionalQuantifier &&\n                        !0 !== tt.match.newBlockMarker) ||\n                      (!isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder)\n                    ) {\n                      var newPos = seekNext(lastPosition);\n                      (newPos <= clickPosition || clickPosition === lastPosition) && (lastPosition = newPos);\n                    }\n                    selectedCaret.end = selectedCaret.begin = lastPosition;\n                  }\n              }\n              return selectedCaret;\n            }\n          }\n          var EventRuler = {\n              on: function on(input, eventName, eventHandler) {\n                var ev = function ev(e) {\n                  e.originalEvent && ((e = e.originalEvent || e), (arguments[0] = e));\n                  var that = this,\n                    args;\n                  if (void 0 === that.inputmask && 'FORM' !== this.nodeName) {\n                    var imOpts = $.data(that, '_inputmask_opts');\n                    imOpts ? new Inputmask(imOpts).mask(that) : EventRuler.off(that);\n                  } else {\n                    if (\n                      'setvalue' === e.type ||\n                      'FORM' === this.nodeName ||\n                      !(\n                        that.disabled ||\n                        (that.readOnly &&\n                          !(\n                            ('keydown' === e.type && e.ctrlKey && 67 === e.keyCode) ||\n                            (!1 === opts.tabThrough && e.keyCode === keyCode.TAB)\n                          ))\n                      )\n                    ) {\n                      switch (e.type) {\n                        case 'input':\n                          if (!0 === skipInputEvent || (e.inputType && 'insertCompositionText' === e.inputType))\n                            return (skipInputEvent = !1), e.preventDefault();\n                          break;\n                        case 'keydown':\n                          (skipKeyPressEvent = !1), (skipInputEvent = !1);\n                          break;\n                        case 'keypress':\n                          if (!0 === skipKeyPressEvent) return e.preventDefault();\n                          skipKeyPressEvent = !0;\n                          break;\n                        case 'click':\n                        case 'focus':\n                          return (\n                            validationEvent\n                              ? ((validationEvent = !1),\n                                input.blur(),\n                                HandleNativePlaceholder(\n                                  input,\n                                  (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate()).join('')\n                                ),\n                                setTimeout(function () {\n                                  input.focus();\n                                }, 3e3))\n                              : ((args = arguments),\n                                setTimeout(function () {\n                                  eventHandler.apply(that, args);\n                                }, 0)),\n                            !1\n                          );\n                      }\n                      var returnVal = eventHandler.apply(that, arguments);\n                      return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal;\n                    }\n                    e.preventDefault();\n                  }\n                };\n                (input.inputmask.events[eventName] = input.inputmask.events[eventName] || []),\n                  input.inputmask.events[eventName].push(ev),\n                  -1 !== $.inArray(eventName, ['submit', 'reset'])\n                    ? null !== input.form && $(input.form).on(eventName, ev)\n                    : $(input).on(eventName, ev);\n              },\n              off: function off(input, event) {\n                var events;\n                input.inputmask &&\n                  input.inputmask.events &&\n                  (event\n                    ? ((events = []), (events[event] = input.inputmask.events[event]))\n                    : (events = input.inputmask.events),\n                  $.each(events, function (eventName, evArr) {\n                    for (; 0 < evArr.length; ) {\n                      var ev = evArr.pop();\n                      -1 !== $.inArray(eventName, ['submit', 'reset'])\n                        ? null !== input.form && $(input.form).off(eventName, ev)\n                        : $(input).off(eventName, ev);\n                    }\n                    delete input.inputmask.events[eventName];\n                  }));\n              },\n            },\n            EventHandlers = {\n              keydownEvent: function keydownEvent(e) {\n                var input = this,\n                  $input = $(input),\n                  k = e.keyCode,\n                  pos = caret(input),\n                  kdResult = opts.onKeyDown.call(this, e, getBuffer(), pos, opts);\n                if (void 0 !== kdResult) return kdResult;\n                if (\n                  k === keyCode.BACKSPACE ||\n                  k === keyCode.DELETE ||\n                  (iphone && k === keyCode.BACKSPACE_SAFARI) ||\n                  (e.ctrlKey && k === keyCode.X && !('oncut' in input))\n                )\n                  e.preventDefault(),\n                    handleRemove(input, k, pos),\n                    writeBuffer(\n                      input,\n                      getBuffer(!0),\n                      maskset.p,\n                      e,\n                      input.inputmask._valueGet() !== getBuffer().join('')\n                    );\n                else if (k === keyCode.END || k === keyCode.PAGE_DOWN) {\n                  e.preventDefault();\n                  var caretPos = seekNext(getLastValidPosition());\n                  caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, !0);\n                } else\n                  (k === keyCode.HOME && !e.shiftKey) || k === keyCode.PAGE_UP\n                    ? (e.preventDefault(), caret(input, 0, e.shiftKey ? pos.begin : 0, !0))\n                    : ((opts.undoOnEscape && k === keyCode.ESCAPE) || (90 === k && e.ctrlKey)) && !0 !== e.altKey\n                    ? (checkVal(input, !0, !1, undoValue.split('')), $input.trigger('click'))\n                    : !0 === opts.tabThrough && k === keyCode.TAB\n                    ? (!0 === e.shiftKey\n                        ? (!0 === getTest(pos.begin).match.static && (pos.begin = seekNext(pos.begin)),\n                          (pos.end = seekPrevious(pos.begin, !0)),\n                          (pos.begin = seekPrevious(pos.end, !0)))\n                        : ((pos.begin = seekNext(pos.begin, !0)),\n                          (pos.end = seekNext(pos.begin, !0)),\n                          pos.end < maskset.maskLength && pos.end--),\n                      pos.begin < maskset.maskLength && (e.preventDefault(), caret(input, pos.begin, pos.end)))\n                    : e.shiftKey ||\n                      (opts.insertModeVisual &&\n                        !1 === opts.insertMode &&\n                        (k === keyCode.RIGHT\n                          ? setTimeout(function () {\n                              var caretPos = caret(input);\n                              caret(input, caretPos.begin);\n                            }, 0)\n                          : k === keyCode.LEFT &&\n                            setTimeout(function () {\n                              var caretPos_begin = translatePosition(input.inputmask.caretPos.begin),\n                                caretPos_end = translatePosition(input.inputmask.caretPos.end);\n                              caret(\n                                input,\n                                isRTL\n                                  ? caretPos_begin + (caretPos_begin === maskset.maskLength ? 0 : 1)\n                                  : caretPos_begin - (0 === caretPos_begin ? 0 : 1)\n                              );\n                            }, 0)));\n                ignorable = -1 !== $.inArray(k, opts.ignorables);\n              },\n              keypressEvent: function keypressEvent(e, checkval, writeOut, strict, ndx) {\n                var input = this,\n                  $input = $(input),\n                  k = e.which || e.charCode || e.keyCode;\n                if (!(!0 === checkval || (e.ctrlKey && e.altKey)) && (e.ctrlKey || e.metaKey || ignorable))\n                  return (\n                    k === keyCode.ENTER &&\n                      undoValue !== getBuffer().join('') &&\n                      ((undoValue = getBuffer().join('')),\n                      setTimeout(function () {\n                        $input.trigger('change');\n                      }, 0)),\n                    (skipInputEvent = !0),\n                    !0\n                  );\n                if (k) {\n                  (44 !== k && 46 !== k) ||\n                    3 !== e.location ||\n                    '' === opts.radixPoint ||\n                    (k = opts.radixPoint.charCodeAt(0));\n                  var pos = checkval ? { begin: ndx, end: ndx } : caret(input),\n                    forwardPosition,\n                    c = String.fromCharCode(k);\n                  maskset.writeOutBuffer = !0;\n                  var valResult = isValid(pos, c, strict);\n                  if (\n                    (!1 !== valResult &&\n                      (resetMaskSet(!0),\n                      (forwardPosition =\n                        void 0 !== valResult.caret\n                          ? valResult.caret\n                          : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos)),\n                      (maskset.p = forwardPosition)),\n                    (forwardPosition =\n                      opts.numericInput && void 0 === valResult.caret\n                        ? seekPrevious(forwardPosition)\n                        : forwardPosition),\n                    !1 !== writeOut &&\n                      (setTimeout(function () {\n                        opts.onKeyValidation.call(input, k, valResult);\n                      }, 0),\n                      maskset.writeOutBuffer && !1 !== valResult))\n                  ) {\n                    var buffer = getBuffer();\n                    writeBuffer(input, buffer, forwardPosition, e, !0 !== checkval);\n                  }\n                  if ((e.preventDefault(), checkval))\n                    return !1 !== valResult && (valResult.forwardPosition = forwardPosition), valResult;\n                }\n              },\n              pasteEvent: function pasteEvent(e) {\n                var input = this,\n                  inputValue = this.inputmask._valueGet(!0),\n                  caretPos = caret(this),\n                  tempValue;\n                isRTL && ((tempValue = caretPos.end), (caretPos.end = caretPos.begin), (caretPos.begin = tempValue));\n                var valueBeforeCaret = inputValue.substr(0, caretPos.begin),\n                  valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\n                if (\n                  (valueBeforeCaret ==\n                    (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate())\n                      .slice(0, caretPos.begin)\n                      .join('') && (valueBeforeCaret = ''),\n                  valueAfterCaret ==\n                    (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate())\n                      .slice(caretPos.end)\n                      .join('') && (valueAfterCaret = ''),\n                  window.clipboardData && window.clipboardData.getData)\n                )\n                  inputValue = valueBeforeCaret + window.clipboardData.getData('Text') + valueAfterCaret;\n                else {\n                  if (!e.clipboardData || !e.clipboardData.getData) return !0;\n                  inputValue = valueBeforeCaret + e.clipboardData.getData('text/plain') + valueAfterCaret;\n                }\n                var pasteValue = inputValue;\n                if ($.isFunction(opts.onBeforePaste)) {\n                  if (((pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts)), !1 === pasteValue))\n                    return e.preventDefault();\n                  pasteValue = pasteValue || inputValue;\n                }\n                return (\n                  checkVal(this, !1, !1, pasteValue.toString().split('')),\n                  writeBuffer(\n                    this,\n                    getBuffer(),\n                    seekNext(getLastValidPosition()),\n                    e,\n                    undoValue !== getBuffer().join('')\n                  ),\n                  e.preventDefault()\n                );\n              },\n              inputFallBackEvent: function inputFallBackEvent(e) {\n                function ieMobileHandler(input, inputValue, caretPos) {\n                  if (iemobile) {\n                    var inputChar = inputValue.replace(getBuffer().join(''), '');\n                    if (1 === inputChar.length) {\n                      var iv = inputValue.split('');\n                      iv.splice(caretPos.begin, 0, inputChar), (inputValue = iv.join(''));\n                    }\n                  }\n                  return inputValue;\n                }\n                function analyseChanges(inputValue, buffer, caretPos) {\n                  for (\n                    var frontPart = inputValue.substr(0, caretPos.begin).split(''),\n                      backPart = inputValue.substr(caretPos.begin).split(''),\n                      frontBufferPart = buffer.substr(0, caretPos.begin).split(''),\n                      backBufferPart = buffer.substr(caretPos.begin).split(''),\n                      fpl = frontPart.length >= frontBufferPart.length ? frontPart.length : frontBufferPart.length,\n                      bpl = backPart.length >= backBufferPart.length ? backPart.length : backBufferPart.length,\n                      bl,\n                      i,\n                      action = '',\n                      data = [],\n                      marker = '~',\n                      placeholder;\n                    frontPart.length < fpl;\n\n                  )\n                    frontPart.push('~');\n                  for (; frontBufferPart.length < fpl; ) frontBufferPart.push('~');\n                  for (; backPart.length < bpl; ) backPart.unshift('~');\n                  for (; backBufferPart.length < bpl; ) backBufferPart.unshift('~');\n                  var newBuffer = frontPart.concat(backPart),\n                    oldBuffer = frontBufferPart.concat(backBufferPart);\n                  for (i = 0, bl = newBuffer.length; i < bl; i++)\n                    switch (((placeholder = getPlaceholder(translatePosition(i))), action)) {\n                      case 'insertText':\n                        oldBuffer[i - 1] === newBuffer[i] &&\n                          caretPos.begin == newBuffer.length - 1 &&\n                          data.push(newBuffer[i]),\n                          (i = bl);\n                        break;\n                      case 'insertReplacementText':\n                        '~' === newBuffer[i] ? caretPos.end++ : (i = bl);\n                        break;\n                      case 'deleteContentBackward':\n                        '~' === newBuffer[i] ? caretPos.end++ : (i = bl);\n                        break;\n                      default:\n                        newBuffer[i] !== oldBuffer[i] &&\n                          (('~' !== newBuffer[i + 1] &&\n                            newBuffer[i + 1] !== placeholder &&\n                            void 0 !== newBuffer[i + 1]) ||\n                          ((oldBuffer[i] !== placeholder || '~' !== oldBuffer[i + 1]) && '~' !== oldBuffer[i])\n                            ? '~' === oldBuffer[i + 1] && oldBuffer[i] === newBuffer[i + 1]\n                              ? ((action = 'insertText'), data.push(newBuffer[i]), caretPos.begin--, caretPos.end--)\n                              : newBuffer[i] !== placeholder &&\n                                '~' !== newBuffer[i] &&\n                                ('~' === newBuffer[i + 1] ||\n                                  (oldBuffer[i] !== newBuffer[i] && oldBuffer[i + 1] === newBuffer[i + 1]))\n                              ? ((action = 'insertReplacementText'), data.push(newBuffer[i]), caretPos.begin--)\n                              : '~' === newBuffer[i]\n                              ? ((action = 'deleteContentBackward'),\n                                (!isMask(translatePosition(i), !0) && oldBuffer[i] !== opts.radixPoint) ||\n                                  caretPos.end++)\n                              : (i = bl)\n                            : ((action = 'insertText'), data.push(newBuffer[i]), caretPos.begin--, caretPos.end--));\n                        break;\n                    }\n                  return { action: action, data: data, caret: caretPos };\n                }\n                var input = this,\n                  inputValue = input.inputmask._valueGet(!0),\n                  buffer = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(''),\n                  caretPos = caret(input, void 0, void 0, !0);\n                if (buffer !== inputValue) {\n                  inputValue = ieMobileHandler(input, inputValue, caretPos);\n                  var changes = analyseChanges(inputValue, buffer, caretPos);\n                  switch (\n                    ((input.inputmask.shadowRoot || document).activeElement !== input && input.focus(),\n                    writeBuffer(input, getBuffer()),\n                    caret(input, caretPos.begin, caretPos.end, !0),\n                    changes.action)\n                  ) {\n                    case 'insertText':\n                    case 'insertReplacementText':\n                      $.each(changes.data, function (ndx, entry) {\n                        var keypress = new $.Event('keypress');\n                        (keypress.which = entry.charCodeAt(0)),\n                          (ignorable = !1),\n                          EventHandlers.keypressEvent.call(input, keypress);\n                      }),\n                        setTimeout(function () {\n                          $el.trigger('keyup');\n                        }, 0);\n                      break;\n                    case 'deleteContentBackward':\n                      var keydown = new $.Event('keydown');\n                      (keydown.keyCode = keyCode.BACKSPACE), EventHandlers.keydownEvent.call(input, keydown);\n                      break;\n                    default:\n                      applyInputValue(input, inputValue);\n                      break;\n                  }\n                  e.preventDefault();\n                }\n              },\n              compositionendEvent: function compositionendEvent(e) {\n                $el.trigger('input');\n              },\n              setValueEvent: function setValueEvent(e, argument_1, argument_2) {\n                var input = this,\n                  value = e && e.detail ? e.detail[0] : argument_1;\n                void 0 === value && (value = this.inputmask._valueGet(!0)),\n                  applyInputValue(this, value),\n                  ((e.detail && void 0 !== e.detail[1]) || void 0 !== argument_2) &&\n                    caret(this, e.detail ? e.detail[1] : argument_2);\n              },\n              focusEvent: function focusEvent(e) {\n                var input = this,\n                  nptValue = this.inputmask._valueGet();\n                opts.showMaskOnFocus &&\n                  nptValue !== getBuffer().join('') &&\n                  writeBuffer(this, getBuffer(), seekNext(getLastValidPosition())),\n                  !0 !== opts.positionCaretOnTab ||\n                    !1 !== mouseEnter ||\n                    (isComplete(getBuffer()) && -1 !== getLastValidPosition()) ||\n                    EventHandlers.clickEvent.apply(this, [e, !0]),\n                  (undoValue = getBuffer().join(''));\n              },\n              invalidEvent: function invalidEvent(e) {\n                validationEvent = !0;\n              },\n              mouseleaveEvent: function mouseleaveEvent() {\n                var input = this;\n                (mouseEnter = !1),\n                  opts.clearMaskOnLostFocus &&\n                    (this.inputmask.shadowRoot || document).activeElement !== this &&\n                    HandleNativePlaceholder(this, originalPlaceholder);\n              },\n              clickEvent: function clickEvent(e, tabbed) {\n                var input = this;\n                if ((this.inputmask.shadowRoot || document).activeElement === this) {\n                  var newCaretPosition = determineNewCaretPosition(caret(this), tabbed);\n                  void 0 !== newCaretPosition && caret(this, newCaretPosition);\n                }\n              },\n              cutEvent: function cutEvent(e) {\n                var input = this,\n                  pos = caret(this),\n                  clipboardData = window.clipboardData || e.clipboardData,\n                  clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);\n                clipboardData.setData('text', isRTL ? clipData.reverse().join('') : clipData.join('')),\n                  document.execCommand && document.execCommand('copy'),\n                  handleRemove(this, keyCode.DELETE, pos),\n                  writeBuffer(this, getBuffer(), maskset.p, e, undoValue !== getBuffer().join(''));\n              },\n              blurEvent: function blurEvent(e) {\n                var $input = $(this),\n                  input = this;\n                if (this.inputmask) {\n                  HandleNativePlaceholder(this, originalPlaceholder);\n                  var nptValue = this.inputmask._valueGet(),\n                    buffer = getBuffer().slice();\n                  '' !== nptValue &&\n                    (opts.clearMaskOnLostFocus &&\n                      (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join('')\n                        ? (buffer = [])\n                        : clearOptionalTail(buffer)),\n                    !1 === isComplete(buffer) &&\n                      (setTimeout(function () {\n                        $input.trigger('incomplete');\n                      }, 0),\n                      opts.clearIncomplete &&\n                        (resetMaskSet(), (buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice()))),\n                    writeBuffer(this, buffer, void 0, e)),\n                    undoValue !== getBuffer().join('') &&\n                      ((undoValue = getBuffer().join('')), $input.trigger('change'));\n                }\n              },\n              mouseenterEvent: function mouseenterEvent() {\n                var input = this;\n                (mouseEnter = !0),\n                  (this.inputmask.shadowRoot || document).activeElement !== this &&\n                    (null == originalPlaceholder &&\n                      this.placeholder !== originalPlaceholder &&\n                      (originalPlaceholder = this.placeholder),\n                    opts.showMaskOnHover &&\n                      HandleNativePlaceholder(\n                        this,\n                        (isRTL ? getBufferTemplate().slice().reverse() : getBufferTemplate()).join('')\n                      ));\n              },\n              submitEvent: function submitEvent() {\n                undoValue !== getBuffer().join('') && $el.trigger('change'),\n                  opts.clearMaskOnLostFocus &&\n                    -1 === getLastValidPosition() &&\n                    el.inputmask._valueGet &&\n                    el.inputmask._valueGet() === getBufferTemplate().join('') &&\n                    el.inputmask._valueSet(''),\n                  opts.clearIncomplete && !1 === isComplete(getBuffer()) && el.inputmask._valueSet(''),\n                  opts.removeMaskOnSubmit &&\n                    (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0),\n                    setTimeout(function () {\n                      writeBuffer(el, getBuffer());\n                    }, 0));\n              },\n              resetEvent: function resetEvent() {\n                (el.inputmask.refreshValue = !0),\n                  setTimeout(function () {\n                    applyInputValue(el, el.inputmask._valueGet(!0));\n                  }, 0);\n              },\n            },\n            valueBuffer;\n          function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {\n            var inputmask = this || input.inputmask,\n              inputValue = nptvl.slice(),\n              charCodes = '',\n              initialNdx = -1,\n              result = void 0;\n            function isTemplateMatch(ndx, charCodes) {\n              for (\n                var targetTemplate = getMaskTemplate(!0, 0).slice(ndx, seekNext(ndx)).join('').replace(/'/g, ''),\n                  charCodeNdx = targetTemplate.indexOf(charCodes);\n                0 < charCodeNdx && ' ' === targetTemplate[charCodeNdx - 1];\n\n              )\n                charCodeNdx--;\n              var match =\n                0 === charCodeNdx &&\n                !isMask(ndx) &&\n                (getTest(ndx).match.nativeDef === charCodes.charAt(0) ||\n                  (!0 === getTest(ndx).match.static && getTest(ndx).match.nativeDef === \"'\" + charCodes.charAt(0)) ||\n                  (' ' === getTest(ndx).match.nativeDef &&\n                    (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0) ||\n                      (!0 === getTest(ndx + 1).match.static &&\n                        getTest(ndx + 1).match.nativeDef === \"'\" + charCodes.charAt(0)))));\n              return !match && 0 < charCodeNdx && (inputmask.caretPos = { begin: seekNext(charCodeNdx) }), match;\n            }\n            resetMaskSet(),\n              (maskset.tests = {}),\n              (initialNdx = opts.radixPoint ? determineNewCaretPosition({ begin: 0, end: 0 }).begin : 0),\n              (maskset.p = initialNdx),\n              (inputmask.caretPos = { begin: initialNdx });\n            var staticMatches = [],\n              prevCaretPos = inputmask.caretPos;\n            if (\n              ($.each(inputValue, function (ndx, charCode) {\n                if (void 0 !== charCode)\n                  if (\n                    void 0 === maskset.validPositions[ndx] &&\n                    inputValue[ndx] === getPlaceholder(ndx) &&\n                    isMask(ndx, !0) &&\n                    !1 === isValid(ndx, inputValue[ndx], !0, void 0, void 0, !0)\n                  )\n                    maskset.p++;\n                  else {\n                    var keypress = new $.Event('_checkval');\n                    (keypress.which = charCode.toString().charCodeAt(0)), (charCodes += charCode);\n                    var lvp = getLastValidPosition(void 0, !0);\n                    isTemplateMatch(initialNdx, charCodes)\n                      ? (result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, lvp + 1))\n                      : ((result = EventHandlers.keypressEvent.call(\n                          input,\n                          keypress,\n                          !0,\n                          !1,\n                          strict,\n                          inputmask.caretPos.begin\n                        )),\n                        result && ((initialNdx = inputmask.caretPos.begin + 1), (charCodes = ''))),\n                      result\n                        ? (void 0 !== result.pos &&\n                            maskset.validPositions[result.pos] &&\n                            !0 === maskset.validPositions[result.pos].match.static &&\n                            void 0 === maskset.validPositions[result.pos].alternation &&\n                            (staticMatches.push(result.pos), isRTL || (result.forwardPosition = result.pos + 1)),\n                          writeBuffer(void 0, getBuffer(), result.forwardPosition, keypress, !1),\n                          (inputmask.caretPos = { begin: result.forwardPosition, end: result.forwardPosition }),\n                          (prevCaretPos = inputmask.caretPos))\n                        : (inputmask.caretPos = prevCaretPos);\n                  }\n              }),\n              0 < staticMatches.length)\n            ) {\n              var sndx,\n                validPos,\n                nextValid = seekNext(-1, void 0, !1);\n              if (\n                (!isComplete(getBuffer()) && staticMatches.length <= nextValid) ||\n                (isComplete(getBuffer()) &&\n                  0 < staticMatches.length &&\n                  staticMatches.length !== nextValid &&\n                  0 === staticMatches[0])\n              )\n                for (var nextSndx = nextValid; void 0 !== (sndx = staticMatches.shift()); ) {\n                  var keypress = new $.Event('_checkval');\n                  if (\n                    ((validPos = maskset.validPositions[sndx]),\n                    (validPos.generatedInput = !0),\n                    (keypress.which = validPos.input.charCodeAt(0)),\n                    (result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, nextSndx)),\n                    result &&\n                      void 0 !== result.pos &&\n                      result.pos !== sndx &&\n                      maskset.validPositions[result.pos] &&\n                      !0 === maskset.validPositions[result.pos].match.static)\n                  )\n                    staticMatches.push(result.pos);\n                  else if (!result) break;\n                  nextSndx++;\n                }\n              else\n                for (; (sndx = staticMatches.pop()); )\n                  (validPos = maskset.validPositions[sndx]), validPos && (validPos.generatedInput = !0);\n            }\n            if (writeOut)\n              for (var vndx in (writeBuffer(\n                input,\n                getBuffer(),\n                result ? result.forwardPosition : void 0,\n                initiatingEvent || new $.Event('checkval'),\n                initiatingEvent && 'input' === initiatingEvent.type\n              ),\n              maskset.validPositions))\n                !0 !== maskset.validPositions[vndx].match.generated &&\n                  delete maskset.validPositions[vndx].generatedInput;\n          }\n          function unmaskedvalue(input) {\n            if (input) {\n              if (void 0 === input.inputmask) return input.value;\n              input.inputmask && input.inputmask.refreshValue && applyInputValue(input, input.inputmask._valueGet(!0));\n            }\n            var umValue = [],\n              vps = maskset.validPositions;\n            for (var pndx in vps)\n              vps[pndx] && vps[pndx].match && 1 != vps[pndx].match.static && umValue.push(vps[pndx].input);\n            var unmaskedValue = 0 === umValue.length ? '' : (isRTL ? umValue.reverse() : umValue).join('');\n            if ($.isFunction(opts.onUnMask)) {\n              var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join('');\n              unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);\n            }\n            return unmaskedValue;\n          }\n          function translatePosition(pos) {\n            return (\n              !isRTL ||\n                'number' != typeof pos ||\n                (opts.greedy && '' === opts.placeholder) ||\n                !el ||\n                (pos = el.inputmask._valueGet().length - pos),\n              pos\n            );\n          }\n          function caret(input, begin, end, notranslate, isDelete) {\n            var range;\n            if (void 0 === begin)\n              return (\n                'selectionStart' in input && 'selectionEnd' in input\n                  ? ((begin = input.selectionStart), (end = input.selectionEnd))\n                  : window.getSelection\n                  ? ((range = window.getSelection().getRangeAt(0)),\n                    (range.commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input) ||\n                      ((begin = range.startOffset), (end = range.endOffset)))\n                  : document.selection &&\n                    document.selection.createRange &&\n                    ((range = document.selection.createRange()),\n                    (begin = 0 - range.duplicate().moveStart('character', -input.inputmask._valueGet().length)),\n                    (end = begin + range.text.length)),\n                {\n                  begin: notranslate ? begin : translatePosition(begin),\n                  end: notranslate ? end : translatePosition(end),\n                }\n              );\n            if (\n              ($.isArray(begin) && ((end = isRTL ? begin[0] : begin[1]), (begin = isRTL ? begin[1] : begin[0])),\n              void 0 !== begin.begin &&\n                ((end = isRTL ? begin.begin : begin.end), (begin = isRTL ? begin.end : begin.begin)),\n              'number' == typeof begin)\n            ) {\n              (begin = notranslate ? begin : translatePosition(begin)),\n                (end = notranslate ? end : translatePosition(end)),\n                (end = 'number' == typeof end ? end : begin);\n              var scrollCalc =\n                parseInt(\n                  ((input.ownerDocument.defaultView || window).getComputedStyle\n                    ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null)\n                    : input.currentStyle\n                  ).fontSize\n                ) * end;\n              if (\n                ((input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0),\n                (input.inputmask.caretPos = { begin: begin, end: end }),\n                opts.insertModeVisual && !1 === opts.insertMode && begin === end && (isDelete || end++),\n                input === (input.inputmask.shadowRoot || document).activeElement)\n              )\n                if ('setSelectionRange' in input) input.setSelectionRange(begin, end);\n                else if (window.getSelection) {\n                  if (((range = document.createRange()), void 0 === input.firstChild || null === input.firstChild)) {\n                    var textNode = document.createTextNode('');\n                    input.appendChild(textNode);\n                  }\n                  range.setStart(\n                    input.firstChild,\n                    begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length\n                  ),\n                    range.setEnd(\n                      input.firstChild,\n                      end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length\n                    ),\n                    range.collapse(!0);\n                  var sel = window.getSelection();\n                  sel.removeAllRanges(), sel.addRange(range);\n                } else\n                  input.createTextRange &&\n                    ((range = input.createTextRange()),\n                    range.collapse(!0),\n                    range.moveEnd('character', end),\n                    range.moveStart('character', begin),\n                    range.select());\n            }\n          }\n          function determineLastRequiredPosition(returnDefinition) {\n            var buffer = getMaskTemplate(!0, getLastValidPosition(), !0, !0),\n              bl = buffer.length,\n              pos,\n              lvp = getLastValidPosition(),\n              positions = {},\n              lvTest = maskset.validPositions[lvp],\n              ndxIntlzr = void 0 !== lvTest ? lvTest.locator.slice() : void 0,\n              testPos;\n            for (pos = lvp + 1; pos < buffer.length; pos++)\n              (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1)),\n                (ndxIntlzr = testPos.locator.slice()),\n                (positions[pos] = $.extend(!0, {}, testPos));\n            var lvTestAlt = lvTest && void 0 !== lvTest.alternation ? lvTest.locator[lvTest.alternation] : void 0;\n            for (\n              pos = bl - 1;\n              lvp < pos &&\n              ((testPos = positions[pos]),\n              (testPos.match.optionality ||\n                (testPos.match.optionalQuantifier && testPos.match.newBlockMarker) ||\n                (lvTestAlt &&\n                  ((lvTestAlt !== positions[pos].locator[lvTest.alternation] && 1 != testPos.match.static) ||\n                    (!0 === testPos.match.static &&\n                      testPos.locator[lvTest.alternation] &&\n                      checkAlternationMatch(\n                        testPos.locator[lvTest.alternation].toString().split(','),\n                        lvTestAlt.toString().split(',')\n                      ) &&\n                      '' !== getTests(pos)[0].def)))) &&\n                buffer[pos] === getPlaceholder(pos, testPos.match));\n              pos--\n            )\n              bl--;\n            return returnDefinition ? { l: bl, def: positions[bl] ? positions[bl].match : void 0 } : bl;\n          }\n          function clearOptionalTail(buffer) {\n            buffer.length = 0;\n            for (var template = getMaskTemplate(!0, 0, !0, void 0, !0), lmnt; void 0 !== (lmnt = template.shift()); )\n              buffer.push(lmnt);\n            return buffer;\n          }\n          function isComplete(buffer) {\n            if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);\n            if ('*' !== opts.repeat) {\n              var complete = !1,\n                lrp = determineLastRequiredPosition(!0),\n                aml = seekPrevious(lrp.l);\n              if (void 0 === lrp.def || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\n                complete = !0;\n                for (var i = 0; i <= aml; i++) {\n                  var test = getTestTemplate(i).match;\n                  if (\n                    (!0 !== test.static &&\n                      void 0 === maskset.validPositions[i] &&\n                      !0 !== test.optionality &&\n                      !0 !== test.optionalQuantifier) ||\n                    (!0 === test.static && buffer[i] !== getPlaceholder(i, test))\n                  ) {\n                    complete = !1;\n                    break;\n                  }\n                }\n              }\n              return complete;\n            }\n          }\n          function handleRemove(input, k, pos, strict, fromIsValid) {\n            if (\n              (opts.numericInput || isRTL) &&\n              (k === keyCode.BACKSPACE ? (k = keyCode.DELETE) : k === keyCode.DELETE && (k = keyCode.BACKSPACE), isRTL)\n            ) {\n              var pend = pos.end;\n              (pos.end = pos.begin), (pos.begin = pend);\n            }\n            var offset;\n            if (\n              (k === keyCode.BACKSPACE\n                ? pos.end - pos.begin < 1 && (pos.begin = seekPrevious(pos.begin))\n                : k === keyCode.DELETE &&\n                  pos.begin === pos.end &&\n                  (pos.end = isMask(pos.end, !0, !0) ? pos.end + 1 : seekNext(pos.end) + 1),\n              !1 !== (offset = revalidateMask(pos)))\n            ) {\n              if (\n                (!0 !== strict && !1 !== opts.keepStatic) ||\n                (null !== opts.regex && -1 !== getTest(pos.begin).match.def.indexOf('|'))\n              ) {\n                var result = alternate(!0);\n                if (result) {\n                  var newPos =\n                    void 0 !== result.caret\n                      ? result.caret\n                      : result.pos\n                      ? seekNext(result.pos.begin ? result.pos.begin : result.pos)\n                      : getLastValidPosition(-1, !0);\n                  (k !== keyCode.DELETE || pos.begin > newPos) && pos.begin;\n                }\n              }\n              !0 !== strict && (maskset.p = k === keyCode.DELETE ? pos.begin + offset : pos.begin);\n            }\n          }\n          function applyInputValue(input, value) {\n            (input.inputmask.refreshValue = !1),\n              $.isFunction(opts.onBeforeMask) && (value = opts.onBeforeMask.call(inputmask, value, opts) || value),\n              (value = value.toString().split('')),\n              checkVal(input, !0, !1, value),\n              (undoValue = getBuffer().join('')),\n              (opts.clearMaskOnLostFocus || opts.clearIncomplete) &&\n                input.inputmask._valueGet() === getBufferTemplate().join('') &&\n                -1 === getLastValidPosition() &&\n                input.inputmask._valueSet('');\n          }\n          function mask(elem) {\n            function isElementTypeSupported(input, opts) {\n              function patchValueProperty(npt) {\n                var valueGet, valueSet;\n                function patchValhook(type) {\n                  if ($.valHooks && (void 0 === $.valHooks[type] || !0 !== $.valHooks[type].inputmaskpatch)) {\n                    var valhookGet =\n                        $.valHooks[type] && $.valHooks[type].get\n                          ? $.valHooks[type].get\n                          : function (elem) {\n                              return elem.value;\n                            },\n                      valhookSet =\n                        $.valHooks[type] && $.valHooks[type].set\n                          ? $.valHooks[type].set\n                          : function (elem, value) {\n                              return (elem.value = value), elem;\n                            };\n                    $.valHooks[type] = {\n                      get: function get(elem) {\n                        if (elem.inputmask) {\n                          if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();\n                          var result = valhookGet(elem);\n                          return -1 !== getLastValidPosition(void 0, void 0, elem.inputmask.maskset.validPositions) ||\n                            !0 !== opts.nullable\n                            ? result\n                            : '';\n                        }\n                        return valhookGet(elem);\n                      },\n                      set: function set(elem, value) {\n                        var result = valhookSet(elem, value);\n                        return elem.inputmask && applyInputValue(elem, value), result;\n                      },\n                      inputmaskpatch: !0,\n                    };\n                  }\n                }\n                function getter() {\n                  return this.inputmask\n                    ? this.inputmask.opts.autoUnmask\n                      ? this.inputmask.unmaskedvalue()\n                      : -1 !== getLastValidPosition() || !0 !== opts.nullable\n                      ? (this.inputmask.shadowRoot || document.activeElement) === this && opts.clearMaskOnLostFocus\n                        ? (isRTL\n                            ? clearOptionalTail(getBuffer().slice()).reverse()\n                            : clearOptionalTail(getBuffer().slice())\n                          ).join('')\n                        : valueGet.call(this)\n                      : ''\n                    : valueGet.call(this);\n                }\n                function setter(value) {\n                  valueSet.call(this, value), this.inputmask && applyInputValue(this, value);\n                }\n                function installNativeValueSetFallback(npt) {\n                  EventRuler.on(npt, 'mouseenter', function () {\n                    var input = this,\n                      value = this.inputmask._valueGet(!0);\n                    value !== (isRTL ? getBuffer().reverse() : getBuffer()).join('') && applyInputValue(this, value);\n                  });\n                }\n                if (!npt.inputmask.__valueGet) {\n                  if (!0 !== opts.noValuePatching) {\n                    if (Object.getOwnPropertyDescriptor) {\n                      'function' != typeof Object.getPrototypeOf &&\n                        (Object.getPrototypeOf =\n                          'object' === _typeof('test'.__proto__)\n                            ? function (object) {\n                                return object.__proto__;\n                              }\n                            : function (object) {\n                                return object.constructor.prototype;\n                              });\n                      var valueProperty = Object.getPrototypeOf\n                        ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), 'value')\n                        : void 0;\n                      valueProperty && valueProperty.get && valueProperty.set\n                        ? ((valueGet = valueProperty.get),\n                          (valueSet = valueProperty.set),\n                          Object.defineProperty(npt, 'value', { get: getter, set: setter, configurable: !0 }))\n                        : 'input' !== npt.tagName.toLowerCase() &&\n                          ((valueGet = function valueGet() {\n                            return this.textContent;\n                          }),\n                          (valueSet = function valueSet(value) {\n                            this.textContent = value;\n                          }),\n                          Object.defineProperty(npt, 'value', { get: getter, set: setter, configurable: !0 }));\n                    } else\n                      document.__lookupGetter__ &&\n                        npt.__lookupGetter__('value') &&\n                        ((valueGet = npt.__lookupGetter__('value')),\n                        (valueSet = npt.__lookupSetter__('value')),\n                        npt.__defineGetter__('value', getter),\n                        npt.__defineSetter__('value', setter));\n                    (npt.inputmask.__valueGet = valueGet), (npt.inputmask.__valueSet = valueSet);\n                  }\n                  (npt.inputmask._valueGet = function (overruleRTL) {\n                    return isRTL && !0 !== overruleRTL\n                      ? valueGet.call(this.el).split('').reverse().join('')\n                      : valueGet.call(this.el);\n                  }),\n                    (npt.inputmask._valueSet = function (value, overruleRTL) {\n                      valueSet.call(\n                        this.el,\n                        null == value ? '' : !0 !== overruleRTL && isRTL ? value.split('').reverse().join('') : value\n                      );\n                    }),\n                    void 0 === valueGet &&\n                      ((valueGet = function valueGet() {\n                        return this.value;\n                      }),\n                      (valueSet = function valueSet(value) {\n                        this.value = value;\n                      }),\n                      patchValhook(npt.type),\n                      installNativeValueSetFallback(npt));\n                }\n              }\n              'textarea' !== input.tagName.toLowerCase() && opts.ignorables.push(keyCode.ENTER);\n              var elementType = input.getAttribute('type'),\n                isSupported =\n                  ('input' === input.tagName.toLowerCase() && -1 !== $.inArray(elementType, opts.supportsInputType)) ||\n                  input.isContentEditable ||\n                  'textarea' === input.tagName.toLowerCase();\n              if (!isSupported)\n                if ('input' === input.tagName.toLowerCase()) {\n                  var el = document.createElement('input');\n                  el.setAttribute('type', elementType), (isSupported = 'text' === el.type), (el = null);\n                } else isSupported = 'partial';\n              return !1 !== isSupported ? patchValueProperty(input) : (input.inputmask = void 0), isSupported;\n            }\n            EventRuler.off(elem);\n            var isSupported = isElementTypeSupported(elem, opts);\n            if (!1 !== isSupported) {\n              (el = elem),\n                ($el = $(el)),\n                (originalPlaceholder = el.placeholder),\n                (maxLength = void 0 !== el ? el.maxLength : void 0),\n                -1 === maxLength && (maxLength = void 0),\n                'inputMode' in el &&\n                  null === el.getAttribute('inputmode') &&\n                  ((el.inputMode = opts.inputmode), el.setAttribute('inputmode', opts.inputmode)),\n                !0 === isSupported &&\n                  ((opts.showMaskOnFocus =\n                    opts.showMaskOnFocus && -1 === ['cc-number', 'cc-exp'].indexOf(el.autocomplete)),\n                  iphone && (opts.insertModeVisual = !1),\n                  EventRuler.on(el, 'submit', EventHandlers.submitEvent),\n                  EventRuler.on(el, 'reset', EventHandlers.resetEvent),\n                  EventRuler.on(el, 'blur', EventHandlers.blurEvent),\n                  EventRuler.on(el, 'focus', EventHandlers.focusEvent),\n                  EventRuler.on(el, 'invalid', EventHandlers.invalidEvent),\n                  EventRuler.on(el, 'click', EventHandlers.clickEvent),\n                  EventRuler.on(el, 'mouseleave', EventHandlers.mouseleaveEvent),\n                  EventRuler.on(el, 'mouseenter', EventHandlers.mouseenterEvent),\n                  EventRuler.on(el, 'paste', EventHandlers.pasteEvent),\n                  EventRuler.on(el, 'cut', EventHandlers.cutEvent),\n                  EventRuler.on(el, 'complete', opts.oncomplete),\n                  EventRuler.on(el, 'incomplete', opts.onincomplete),\n                  EventRuler.on(el, 'cleared', opts.oncleared),\n                  mobile || !0 === opts.inputEventOnly\n                    ? el.removeAttribute('maxLength')\n                    : (EventRuler.on(el, 'keydown', EventHandlers.keydownEvent),\n                      EventRuler.on(el, 'keypress', EventHandlers.keypressEvent)),\n                  EventRuler.on(el, 'input', EventHandlers.inputFallBackEvent),\n                  EventRuler.on(el, 'compositionend', EventHandlers.compositionendEvent)),\n                EventRuler.on(el, 'setvalue', EventHandlers.setValueEvent),\n                (undoValue = getBufferTemplate().join(''));\n              var activeElement = (el.inputmask.shadowRoot || document).activeElement;\n              if ('' !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || activeElement === el) {\n                applyInputValue(el, el.inputmask._valueGet(!0), opts);\n                var buffer = getBuffer().slice();\n                !1 === isComplete(buffer) && opts.clearIncomplete && resetMaskSet(),\n                  opts.clearMaskOnLostFocus &&\n                    activeElement !== el &&\n                    (-1 === getLastValidPosition() ? (buffer = []) : clearOptionalTail(buffer)),\n                  (!1 === opts.clearMaskOnLostFocus ||\n                    (opts.showMaskOnFocus && activeElement === el) ||\n                    '' !== el.inputmask._valueGet(!0)) &&\n                    writeBuffer(el, buffer),\n                  activeElement === el && caret(el, seekNext(getLastValidPosition()));\n              }\n            }\n          }\n          if (void 0 !== actionObj)\n            switch (actionObj.action) {\n              case 'isComplete':\n                return (el = actionObj.el), isComplete(getBuffer());\n              case 'unmaskedvalue':\n                return (\n                  (void 0 !== el && void 0 === actionObj.value) ||\n                    ((valueBuffer = actionObj.value),\n                    (valueBuffer = (\n                      ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, valueBuffer, opts)) ||\n                      valueBuffer\n                    ).split('')),\n                    checkVal.call(this, void 0, !1, !1, valueBuffer),\n                    $.isFunction(opts.onBeforeWrite) &&\n                      opts.onBeforeWrite.call(inputmask, void 0, getBuffer(), 0, opts)),\n                  unmaskedvalue(el)\n                );\n              case 'mask':\n                mask(el);\n                break;\n              case 'format':\n                return (\n                  (valueBuffer = (\n                    ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, actionObj.value, opts)) ||\n                    actionObj.value\n                  ).split('')),\n                  checkVal.call(this, void 0, !0, !1, valueBuffer),\n                  actionObj.metadata\n                    ? {\n                        value: isRTL ? getBuffer().slice().reverse().join('') : getBuffer().join(''),\n                        metadata: maskScope.call(this, { action: 'getmetadata' }, maskset, opts),\n                      }\n                    : isRTL\n                    ? getBuffer().slice().reverse().join('')\n                    : getBuffer().join('')\n                );\n              case 'isValid':\n                actionObj.value\n                  ? ((valueBuffer = (\n                      ($.isFunction(opts.onBeforeMask) && opts.onBeforeMask.call(inputmask, actionObj.value, opts)) ||\n                      actionObj.value\n                    ).split('')),\n                    checkVal.call(this, void 0, !0, !1, valueBuffer))\n                  : (actionObj.value = isRTL ? getBuffer().slice().reverse().join('') : getBuffer().join(''));\n                for (\n                  var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1;\n                  rl < lmib && !isMask(lmib);\n                  lmib--\n                );\n                return (\n                  buffer.splice(rl, lmib + 1 - rl),\n                  isComplete(buffer) &&\n                    actionObj.value === (isRTL ? getBuffer().slice().reverse().join('') : getBuffer().join(''))\n                );\n              case 'getemptymask':\n                return getBufferTemplate().join('');\n              case 'remove':\n                if (el && el.inputmask) {\n                  $.data(el, '_inputmask_opts', null), ($el = $(el));\n                  var cv = opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(opts.autoUnmask),\n                    valueProperty;\n                  cv !== getBufferTemplate().join('')\n                    ? el.inputmask._valueSet(cv, opts.autoUnmask)\n                    : el.inputmask._valueSet(''),\n                    EventRuler.off(el),\n                    Object.getOwnPropertyDescriptor && Object.getPrototypeOf\n                      ? ((valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), 'value')),\n                        valueProperty &&\n                          el.inputmask.__valueGet &&\n                          Object.defineProperty(el, 'value', {\n                            get: el.inputmask.__valueGet,\n                            set: el.inputmask.__valueSet,\n                            configurable: !0,\n                          }))\n                      : document.__lookupGetter__ &&\n                        el.__lookupGetter__('value') &&\n                        el.inputmask.__valueGet &&\n                        (el.__defineGetter__('value', el.inputmask.__valueGet),\n                        el.__defineSetter__('value', el.inputmask.__valueSet)),\n                    (el.inputmask = void 0);\n                }\n                return el;\n              case 'getmetadata':\n                if ($.isArray(maskset.metadata)) {\n                  var maskTarget = getMaskTemplate(!0, 0, !1).join('');\n                  return (\n                    $.each(maskset.metadata, function (ndx, mtdt) {\n                      if (mtdt.mask === maskTarget) return (maskTarget = mtdt), !1;\n                    }),\n                    maskTarget\n                  );\n                }\n                return maskset.metadata;\n            }\n        };\n      },\n      function (module, exports, __nested_webpack_require_160663__) {\n        'use strict';\n        function _typeof(obj) {\n          return (\n            (_typeof =\n              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\n                ? function _typeof(obj) {\n                    return typeof obj;\n                  }\n                : function _typeof(obj) {\n                    return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype\n                      ? 'symbol'\n                      : typeof obj;\n                  }),\n            _typeof(obj)\n          );\n        }\n        var Inputmask = __nested_webpack_require_160663__(1),\n          $ = Inputmask.dependencyLib,\n          keyCode = __nested_webpack_require_160663__(0),\n          formatCode = {\n            d: ['[1-9]|[12][0-9]|3[01]', Date.prototype.setDate, 'day', Date.prototype.getDate],\n            dd: [\n              '0[1-9]|[12][0-9]|3[01]',\n              Date.prototype.setDate,\n              'day',\n              function () {\n                return pad(Date.prototype.getDate.call(this), 2);\n              },\n            ],\n            ddd: [''],\n            dddd: [''],\n            m: [\n              '[1-9]|1[012]',\n              Date.prototype.setMonth,\n              'month',\n              function () {\n                return Date.prototype.getMonth.call(this) + 1;\n              },\n            ],\n            mm: [\n              '0[1-9]|1[012]',\n              Date.prototype.setMonth,\n              'month',\n              function () {\n                return pad(Date.prototype.getMonth.call(this) + 1, 2);\n              },\n            ],\n            mmm: [''],\n            mmmm: [''],\n            yy: [\n              '[0-9]{2}',\n              Date.prototype.setFullYear,\n              'year',\n              function () {\n                return pad(Date.prototype.getFullYear.call(this), 2);\n              },\n            ],\n            yyyy: [\n              '[0-9]{4}',\n              Date.prototype.setFullYear,\n              'year',\n              function () {\n                return pad(Date.prototype.getFullYear.call(this), 4);\n              },\n            ],\n            h: ['[1-9]|1[0-2]', Date.prototype.setHours, 'hours', Date.prototype.getHours],\n            hh: [\n              '0[1-9]|1[0-2]',\n              Date.prototype.setHours,\n              'hours',\n              function () {\n                return pad(Date.prototype.getHours.call(this), 2);\n              },\n            ],\n            hx: [\n              function (x) {\n                return '[0-9]{'.concat(x, '}');\n              },\n              Date.prototype.setHours,\n              'hours',\n              function (x) {\n                return Date.prototype.getHours;\n              },\n            ],\n            H: ['1?[0-9]|2[0-3]', Date.prototype.setHours, 'hours', Date.prototype.getHours],\n            HH: [\n              '0[0-9]|1[0-9]|2[0-3]',\n              Date.prototype.setHours,\n              'hours',\n              function () {\n                return pad(Date.prototype.getHours.call(this), 2);\n              },\n            ],\n            Hx: [\n              function (x) {\n                return '[0-9]{'.concat(x, '}');\n              },\n              Date.prototype.setHours,\n              'hours',\n              function (x) {\n                return function () {\n                  return pad(Date.prototype.getHours.call(this), x);\n                };\n              },\n            ],\n            M: ['[1-5]?[0-9]', Date.prototype.setMinutes, 'minutes', Date.prototype.getMinutes],\n            MM: [\n              '0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]',\n              Date.prototype.setMinutes,\n              'minutes',\n              function () {\n                return pad(Date.prototype.getMinutes.call(this), 2);\n              },\n            ],\n            s: ['[1-5]?[0-9]', Date.prototype.setSeconds, 'seconds', Date.prototype.getSeconds],\n            ss: [\n              '0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]',\n              Date.prototype.setSeconds,\n              'seconds',\n              function () {\n                return pad(Date.prototype.getSeconds.call(this), 2);\n              },\n            ],\n            l: [\n              '[0-9]{3}',\n              Date.prototype.setMilliseconds,\n              'milliseconds',\n              function () {\n                return pad(Date.prototype.getMilliseconds.call(this), 3);\n              },\n            ],\n            L: [\n              '[0-9]{2}',\n              Date.prototype.setMilliseconds,\n              'milliseconds',\n              function () {\n                return pad(Date.prototype.getMilliseconds.call(this), 2);\n              },\n            ],\n            t: ['[ap]'],\n            tt: ['[ap]m'],\n            T: ['[AP]'],\n            TT: ['[AP]M'],\n            Z: [''],\n            o: [''],\n            S: [''],\n          },\n          formatAlias = {\n            isoDate: 'yyyy-mm-dd',\n            isoTime: 'HH:MM:ss',\n            isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\",\n            isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\",\n          };\n        function formatcode(match) {\n          var dynMatches = new RegExp('\\\\d+$').exec(match[0]);\n          if (dynMatches && void 0 !== dynMatches[0]) {\n            var fcode = formatCode[match[0][0] + 'x'].slice('');\n            return (fcode[0] = fcode[0](dynMatches[0])), (fcode[3] = fcode[3](dynMatches[0])), fcode;\n          }\n          if (formatCode[match[0]]) return formatCode[match[0]];\n        }\n        function getTokenizer(opts) {\n          if (!opts.tokenizer) {\n            var tokens = [],\n              dyntokens = [];\n            for (var ndx in formatCode)\n              if (/\\.*x$/.test(ndx)) {\n                var dynToken = ndx[0] + '\\\\d+';\n                -1 === dyntokens.indexOf(dynToken) && dyntokens.push(dynToken);\n              } else -1 === tokens.indexOf(ndx[0]) && tokens.push(ndx[0]);\n            (opts.tokenizer =\n              '(' + (0 < dyntokens.length ? dyntokens.join('|') + '|' : '') + tokens.join('+|') + ')+?|.'),\n              (opts.tokenizer = new RegExp(opts.tokenizer, 'g'));\n          }\n          return opts.tokenizer;\n        }\n        function isValidDate(dateParts, currentResult) {\n          return (\n            (!isFinite(dateParts.rawday) ||\n              ('29' == dateParts.day && !isFinite(dateParts.rawyear)) ||\n              new Date(\n                dateParts.date.getFullYear(),\n                isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1,\n                0\n              ).getDate() >= dateParts.day) &&\n            currentResult\n          );\n        }\n        function isDateInRange(dateParts, opts) {\n          var result = !0;\n          if (opts.min) {\n            if (dateParts.rawyear) {\n              var rawYear = dateParts.rawyear.replace(/[^0-9]/g, ''),\n                minYear = opts.min.year.substr(0, rawYear.length);\n              result = minYear <= rawYear;\n            }\n            dateParts.year === dateParts.rawyear &&\n              opts.min.date.getTime() == opts.min.date.getTime() &&\n              (result = opts.min.date.getTime() <= dateParts.date.getTime());\n          }\n          return (\n            result &&\n              opts.max &&\n              opts.max.date.getTime() == opts.max.date.getTime() &&\n              (result = opts.max.date.getTime() >= dateParts.date.getTime()),\n            result\n          );\n        }\n        function parse(format, dateObjValue, opts, raw) {\n          var mask = '',\n            match,\n            fcode;\n          for (getTokenizer(opts).lastIndex = 0; (match = getTokenizer(opts).exec(format)); )\n            if (void 0 === dateObjValue)\n              if ((fcode = formatcode(match))) mask += '(' + fcode[0] + ')';\n              else\n                switch (match[0]) {\n                  case '[':\n                    mask += '(';\n                    break;\n                  case ']':\n                    mask += ')?';\n                    break;\n                  default:\n                    mask += Inputmask.escapeRegex(match[0]);\n                }\n            else if ((fcode = formatcode(match)))\n              if (!0 !== raw && fcode[3]) {\n                var getFn = fcode[3];\n                mask += getFn.call(dateObjValue.date);\n              } else fcode[2] ? (mask += dateObjValue['raw' + fcode[2]]) : (mask += match[0]);\n            else mask += match[0];\n          return mask;\n        }\n        function pad(val, len) {\n          for (val = String(val), len = len || 2; val.length < len; ) val = '0' + val;\n          return val;\n        }\n        function analyseMask(maskString, format, opts) {\n          var dateObj = { date: new Date(1, 0, 1) },\n            targetProp,\n            mask = maskString,\n            match,\n            dateOperation;\n          function extendProperty(value) {\n            var correctedValue = value.replace(/[^0-9]/g, '0');\n            return correctedValue;\n          }\n          function setValue(dateObj, value, opts) {\n            (dateObj[targetProp] = extendProperty(value)),\n              (dateObj['raw' + targetProp] = value),\n              void 0 !== dateOperation &&\n                dateOperation.call(\n                  dateObj.date,\n                  'month' == targetProp ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]\n                );\n          }\n          if ('string' == typeof mask) {\n            for (getTokenizer(opts).lastIndex = 0; (match = getTokenizer(opts).exec(format)); ) {\n              var value = mask.slice(0, match[0].length);\n              formatCode.hasOwnProperty(match[0]) &&\n                ((targetProp = formatCode[match[0]][2]),\n                (dateOperation = formatCode[match[0]][1]),\n                setValue(dateObj, value, opts)),\n                (mask = mask.slice(value.length));\n            }\n            return dateObj;\n          }\n          if (mask && 'object' === _typeof(mask) && mask.hasOwnProperty('date')) return mask;\n        }\n        function importDate(dateObj, opts) {\n          var match,\n            date = '';\n          for (getTokenizer(opts).lastIndex = 0; (match = getTokenizer(opts).exec(opts.inputFormat)); )\n            'd' === match[0].charAt(0)\n              ? (date += pad(dateObj.getDate(), match[0].length))\n              : 'm' === match[0].charAt(0)\n              ? (date += pad(dateObj.getMonth() + 1, match[0].length))\n              : 'yyyy' === match[0]\n              ? (date += dateObj.getFullYear().toString())\n              : 'y' === match[0].charAt(0) && (date += pad(dateObj.getYear(), match[0].length));\n          return date;\n        }\n        function getTokenMatch(pos, opts) {\n          var calcPos = 0,\n            targetMatch,\n            match;\n          for (getTokenizer(opts).lastIndex = 0; (match = getTokenizer(opts).exec(opts.inputFormat)); )\n            if (((calcPos += match[0].length), pos <= calcPos)) {\n              (targetMatch = match), (match = getTokenizer(opts).exec(opts.inputFormat));\n              break;\n            }\n          return { nextMatch: match, targetMatch: targetMatch };\n        }\n        Inputmask.extendAliases({\n          datetime: {\n            mask: function mask(opts) {\n              return (\n                (opts.numericInput = !1),\n                (formatCode.S = opts.i18n.ordinalSuffix.join('|')),\n                (opts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat),\n                (opts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat),\n                (opts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat),\n                (opts.placeholder = '' !== opts.placeholder ? opts.placeholder : opts.inputFormat.replace(/[[\\]]/, '')),\n                (opts.regex = parse(opts.inputFormat, void 0, opts)),\n                (opts.min = analyseMask(opts.min, opts.inputFormat, opts)),\n                (opts.max = analyseMask(opts.max, opts.inputFormat, opts)),\n                null\n              );\n            },\n            placeholder: '',\n            inputFormat: 'isoDateTime',\n            displayFormat: void 0,\n            outputFormat: void 0,\n            min: null,\n            max: null,\n            skipOptionalPartCharacter: '',\n            i18n: {\n              dayNames: [\n                'Mon',\n                'Tue',\n                'Wed',\n                'Thu',\n                'Fri',\n                'Sat',\n                'Sun',\n                'Monday',\n                'Tuesday',\n                'Wednesday',\n                'Thursday',\n                'Friday',\n                'Saturday',\n                'Sunday',\n              ],\n              monthNames: [\n                'Jan',\n                'Feb',\n                'Mar',\n                'Apr',\n                'May',\n                'Jun',\n                'Jul',\n                'Aug',\n                'Sep',\n                'Oct',\n                'Nov',\n                'Dec',\n                'January',\n                'February',\n                'March',\n                'April',\n                'May',\n                'June',\n                'July',\n                'August',\n                'September',\n                'October',\n                'November',\n                'December',\n              ],\n              ordinalSuffix: ['st', 'nd', 'rd', 'th'],\n            },\n            preValidation: function preValidation(buffer, pos, c, isSelection, opts, maskset, caretPos, strict) {\n              if (strict) return !0;\n              if (isNaN(c) && buffer[pos] !== c) {\n                var tokenMatch = getTokenMatch(pos, opts);\n                if (tokenMatch.nextMatch && tokenMatch.nextMatch[0] === c && 1 < tokenMatch.targetMatch[0].length) {\n                  var validator = formatCode[tokenMatch.targetMatch[0]][0];\n                  if (new RegExp(validator).test('0' + buffer[pos - 1]))\n                    return (\n                      (buffer[pos] = buffer[pos - 1]),\n                      (buffer[pos - 1] = '0'),\n                      { fuzzy: !0, buffer: buffer, refreshFromBuffer: { start: pos - 1, end: pos + 1 }, pos: pos + 1 }\n                    );\n                }\n              }\n              return !0;\n            },\n            postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) {\n              if (strict) return !0;\n              var tokenMatch;\n              if (!1 === currentResult) {\n                if (\n                  ((tokenMatch = getTokenMatch(pos + 1, opts)),\n                  tokenMatch.targetMatch &&\n                    tokenMatch.targetMatch.index === pos &&\n                    1 < tokenMatch.targetMatch[0].length &&\n                    void 0 !== formatCode[tokenMatch.targetMatch[0]])\n                ) {\n                  var validator = formatCode[tokenMatch.targetMatch[0]][0];\n                  if (new RegExp(validator).test('0' + c))\n                    return {\n                      insert: [\n                        { pos: pos, c: '0' },\n                        { pos: pos + 1, c: c },\n                      ],\n                      pos: pos + 1,\n                    };\n                }\n                return currentResult;\n              }\n              if (\n                (currentResult.fuzzy && ((buffer = currentResult.buffer), (pos = currentResult.pos)),\n                (tokenMatch = getTokenMatch(pos, opts)),\n                tokenMatch.targetMatch && tokenMatch.targetMatch[0] && void 0 !== formatCode[tokenMatch.targetMatch[0]])\n              ) {\n                var validator = formatCode[tokenMatch.targetMatch[0]][0],\n                  part = buffer.slice(\n                    tokenMatch.targetMatch.index,\n                    tokenMatch.targetMatch.index + tokenMatch.targetMatch[0].length\n                  );\n                !1 === new RegExp(validator).test(part.join('')) &&\n                  2 === tokenMatch.targetMatch[0].length &&\n                  maskset.validPositions[tokenMatch.targetMatch.index] &&\n                  maskset.validPositions[tokenMatch.targetMatch.index + 1] &&\n                  (maskset.validPositions[tokenMatch.targetMatch.index + 1].input = '0');\n              }\n              var result = currentResult,\n                dateParts = analyseMask(buffer.join(''), opts.inputFormat, opts);\n              return (\n                result &&\n                  dateParts.date.getTime() == dateParts.date.getTime() &&\n                  ((result = isValidDate(dateParts, result)), (result = result && isDateInRange(dateParts, opts))),\n                pos && result && currentResult.pos !== pos\n                  ? {\n                      buffer: parse(opts.inputFormat, dateParts, opts).split(''),\n                      refreshFromBuffer: { start: pos, end: currentResult.pos },\n                    }\n                  : result\n              );\n            },\n            onKeyDown: function onKeyDown(e, buffer, caretPos, opts) {\n              var input = this;\n              e.ctrlKey &&\n                e.keyCode === keyCode.RIGHT &&\n                (this.inputmask._valueSet(importDate(new Date(), opts)), $(this).trigger('setvalue'));\n            },\n            onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {\n              return unmaskedValue\n                ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, !0)\n                : unmaskedValue;\n            },\n            casing: function casing(elem, test, pos, validPositions) {\n              return 0 == test.nativeDef.indexOf('[ap]')\n                ? elem.toLowerCase()\n                : 0 == test.nativeDef.indexOf('[AP]')\n                ? elem.toUpperCase()\n                : elem;\n            },\n            onBeforeMask: function onBeforeMask(initialValue, opts) {\n              return (\n                '[object Date]' === Object.prototype.toString.call(initialValue) &&\n                  (initialValue = importDate(initialValue, opts)),\n                initialValue\n              );\n            },\n            insertMode: !1,\n            shiftPositions: !1,\n            keepStatic: !1,\n            inputmode: 'numeric',\n          },\n        }),\n          (module.exports = Inputmask);\n      },\n      function (module, exports, __nested_webpack_require_179004__) {\n        'use strict';\n        var Inputmask = __nested_webpack_require_179004__(1),\n          $ = Inputmask.dependencyLib,\n          keyCode = __nested_webpack_require_179004__(0);\n        function autoEscape(txt, opts) {\n          for (var escapedTxt = '', i = 0; i < txt.length; i++)\n            Inputmask.prototype.definitions[txt.charAt(i)] ||\n            opts.definitions[txt.charAt(i)] ||\n            opts.optionalmarker[0] === txt.charAt(i) ||\n            opts.optionalmarker[1] === txt.charAt(i) ||\n            opts.quantifiermarker[0] === txt.charAt(i) ||\n            opts.quantifiermarker[1] === txt.charAt(i) ||\n            opts.groupmarker[0] === txt.charAt(i) ||\n            opts.groupmarker[1] === txt.charAt(i) ||\n            opts.alternatormarker === txt.charAt(i)\n              ? (escapedTxt += '\\\\' + txt.charAt(i))\n              : (escapedTxt += txt.charAt(i));\n          return escapedTxt;\n        }\n        function alignDigits(buffer, digits, opts, force) {\n          if (0 < digits && (!opts.digitsOptional || force)) {\n            var radixPosition = $.inArray(opts.radixPoint, buffer);\n            -1 === radixPosition && (buffer.push(opts.radixPoint), (radixPosition = buffer.length - 1));\n            for (var i = 1; i <= digits; i++) isFinite(buffer[radixPosition + i]) || (buffer[radixPosition + i] = '0');\n          }\n          return buffer;\n        }\n        function findValidator(symbol, maskset) {\n          var posNdx = 0;\n          if ('+' === symbol) {\n            for (posNdx in maskset.validPositions);\n            posNdx = parseInt(posNdx);\n          }\n          for (var tstNdx in maskset.tests)\n            if (((tstNdx = parseInt(tstNdx)), posNdx <= tstNdx))\n              for (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++)\n                if (\n                  (void 0 === maskset.validPositions[tstNdx] || '-' === symbol) &&\n                  maskset.tests[tstNdx][ndx].match.def === symbol\n                )\n                  return tstNdx + (void 0 !== maskset.validPositions[tstNdx] && '-' !== symbol ? 1 : 0);\n          return posNdx;\n        }\n        function findValid(symbol, maskset) {\n          var ret = -1;\n          return (\n            $.each(maskset.validPositions, function (ndx, tst) {\n              if (tst && tst.match.def === symbol) return (ret = parseInt(ndx)), !1;\n            }),\n            ret\n          );\n        }\n        function parseMinMaxOptions(opts) {\n          void 0 === opts.parseMinMaxOptions &&\n            (null !== opts.min &&\n              ((opts.min = opts.min\n                .toString()\n                .replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), 'g'), '')),\n              ',' === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, '.')),\n              (opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN),\n              isNaN(opts.min) && (opts.min = Number.MIN_VALUE)),\n            null !== opts.max &&\n              ((opts.max = opts.max\n                .toString()\n                .replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), 'g'), '')),\n              ',' === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, '.')),\n              (opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN),\n              isNaN(opts.max) && (opts.max = Number.MAX_VALUE)),\n            (opts.parseMinMaxOptions = 'done'));\n        }\n        function genMask(opts) {\n          (opts.repeat = 0),\n            opts.groupSeparator === opts.radixPoint &&\n              opts.digits &&\n              '0' !== opts.digits &&\n              ('.' === opts.radixPoint\n                ? (opts.groupSeparator = ',')\n                : ',' === opts.radixPoint\n                ? (opts.groupSeparator = '.')\n                : (opts.groupSeparator = '')),\n            ' ' === opts.groupSeparator && (opts.skipOptionalPartCharacter = void 0),\n            1 < opts.placeholder.length && (opts.placeholder = opts.placeholder.charAt(0)),\n            'radixFocus' === opts.positionCaretOnClick &&\n              '' === opts.placeholder &&\n              (opts.positionCaretOnClick = 'lvp');\n          var decimalDef = '0',\n            radixPointDef = opts.radixPoint;\n          !0 === opts.numericInput && void 0 === opts.__financeInput\n            ? ((decimalDef = '1'),\n              (opts.positionCaretOnClick =\n                'radixFocus' === opts.positionCaretOnClick ? 'lvp' : opts.positionCaretOnClick),\n              (opts.digitsOptional = !1),\n              isNaN(opts.digits) && (opts.digits = 2),\n              (opts._radixDance = !1),\n              (radixPointDef = ',' === opts.radixPoint ? '?' : '!'),\n              '' !== opts.radixPoint &&\n                void 0 === opts.definitions[radixPointDef] &&\n                ((opts.definitions[radixPointDef] = {}),\n                (opts.definitions[radixPointDef].validator = '[' + opts.radixPoint + ']'),\n                (opts.definitions[radixPointDef].placeholder = opts.radixPoint),\n                (opts.definitions[radixPointDef].static = !0),\n                (opts.definitions[radixPointDef].generated = !0)))\n            : ((opts.__financeInput = !1), (opts.numericInput = !0));\n          var mask = '[+]',\n            altMask;\n          if (\n            ((mask += autoEscape(opts.prefix, opts)),\n            '' !== opts.groupSeparator\n              ? (void 0 === opts.definitions[opts.groupSeparator] &&\n                  ((opts.definitions[opts.groupSeparator] = {}),\n                  (opts.definitions[opts.groupSeparator].validator = '[' + opts.groupSeparator + ']'),\n                  (opts.definitions[opts.groupSeparator].placeholder = opts.groupSeparator),\n                  (opts.definitions[opts.groupSeparator].static = !0),\n                  (opts.definitions[opts.groupSeparator].generated = !0)),\n                (mask += opts._mask(opts)))\n              : (mask += '9{+}'),\n            void 0 !== opts.digits && 0 !== opts.digits)\n          ) {\n            var dq = opts.digits.toString().split(',');\n            isFinite(dq[0]) && dq[1] && isFinite(dq[1])\n              ? (mask += radixPointDef + decimalDef + '{' + opts.digits + '}')\n              : (isNaN(opts.digits) || 0 < parseInt(opts.digits)) &&\n                (opts.digitsOptional\n                  ? ((altMask = mask + radixPointDef + decimalDef + '{0,' + opts.digits + '}'), (opts.keepStatic = !0))\n                  : (mask += radixPointDef + decimalDef + '{' + opts.digits + '}'));\n          }\n          return (\n            (mask += autoEscape(opts.suffix, opts)),\n            (mask += '[-]'),\n            altMask && (mask = [altMask + autoEscape(opts.suffix, opts) + '[-]', mask]),\n            (opts.greedy = !1),\n            parseMinMaxOptions(opts),\n            mask\n          );\n        }\n        function hanndleRadixDance(pos, c, radixPos, maskset, opts) {\n          return (\n            opts._radixDance &&\n              opts.numericInput &&\n              c !== opts.negationSymbol.back &&\n              pos <= radixPos &&\n              (0 < radixPos || c == opts.radixPoint) &&\n              (void 0 === maskset.validPositions[pos - 1] ||\n                maskset.validPositions[pos - 1].input !== opts.negationSymbol.back) &&\n              (pos -= 1),\n            pos\n          );\n        }\n        function decimalValidator(chrs, maskset, pos, strict, opts) {\n          var radixPos = maskset.buffer ? maskset.buffer.indexOf(opts.radixPoint) : -1,\n            result = -1 !== radixPos && new RegExp('[0-9\\uff11-\\uff19]').test(chrs);\n          return opts._radixDance && result && null == maskset.validPositions[radixPos]\n            ? { insert: { pos: radixPos === pos ? radixPos + 1 : radixPos, c: opts.radixPoint }, pos: pos }\n            : result;\n        }\n        function checkForLeadingZeroes(buffer, opts) {\n          var numberMatches = new RegExp(\n              '(^' +\n                ('' !== opts.negationSymbol.front ? Inputmask.escapeRegex(opts.negationSymbol.front) + '?' : '') +\n                Inputmask.escapeRegex(opts.prefix) +\n                ')(.*)(' +\n                Inputmask.escapeRegex(opts.suffix) +\n                ('' != opts.negationSymbol.back ? Inputmask.escapeRegex(opts.negationSymbol.back) + '?' : '') +\n                '$)'\n            ).exec(buffer.slice().reverse().join('')),\n            number = numberMatches ? numberMatches[2] : '',\n            leadingzeroes = !1;\n          return (\n            number &&\n              ((number = number.split(opts.radixPoint.charAt(0))[0]),\n              (leadingzeroes = new RegExp('^[0' + opts.groupSeparator + ']*').exec(number))),\n            !(\n              !leadingzeroes ||\n              !(1 < leadingzeroes[0].length || (0 < leadingzeroes[0].length && leadingzeroes[0].length < number.length))\n            ) && leadingzeroes\n          );\n        }\n        Inputmask.extendAliases({\n          numeric: {\n            mask: genMask,\n            _mask: function _mask(opts) {\n              return '(' + opts.groupSeparator + '999){+|1}';\n            },\n            digits: '*',\n            digitsOptional: !0,\n            enforceDigitsOnBlur: !1,\n            radixPoint: '.',\n            positionCaretOnClick: 'radixFocus',\n            _radixDance: !0,\n            groupSeparator: '',\n            allowMinus: !0,\n            negationSymbol: { front: '-', back: '' },\n            prefix: '',\n            suffix: '',\n            min: null,\n            max: null,\n            step: 1,\n            unmaskAsNumber: !1,\n            roundingFN: Math.round,\n            inputmode: 'numeric',\n            shortcuts: { k: '000', m: '000000' },\n            placeholder: '0',\n            greedy: !1,\n            rightAlign: !0,\n            insertMode: !0,\n            autoUnmask: !1,\n            skipOptionalPartCharacter: '',\n            definitions: {\n              0: { validator: decimalValidator },\n              1: { validator: decimalValidator, definitionSymbol: '9' },\n              '+': {\n                validator: function validator(chrs, maskset, pos, strict, opts) {\n                  return opts.allowMinus && ('-' === chrs || chrs === opts.negationSymbol.front);\n                },\n              },\n              '-': {\n                validator: function validator(chrs, maskset, pos, strict, opts) {\n                  return opts.allowMinus && chrs === opts.negationSymbol.back;\n                },\n              },\n            },\n            preValidation: function preValidation(buffer, pos, c, isSelection, opts, maskset, caretPos, strict) {\n              if (!1 !== opts.__financeInput && c === opts.radixPoint) return !1;\n              var pattern;\n              if ((pattern = opts.shortcuts && opts.shortcuts[c])) {\n                if (1 < pattern.length)\n                  for (var inserts = [], i = 0; i < pattern.length; i++)\n                    inserts.push({ pos: pos + i, c: pattern[i], strict: !1 });\n                return { insert: inserts };\n              }\n              var radixPos = $.inArray(opts.radixPoint, buffer),\n                initPos = pos;\n              if (\n                ((pos = hanndleRadixDance(pos, c, radixPos, maskset, opts)),\n                '-' === c || c === opts.negationSymbol.front)\n              ) {\n                if (!0 !== opts.allowMinus) return !1;\n                var isNegative = !1,\n                  front = findValid('+', maskset),\n                  back = findValid('-', maskset);\n                return (\n                  -1 !== front && (isNegative = [front, back]),\n                  !1 !== isNegative\n                    ? { remove: isNegative, caret: initPos }\n                    : {\n                        insert: [\n                          { pos: findValidator('+', maskset), c: opts.negationSymbol.front, fromIsValid: !0 },\n                          { pos: findValidator('-', maskset), c: opts.negationSymbol.back, fromIsValid: void 0 },\n                        ],\n                        caret: initPos + opts.negationSymbol.back.length,\n                      }\n                );\n              }\n              if (strict) return !0;\n              if (\n                -1 !== radixPos &&\n                !0 === opts._radixDance &&\n                !1 === isSelection &&\n                c === opts.radixPoint &&\n                void 0 !== opts.digits &&\n                (isNaN(opts.digits) || 0 < parseInt(opts.digits)) &&\n                radixPos !== pos\n              )\n                return { caret: opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos };\n              if (!1 === opts.__financeInput)\n                if (isSelection) {\n                  if (opts.digitsOptional) return { rewritePosition: caretPos.end };\n                  if (!opts.digitsOptional) {\n                    if (caretPos.begin > radixPos && caretPos.end <= radixPos)\n                      return c === opts.radixPoint\n                        ? { insert: { pos: radixPos + 1, c: '0', fromIsValid: !0 }, rewritePosition: radixPos }\n                        : { rewritePosition: radixPos + 1 };\n                    if (caretPos.begin < radixPos) return { rewritePosition: caretPos.begin - 1 };\n                  }\n                } else if (\n                  !opts.showMaskOnHover &&\n                  !opts.showMaskOnFocus &&\n                  !opts.digitsOptional &&\n                  0 < opts.digits &&\n                  '' === this.inputmask.__valueGet.call(this)\n                )\n                  return { rewritePosition: radixPos };\n              return { rewritePosition: pos };\n            },\n            postValidation: function postValidation(buffer, pos, c, currentResult, opts, maskset, strict) {\n              if (!1 === currentResult) return currentResult;\n              if (strict) return !0;\n              if (null !== opts.min || null !== opts.max) {\n                var unmasked = opts.onUnMask(\n                  buffer.slice().reverse().join(''),\n                  void 0,\n                  $.extend({}, opts, { unmaskAsNumber: !0 })\n                );\n                if (\n                  null !== opts.min &&\n                  unmasked < opts.min &&\n                  (unmasked.toString().length >= opts.min.toString().length || unmasked < 0)\n                )\n                  return !1;\n                if (null !== opts.max && unmasked > opts.max) return !1;\n              }\n              return currentResult;\n            },\n            onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {\n              if ('' === unmaskedValue && !0 === opts.nullable) return unmaskedValue;\n              var processValue = maskedValue.replace(opts.prefix, '');\n              return (\n                (processValue = processValue.replace(opts.suffix, '')),\n                (processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), 'g'), '')),\n                '' !== opts.placeholder.charAt(0) &&\n                  (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), 'g'), '0')),\n                opts.unmaskAsNumber\n                  ? ('' !== opts.radixPoint &&\n                      -1 !== processValue.indexOf(opts.radixPoint) &&\n                      (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), '.')),\n                    (processValue = processValue.replace(\n                      new RegExp('^' + Inputmask.escapeRegex(opts.negationSymbol.front)),\n                      '-'\n                    )),\n                    (processValue = processValue.replace(\n                      new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + '$'),\n                      ''\n                    )),\n                    Number(processValue))\n                  : processValue\n              );\n            },\n            isComplete: function isComplete(buffer, opts) {\n              var maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join('');\n              return (\n                (maskedValue = maskedValue.replace(\n                  new RegExp('^' + Inputmask.escapeRegex(opts.negationSymbol.front)),\n                  '-'\n                )),\n                (maskedValue = maskedValue.replace(\n                  new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + '$'),\n                  ''\n                )),\n                (maskedValue = maskedValue.replace(opts.prefix, '')),\n                (maskedValue = maskedValue.replace(opts.suffix, '')),\n                (maskedValue = maskedValue.replace(\n                  new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + '([0-9]{3})', 'g'),\n                  '$1'\n                )),\n                ',' === opts.radixPoint &&\n                  (maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), '.')),\n                isFinite(maskedValue)\n              );\n            },\n            onBeforeMask: function onBeforeMask(initialValue, opts) {\n              var radixPoint = opts.radixPoint || ',';\n              isFinite(opts.digits) && (opts.digits = parseInt(opts.digits)),\n                ('number' != typeof initialValue && 'number' !== opts.inputType) ||\n                  '' === radixPoint ||\n                  (initialValue = initialValue.toString().replace('.', radixPoint));\n              var valueParts = initialValue.split(radixPoint),\n                integerPart = valueParts[0].replace(/[^\\-0-9]/g, ''),\n                decimalPart = 1 < valueParts.length ? valueParts[1].replace(/[^0-9]/g, '') : '',\n                forceDigits = 1 < valueParts.length;\n              initialValue = integerPart + ('' !== decimalPart ? radixPoint + decimalPart : decimalPart);\n              var digits = 0;\n              if (\n                '' !== radixPoint &&\n                ((digits = opts.digitsOptional\n                  ? opts.digits < decimalPart.length\n                    ? opts.digits\n                    : decimalPart.length\n                  : opts.digits),\n                '' !== decimalPart || !opts.digitsOptional)\n              ) {\n                var digitsFactor = Math.pow(10, digits || 1);\n                (initialValue = initialValue.replace(Inputmask.escapeRegex(radixPoint), '.')),\n                  isFinite(initialValue) &&\n                    (initialValue = (opts.roundingFN(parseFloat(initialValue) * digitsFactor) / digitsFactor).toFixed(\n                      digits\n                    )),\n                  (initialValue = initialValue.toString().replace('.', radixPoint));\n              }\n              if (\n                (0 === opts.digits &&\n                  -1 !== initialValue.indexOf(radixPoint) &&\n                  (initialValue = initialValue.substring(0, initialValue.indexOf(radixPoint))),\n                null !== opts.min || null !== opts.max)\n              ) {\n                var numberValue = initialValue.toString().replace(radixPoint, '.');\n                null !== opts.min && numberValue < opts.min\n                  ? (initialValue = opts.min.toString().replace('.', radixPoint))\n                  : null !== opts.max &&\n                    numberValue > opts.max &&\n                    (initialValue = opts.max.toString().replace('.', radixPoint));\n              }\n              return alignDigits(initialValue.toString().split(''), digits, opts, forceDigits).join('');\n            },\n            onBeforeWrite: function onBeforeWrite(e, buffer, caretPos, opts) {\n              function stripBuffer(buffer, stripRadix) {\n                if (!1 !== opts.__financeInput || stripRadix) {\n                  var position = $.inArray(opts.radixPoint, buffer);\n                  -1 !== position && buffer.splice(position, 1);\n                }\n                if ('' !== opts.groupSeparator)\n                  for (; -1 !== (position = buffer.indexOf(opts.groupSeparator)); ) buffer.splice(position, 1);\n                return buffer;\n              }\n              var result,\n                leadingzeroes = checkForLeadingZeroes(buffer, opts);\n              if (leadingzeroes) {\n                var buf = buffer.slice().reverse(),\n                  caretNdx = buf.join('').indexOf(leadingzeroes[0]);\n                buf.splice(caretNdx, leadingzeroes[0].length);\n                var newCaretPos = buf.length - caretNdx;\n                stripBuffer(buf),\n                  (result = {\n                    refreshFromBuffer: !0,\n                    buffer: buf.reverse(),\n                    caret: caretPos < newCaretPos ? caretPos : newCaretPos,\n                  });\n              }\n              if (e)\n                switch (e.type) {\n                  case 'blur':\n                  case 'checkval':\n                    if (null !== opts.min) {\n                      var unmasked = opts.onUnMask(\n                        buffer.slice().reverse().join(''),\n                        void 0,\n                        $.extend({}, opts, { unmaskAsNumber: !0 })\n                      );\n                      if (null !== opts.min && unmasked < opts.min)\n                        return {\n                          refreshFromBuffer: !0,\n                          buffer: alignDigits(\n                            opts.min.toString().replace('.', opts.radixPoint).split(''),\n                            opts.digits,\n                            opts\n                          ).reverse(),\n                        };\n                    }\n                    if (buffer[buffer.length - 1] === opts.negationSymbol.front) {\n                      var nmbrMtchs = new RegExp(\n                          '(^' +\n                            ('' != opts.negationSymbol.front\n                              ? Inputmask.escapeRegex(opts.negationSymbol.front) + '?'\n                              : '') +\n                            Inputmask.escapeRegex(opts.prefix) +\n                            ')(.*)(' +\n                            Inputmask.escapeRegex(opts.suffix) +\n                            ('' != opts.negationSymbol.back\n                              ? Inputmask.escapeRegex(opts.negationSymbol.back) + '?'\n                              : '') +\n                            '$)'\n                        ).exec(stripBuffer(buffer.slice(), !0).reverse().join('')),\n                        number = nmbrMtchs ? nmbrMtchs[2] : '';\n                      0 == number && (result = { refreshFromBuffer: !0, buffer: [0] });\n                    } else\n                      '' !== opts.radixPoint &&\n                        buffer[0] === opts.radixPoint &&\n                        (result && result.buffer\n                          ? result.buffer.shift()\n                          : (buffer.shift(), (result = { refreshFromBuffer: !0, buffer: stripBuffer(buffer) })));\n                    if (opts.enforceDigitsOnBlur) {\n                      result = result || {};\n                      var bffr = (result && result.buffer) || buffer.slice().reverse();\n                      (result.refreshFromBuffer = !0),\n                        (result.buffer = alignDigits(bffr, opts.digits, opts, !0).reverse());\n                    }\n                }\n              return result;\n            },\n            onKeyDown: function onKeyDown(e, buffer, caretPos, opts) {\n              var $input = $(this),\n                bffr;\n              if (e.ctrlKey)\n                switch (e.keyCode) {\n                  case keyCode.UP:\n                    return (\n                      this.inputmask.__valueSet.call(\n                        this,\n                        parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)\n                      ),\n                      $input.trigger('setvalue'),\n                      !1\n                    );\n                  case keyCode.DOWN:\n                    return (\n                      this.inputmask.__valueSet.call(\n                        this,\n                        parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)\n                      ),\n                      $input.trigger('setvalue'),\n                      !1\n                    );\n                }\n              if (\n                !e.shiftKey &&\n                (e.keyCode === keyCode.DELETE ||\n                  e.keyCode === keyCode.BACKSPACE ||\n                  e.keyCode === keyCode.BACKSPACE_SAFARI) &&\n                caretPos.begin !== buffer.length\n              ) {\n                if (\n                  buffer[e.keyCode === keyCode.DELETE ? caretPos.begin - 1 : caretPos.end] === opts.negationSymbol.front\n                )\n                  return (\n                    (bffr = buffer.slice().reverse()),\n                    '' !== opts.negationSymbol.front && bffr.shift(),\n                    '' !== opts.negationSymbol.back && bffr.pop(),\n                    $input.trigger('setvalue', [bffr.join(''), caretPos.begin]),\n                    !1\n                  );\n                if (!0 === opts._radixDance) {\n                  var radixPos = $.inArray(opts.radixPoint, buffer);\n                  if (opts.digitsOptional) {\n                    if (0 === radixPos)\n                      return (\n                        (bffr = buffer.slice().reverse()),\n                        bffr.pop(),\n                        $input.trigger('setvalue', [\n                          bffr.join(''),\n                          caretPos.begin >= bffr.length ? bffr.length : caretPos.begin,\n                        ]),\n                        !1\n                      );\n                  } else if (\n                    -1 !== radixPos &&\n                    (caretPos.begin < radixPos ||\n                      caretPos.end < radixPos ||\n                      (e.keyCode === keyCode.DELETE && caretPos.begin === radixPos))\n                  )\n                    return (\n                      caretPos.begin !== caretPos.end ||\n                        (e.keyCode !== keyCode.BACKSPACE && e.keyCode !== keyCode.BACKSPACE_SAFARI) ||\n                        caretPos.begin++,\n                      (bffr = buffer.slice().reverse()),\n                      bffr.splice(bffr.length - caretPos.begin, caretPos.begin - caretPos.end + 1),\n                      (bffr = alignDigits(bffr, opts.digits, opts).join('')),\n                      $input.trigger('setvalue', [bffr, caretPos.begin >= bffr.length ? radixPos + 1 : caretPos.begin]),\n                      !1\n                    );\n                }\n              }\n            },\n          },\n          currency: { prefix: '', groupSeparator: ',', alias: 'numeric', digits: 2, digitsOptional: !1 },\n          decimal: { alias: 'numeric' },\n          integer: { alias: 'numeric', digits: 0 },\n          percentage: { alias: 'numeric', min: 0, max: 100, suffix: ' %', digits: 0, allowMinus: !1 },\n          indianns: {\n            alias: 'numeric',\n            _mask: function _mask(opts) {\n              return '(' + opts.groupSeparator + '99){*|1}(' + opts.groupSeparator + '999){1|1}';\n            },\n            groupSeparator: ',',\n            radixPoint: '.',\n            placeholder: '0',\n            digits: 2,\n            digitsOptional: !1,\n          },\n        }),\n          (module.exports = Inputmask);\n      },\n      function (module, exports, __nested_webpack_require_206168__) {\n        'use strict';\n        var _inputmask = _interopRequireDefault(__nested_webpack_require_206168__(1));\n        function _typeof(obj) {\n          return (\n            (_typeof =\n              'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\n                ? function _typeof(obj) {\n                    return typeof obj;\n                  }\n                : function _typeof(obj) {\n                    return obj && 'function' == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype\n                      ? 'symbol'\n                      : typeof obj;\n                  }),\n            _typeof(obj)\n          );\n        }\n        function _classCallCheck(instance, Constructor) {\n          if (!(instance instanceof Constructor)) throw new TypeError('Cannot call a class as a function');\n        }\n        function _possibleConstructorReturn(self, call) {\n          return !call || ('object' !== _typeof(call) && 'function' != typeof call)\n            ? _assertThisInitialized(self)\n            : call;\n        }\n        function _assertThisInitialized(self) {\n          if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          return self;\n        }\n        function _inherits(subClass, superClass) {\n          if ('function' != typeof superClass && null !== superClass)\n            throw new TypeError('Super expression must either be null or a function');\n          (subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: { value: subClass, writable: !0, configurable: !0 },\n          })),\n            superClass && _setPrototypeOf(subClass, superClass);\n        }\n        function _wrapNativeSuper(Class) {\n          var _cache = 'function' == typeof Map ? new Map() : void 0;\n          return (\n            (_wrapNativeSuper = function _wrapNativeSuper(Class) {\n              if (null === Class || !_isNativeFunction(Class)) return Class;\n              if ('function' != typeof Class) throw new TypeError('Super expression must either be null or a function');\n              if ('undefined' != typeof _cache) {\n                if (_cache.has(Class)) return _cache.get(Class);\n                _cache.set(Class, Wrapper);\n              }\n              function Wrapper() {\n                return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n              }\n              return (\n                (Wrapper.prototype = Object.create(Class.prototype, {\n                  constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 },\n                })),\n                _setPrototypeOf(Wrapper, Class)\n              );\n            }),\n            _wrapNativeSuper(Class)\n          );\n        }\n        function isNativeReflectConstruct() {\n          if ('undefined' == typeof Reflect || !Reflect.construct) return !1;\n          if (Reflect.construct.sham) return !1;\n          if ('function' == typeof Proxy) return !0;\n          try {\n            return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n          } catch (e) {\n            return !1;\n          }\n        }\n        function _construct(Parent, args, Class) {\n          return (\n            (_construct = isNativeReflectConstruct()\n              ? Reflect.construct\n              : function _construct(Parent, args, Class) {\n                  var a = [null];\n                  a.push.apply(a, args);\n                  var Constructor = Function.bind.apply(Parent, a),\n                    instance = new Constructor();\n                  return Class && _setPrototypeOf(instance, Class.prototype), instance;\n                }),\n            _construct.apply(null, arguments)\n          );\n        }\n        function _isNativeFunction(fn) {\n          return -1 !== Function.toString.call(fn).indexOf('[native code]');\n        }\n        function _setPrototypeOf(o, p) {\n          return (\n            (_setPrototypeOf =\n              Object.setPrototypeOf ||\n              function _setPrototypeOf(o, p) {\n                return (o.__proto__ = p), o;\n              }),\n            _setPrototypeOf(o, p)\n          );\n        }\n        function _getPrototypeOf(o) {\n          return (\n            (_getPrototypeOf = Object.setPrototypeOf\n              ? Object.getPrototypeOf\n              : function _getPrototypeOf(o) {\n                  return o.__proto__ || Object.getPrototypeOf(o);\n                }),\n            _getPrototypeOf(o)\n          );\n        }\n        function _interopRequireDefault(obj) {\n          return obj && obj.__esModule ? obj : { default: obj };\n        }\n        if (document.head.createShadowRoot || document.head.attachShadow) {\n          var InputmaskElement = (function (_HTMLElement) {\n            function InputmaskElement() {\n              var _this;\n              _classCallCheck(this, InputmaskElement),\n                (_this = _possibleConstructorReturn(this, _getPrototypeOf(InputmaskElement).call(this)));\n              var attributeNames = _this.getAttributeNames(),\n                shadow = _this.attachShadow({ mode: 'closed' }),\n                input = document.createElement('input');\n              for (var attr in ((input.type = 'text'), shadow.appendChild(input), attributeNames))\n                Object.prototype.hasOwnProperty.call(attributeNames, attr) &&\n                  input.setAttribute(\n                    'data-inputmask-' + attributeNames[attr],\n                    _this.getAttribute(attributeNames[attr])\n                  );\n              return new _inputmask.default().mask(input), (input.inputmask.shadowRoot = shadow), _this;\n            }\n            return _inherits(InputmaskElement, _HTMLElement), InputmaskElement;\n          })(_wrapNativeSuper(HTMLElement));\n          customElements.define('input-mask', InputmaskElement);\n        }\n      },\n    ]),\n    (installedModules = {}),\n    (__nested_webpack_require_213911__.m = modules),\n    (__nested_webpack_require_213911__.c = installedModules),\n    (__nested_webpack_require_213911__.d = function (exports, name, getter) {\n      __nested_webpack_require_213911__.o(exports, name) || Object.defineProperty(exports, name, { enumerable: !0, get: getter });\n    }),\n    (__nested_webpack_require_213911__.r = function (exports) {\n      'undefined' != typeof Symbol &&\n        Symbol.toStringTag &&\n        Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }),\n        Object.defineProperty(exports, '__esModule', { value: !0 });\n    }),\n    (__nested_webpack_require_213911__.t = function (value, mode) {\n      if ((1 & mode && (value = __nested_webpack_require_213911__(value)), 8 & mode)) return value;\n      if (4 & mode && 'object' == typeof value && value && value.__esModule) return value;\n      var ns = Object.create(null);\n      if (\n        (__nested_webpack_require_213911__.r(ns),\n        Object.defineProperty(ns, 'default', { enumerable: !0, value: value }),\n        2 & mode && 'string' != typeof value)\n      )\n        for (var key in value)\n          __nested_webpack_require_213911__.d(\n            ns,\n            key,\n            function (key) {\n              return value[key];\n            }.bind(null, key)\n          );\n      return ns;\n    }),\n    (__nested_webpack_require_213911__.n = function (module) {\n      var getter =\n        module && module.__esModule\n          ? function getDefault() {\n              return module.default;\n            }\n          : function getModuleExports() {\n              return module;\n            };\n      return __nested_webpack_require_213911__.d(getter, 'a', getter), getter;\n    }),\n    (__nested_webpack_require_213911__.o = function (object, property) {\n      return Object.prototype.hasOwnProperty.call(object, property);\n    }),\n    (__nested_webpack_require_213911__.p = ''),\n    __nested_webpack_require_213911__((__nested_webpack_require_213911__.s = 5))\n  );\n  function __nested_webpack_require_213911__(moduleId) {\n    if (installedModules[moduleId]) return installedModules[moduleId].exports;\n    var module = (installedModules[moduleId] = { i: moduleId, l: !1, exports: {} });\n    return (\n      modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_213911__),\n      (module.l = !0),\n      module.exports\n    );\n  }\n  var modules, installedModules;\n});\n\n\n//# sourceURL=webpack://boarding-houses/./src/js/libs/inputmask.min.js?");

/***/ }),

/***/ "./src/js/libs/swipers.js":
/*!********************************!*\
  !*** ./src/js/libs/swipers.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Swiper 8.3.0\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2022 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: July 6, 2022\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined'\n    ? (module.exports = factory())\n    : typeof define === 'function' && define.amd\n    ? define(factory)\n    : ((global = typeof globalThis !== 'undefined' ? globalThis : global || self), (global.Swiper = factory()));\n})(undefined, () => {\n  /**\n   * SSR Window 4.0.2\n   * Better handling for window object in SSR environment\n   * https://github.com/nolimits4web/ssr-window\n   *\n   * Copyright 2021, Vladimir Kharlampidi\n   *\n   * Licensed under MIT\n   *\n   * Released on: December 13, 2021\n   */\n\n  /* eslint-disable no-param-reassign */\n  function isObject$1(obj) {\n    return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n  }\n\n  function extend$1(target, src) {\n    if (target === void 0) {\n      target = {};\n    }\n\n    if (src === void 0) {\n      src = {};\n    }\n\n    Object.keys(src).forEach((key) => {\n      if (typeof target[key] === 'undefined') target[key] = src[key];\n      else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n        extend$1(target[key], src[key]);\n      }\n    });\n  }\n\n  const ssrDocument = {\n    body: {},\n\n    addEventListener() {},\n\n    removeEventListener() {},\n\n    activeElement: {\n      blur() {},\n\n      nodeName: '',\n    },\n\n    querySelector() {\n      return null;\n    },\n\n    querySelectorAll() {\n      return [];\n    },\n\n    getElementById() {\n      return null;\n    },\n\n    createEvent() {\n      return {\n        initEvent() {},\n      };\n    },\n\n    createElement() {\n      return {\n        children: [],\n        childNodes: [],\n        style: {},\n\n        setAttribute() {},\n\n        getElementsByTagName() {\n          return [];\n        },\n      };\n    },\n\n    createElementNS() {\n      return {};\n    },\n\n    importNode() {\n      return null;\n    },\n\n    location: {\n      hash: '',\n      host: '',\n      hostname: '',\n      href: '',\n      origin: '',\n      pathname: '',\n      protocol: '',\n      search: '',\n    },\n  };\n\n  function getDocument() {\n    const doc = typeof document !== 'undefined' ? document : {};\n    extend$1(doc, ssrDocument);\n    return doc;\n  }\n\n  const ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n      userAgent: '',\n    },\n    location: {\n      hash: '',\n      host: '',\n      hostname: '',\n      href: '',\n      origin: '',\n      pathname: '',\n      protocol: '',\n      search: '',\n    },\n    history: {\n      replaceState() {},\n\n      pushState() {},\n\n      go() {},\n\n      back() {},\n    },\n    CustomEvent: function CustomEvent() {\n      return this;\n    },\n\n    addEventListener() {},\n\n    removeEventListener() {},\n\n    getComputedStyle() {\n      return {\n        getPropertyValue() {\n          return '';\n        },\n      };\n    },\n\n    Image() {},\n\n    Date() {},\n\n    screen: {},\n\n    setTimeout() {},\n\n    clearTimeout() {},\n\n    matchMedia() {\n      return {};\n    },\n\n    requestAnimationFrame(callback) {\n      if (typeof setTimeout === 'undefined') {\n        callback();\n        return null;\n      }\n\n      return setTimeout(callback, 0);\n    },\n\n    cancelAnimationFrame(id) {\n      if (typeof setTimeout === 'undefined') {\n        return;\n      }\n\n      clearTimeout(id);\n    },\n  };\n\n  function getWindow() {\n    const win = typeof window !== 'undefined' ? window : {};\n    extend$1(win, ssrWindow);\n    return win;\n  }\n\n  /**\n   * Dom7 4.0.4\n   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API\n   * https://framework7.io/docs/dom7.html\n   *\n   * Copyright 2022, Vladimir Kharlampidi\n   *\n   * Licensed under MIT\n   *\n   * Released on: January 11, 2022\n   */\n  /* eslint-disable no-proto */\n\n  function makeReactive(obj) {\n    const proto = obj.__proto__;\n    Object.defineProperty(obj, '__proto__', {\n      get() {\n        return proto;\n      },\n\n      set(value) {\n        proto.__proto__ = value;\n      },\n    });\n  }\n\n  class Dom7 extends Array {\n    constructor(items) {\n      if (typeof items === 'number') {\n        super(items);\n      } else {\n        super(...(items || []));\n        makeReactive(this);\n      }\n    }\n  }\n\n  function arrayFlat(arr) {\n    if (arr === void 0) {\n      arr = [];\n    }\n\n    const res = [];\n    arr.forEach((el) => {\n      if (Array.isArray(el)) {\n        res.push(...arrayFlat(el));\n      } else {\n        res.push(el);\n      }\n    });\n    return res;\n  }\n\n  function arrayFilter(arr, callback) {\n    return Array.prototype.filter.call(arr, callback);\n  }\n\n  function arrayUnique(arr) {\n    const uniqueArray = [];\n\n    for (let i = 0; i < arr.length; i += 1) {\n      if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);\n    }\n\n    return uniqueArray;\n  }\n\n  function qsa(selector, context) {\n    if (typeof selector !== 'string') {\n      return [selector];\n    }\n\n    const a = [];\n    const res = context.querySelectorAll(selector);\n\n    for (let i = 0; i < res.length; i += 1) {\n      a.push(res[i]);\n    }\n\n    return a;\n  }\n\n  function $(selector, context) {\n    const window = getWindow();\n    const document = getDocument();\n    let arr = [];\n\n    if (!context && selector instanceof Dom7) {\n      return selector;\n    }\n\n    if (!selector) {\n      return new Dom7(arr);\n    }\n\n    if (typeof selector === 'string') {\n      const html = selector.trim();\n\n      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {\n        let toCreate = 'div';\n        if (html.indexOf('<li') === 0) toCreate = 'ul';\n        if (html.indexOf('<tr') === 0) toCreate = 'tbody';\n        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';\n        if (html.indexOf('<tbody') === 0) toCreate = 'table';\n        if (html.indexOf('<option') === 0) toCreate = 'select';\n        const tempParent = document.createElement(toCreate);\n        tempParent.innerHTML = html;\n\n        for (let i = 0; i < tempParent.childNodes.length; i += 1) {\n          arr.push(tempParent.childNodes[i]);\n        }\n      } else {\n        arr = qsa(selector.trim(), context || document);\n      } // arr = qsa(selector, document);\n    } else if (selector.nodeType || selector === window || selector === document) {\n      arr.push(selector);\n    } else if (Array.isArray(selector)) {\n      if (selector instanceof Dom7) return selector;\n      arr = selector;\n    }\n\n    return new Dom7(arrayUnique(arr));\n  }\n\n  $.fn = Dom7.prototype; // eslint-disable-next-line\n\n  function addClass() {\n    for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {\n      classes[_key] = arguments[_key];\n    }\n\n    const classNames = arrayFlat(classes.map((c) => c.split(' ')));\n    this.forEach((el) => {\n      el.classList.add(...classNames);\n    });\n    return this;\n  }\n\n  function removeClass() {\n    for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      classes[_key2] = arguments[_key2];\n    }\n\n    const classNames = arrayFlat(classes.map((c) => c.split(' ')));\n    this.forEach((el) => {\n      el.classList.remove(...classNames);\n    });\n    return this;\n  }\n\n  function toggleClass() {\n    for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      classes[_key3] = arguments[_key3];\n    }\n\n    const classNames = arrayFlat(classes.map((c) => c.split(' ')));\n    this.forEach((el) => {\n      classNames.forEach((className) => {\n        el.classList.toggle(className);\n      });\n    });\n  }\n\n  function hasClass() {\n    for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      classes[_key4] = arguments[_key4];\n    }\n\n    const classNames = arrayFlat(classes.map((c) => c.split(' ')));\n    return (\n      arrayFilter(this, (el) => classNames.filter((className) => el.classList.contains(className)).length > 0).length >\n      0\n    );\n  }\n\n  function attr(attrs, value) {\n    if (arguments.length === 1 && typeof attrs === 'string') {\n      // Get attr\n      if (this[0]) return this[0].getAttribute(attrs);\n      return undefined;\n    } // Set attrs\n\n    for (let i = 0; i < this.length; i += 1) {\n      if (arguments.length === 2) {\n        // String\n        this[i].setAttribute(attrs, value);\n      } else {\n        // Object\n        for (const attrName in attrs) {\n          this[i][attrName] = attrs[attrName];\n          this[i].setAttribute(attrName, attrs[attrName]);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  function removeAttr(attr) {\n    for (let i = 0; i < this.length; i += 1) {\n      this[i].removeAttribute(attr);\n    }\n\n    return this;\n  }\n\n  function transform(transform) {\n    for (let i = 0; i < this.length; i += 1) {\n      this[i].style.transform = transform;\n    }\n\n    return this;\n  }\n\n  function transition$1(duration) {\n    for (let i = 0; i < this.length; i += 1) {\n      this[i].style.transitionDuration = typeof duration !== 'string' ? `${duration}ms` : duration;\n    }\n\n    return this;\n  }\n\n  function on() {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    let [eventType, targetSelector, listener, capture] = args;\n\n    if (typeof args[1] === 'function') {\n      [eventType, listener, capture] = args;\n      targetSelector = undefined;\n    }\n\n    if (!capture) capture = false;\n\n    function handleLiveEvent(e) {\n      const { target } = e;\n      if (!target) return;\n      const eventData = e.target.dom7EventData || [];\n\n      if (eventData.indexOf(e) < 0) {\n        eventData.unshift(e);\n      }\n\n      if ($(target).is(targetSelector)) listener.apply(target, eventData);\n      else {\n        const parents = $(target).parents(); // eslint-disable-line\n\n        for (let k = 0; k < parents.length; k += 1) {\n          if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);\n        }\n      }\n    }\n\n    function handleEvent(e) {\n      const eventData = e && e.target ? e.target.dom7EventData || [] : [];\n\n      if (eventData.indexOf(e) < 0) {\n        eventData.unshift(e);\n      }\n\n      listener.apply(this, eventData);\n    }\n\n    const events = eventType.split(' ');\n    let j;\n\n    for (let i = 0; i < this.length; i += 1) {\n      const el = this[i];\n\n      if (!targetSelector) {\n        for (j = 0; j < events.length; j += 1) {\n          const event = events[j];\n          if (!el.dom7Listeners) el.dom7Listeners = {};\n          if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];\n          el.dom7Listeners[event].push({\n            listener,\n            proxyListener: handleEvent,\n          });\n          el.addEventListener(event, handleEvent, capture);\n        }\n      } else {\n        // Live events\n        for (j = 0; j < events.length; j += 1) {\n          const event = events[j];\n          if (!el.dom7LiveListeners) el.dom7LiveListeners = {};\n          if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];\n          el.dom7LiveListeners[event].push({\n            listener,\n            proxyListener: handleLiveEvent,\n          });\n          el.addEventListener(event, handleLiveEvent, capture);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  function off() {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    let [eventType, targetSelector, listener, capture] = args;\n\n    if (typeof args[1] === 'function') {\n      [eventType, listener, capture] = args;\n      targetSelector = undefined;\n    }\n\n    if (!capture) capture = false;\n    const events = eventType.split(' ');\n\n    for (let i = 0; i < events.length; i += 1) {\n      const event = events[i];\n\n      for (let j = 0; j < this.length; j += 1) {\n        const el = this[j];\n        let handlers;\n\n        if (!targetSelector && el.dom7Listeners) {\n          handlers = el.dom7Listeners[event];\n        } else if (targetSelector && el.dom7LiveListeners) {\n          handlers = el.dom7LiveListeners[event];\n        }\n\n        if (handlers && handlers.length) {\n          for (let k = handlers.length - 1; k >= 0; k -= 1) {\n            const handler = handlers[k];\n\n            if (listener && handler.listener === listener) {\n              el.removeEventListener(event, handler.proxyListener, capture);\n              handlers.splice(k, 1);\n            } else if (\n              listener &&\n              handler.listener &&\n              handler.listener.dom7proxy &&\n              handler.listener.dom7proxy === listener\n            ) {\n              el.removeEventListener(event, handler.proxyListener, capture);\n              handlers.splice(k, 1);\n            } else if (!listener) {\n              el.removeEventListener(event, handler.proxyListener, capture);\n              handlers.splice(k, 1);\n            }\n          }\n        }\n      }\n    }\n\n    return this;\n  }\n\n  function trigger() {\n    const window = getWindow();\n\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n\n    const events = args[0].split(' ');\n    const eventData = args[1];\n\n    for (let i = 0; i < events.length; i += 1) {\n      const event = events[i];\n\n      for (let j = 0; j < this.length; j += 1) {\n        const el = this[j];\n\n        if (window.CustomEvent) {\n          const evt = new window.CustomEvent(event, {\n            detail: eventData,\n            bubbles: true,\n            cancelable: true,\n          });\n          el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);\n          el.dispatchEvent(evt);\n          el.dom7EventData = [];\n          delete el.dom7EventData;\n        }\n      }\n    }\n\n    return this;\n  }\n\n  function transitionEnd$1(callback) {\n    const dom = this;\n\n    function fireCallBack(e) {\n      if (e.target !== this) return;\n      callback.call(this, e);\n      dom.off('transitionend', fireCallBack);\n    }\n\n    if (callback) {\n      dom.on('transitionend', fireCallBack);\n    }\n\n    return this;\n  }\n\n  function outerWidth(includeMargins) {\n    if (this.length > 0) {\n      if (includeMargins) {\n        const styles = this.styles();\n        return (\n          this[0].offsetWidth +\n          parseFloat(styles.getPropertyValue('margin-right')) +\n          parseFloat(styles.getPropertyValue('margin-left'))\n        );\n      }\n\n      return this[0].offsetWidth;\n    }\n\n    return null;\n  }\n\n  function outerHeight(includeMargins) {\n    if (this.length > 0) {\n      if (includeMargins) {\n        const styles = this.styles();\n        return (\n          this[0].offsetHeight +\n          parseFloat(styles.getPropertyValue('margin-top')) +\n          parseFloat(styles.getPropertyValue('margin-bottom'))\n        );\n      }\n\n      return this[0].offsetHeight;\n    }\n\n    return null;\n  }\n\n  function offset() {\n    if (this.length > 0) {\n      const window = getWindow();\n      const document = getDocument();\n      const el = this[0];\n      const box = el.getBoundingClientRect();\n      const { body } = document;\n      const clientTop = el.clientTop || body.clientTop || 0;\n      const clientLeft = el.clientLeft || body.clientLeft || 0;\n      const scrollTop = el === window ? window.scrollY : el.scrollTop;\n      const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n      return {\n        top: box.top + scrollTop - clientTop,\n        left: box.left + scrollLeft - clientLeft,\n      };\n    }\n\n    return null;\n  }\n\n  function styles() {\n    const window = getWindow();\n    if (this[0]) return window.getComputedStyle(this[0], null);\n    return {};\n  }\n\n  function css(props, value) {\n    const window = getWindow();\n    let i;\n\n    if (arguments.length === 1) {\n      if (typeof props === 'string') {\n        // .css('width')\n        if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);\n      } else {\n        // .css({ width: '100px' })\n        for (i = 0; i < this.length; i += 1) {\n          for (const prop in props) {\n            this[i].style[prop] = props[prop];\n          }\n        }\n\n        return this;\n      }\n    }\n\n    if (arguments.length === 2 && typeof props === 'string') {\n      // .css('width', '100px')\n      for (i = 0; i < this.length; i += 1) {\n        this[i].style[props] = value;\n      }\n\n      return this;\n    }\n\n    return this;\n  }\n\n  function each(callback) {\n    if (!callback) return this;\n    this.forEach((el, index) => {\n      callback.apply(el, [el, index]);\n    });\n    return this;\n  }\n\n  function filter(callback) {\n    const result = arrayFilter(this, callback);\n    return $(result);\n  }\n\n  function html(html) {\n    if (typeof html === 'undefined') {\n      return this[0] ? this[0].innerHTML : null;\n    }\n\n    for (let i = 0; i < this.length; i += 1) {\n      this[i].innerHTML = html;\n    }\n\n    return this;\n  }\n\n  function text(text) {\n    if (typeof text === 'undefined') {\n      return this[0] ? this[0].textContent.trim() : null;\n    }\n\n    for (let i = 0; i < this.length; i += 1) {\n      this[i].textContent = text;\n    }\n\n    return this;\n  }\n\n  function is(selector) {\n    const window = getWindow();\n    const document = getDocument();\n    const el = this[0];\n    let compareWith;\n    let i;\n    if (!el || typeof selector === 'undefined') return false;\n\n    if (typeof selector === 'string') {\n      if (el.matches) return el.matches(selector);\n      if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);\n      if (el.msMatchesSelector) return el.msMatchesSelector(selector);\n      compareWith = $(selector);\n\n      for (i = 0; i < compareWith.length; i += 1) {\n        if (compareWith[i] === el) return true;\n      }\n\n      return false;\n    }\n\n    if (selector === document) {\n      return el === document;\n    }\n\n    if (selector === window) {\n      return el === window;\n    }\n\n    if (selector.nodeType || selector instanceof Dom7) {\n      compareWith = selector.nodeType ? [selector] : selector;\n\n      for (i = 0; i < compareWith.length; i += 1) {\n        if (compareWith[i] === el) return true;\n      }\n\n      return false;\n    }\n\n    return false;\n  }\n\n  function index() {\n    let child = this[0];\n    let i;\n\n    if (child) {\n      i = 0; // eslint-disable-next-line\n\n      while ((child = child.previousSibling) !== null) {\n        if (child.nodeType === 1) i += 1;\n      }\n\n      return i;\n    }\n\n    return undefined;\n  }\n\n  function eq(index) {\n    if (typeof index === 'undefined') return this;\n    const { length } = this;\n\n    if (index > length - 1) {\n      return $([]);\n    }\n\n    if (index < 0) {\n      const returnIndex = length + index;\n      if (returnIndex < 0) return $([]);\n      return $([this[returnIndex]]);\n    }\n\n    return $([this[index]]);\n  }\n\n  function append() {\n    let newChild;\n    const document = getDocument();\n\n    for (let k = 0; k < arguments.length; k += 1) {\n      newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];\n\n      for (let i = 0; i < this.length; i += 1) {\n        if (typeof newChild === 'string') {\n          const tempDiv = document.createElement('div');\n          tempDiv.innerHTML = newChild;\n\n          while (tempDiv.firstChild) {\n            this[i].appendChild(tempDiv.firstChild);\n          }\n        } else if (newChild instanceof Dom7) {\n          for (let j = 0; j < newChild.length; j += 1) {\n            this[i].appendChild(newChild[j]);\n          }\n        } else {\n          this[i].appendChild(newChild);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  function prepend(newChild) {\n    const document = getDocument();\n    let i;\n    let j;\n\n    for (i = 0; i < this.length; i += 1) {\n      if (typeof newChild === 'string') {\n        const tempDiv = document.createElement('div');\n        tempDiv.innerHTML = newChild;\n\n        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\n          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\n        }\n      } else if (newChild instanceof Dom7) {\n        for (j = 0; j < newChild.length; j += 1) {\n          this[i].insertBefore(newChild[j], this[i].childNodes[0]);\n        }\n      } else {\n        this[i].insertBefore(newChild, this[i].childNodes[0]);\n      }\n    }\n\n    return this;\n  }\n\n  function next(selector) {\n    if (this.length > 0) {\n      if (selector) {\n        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\n          return $([this[0].nextElementSibling]);\n        }\n\n        return $([]);\n      }\n\n      if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);\n      return $([]);\n    }\n\n    return $([]);\n  }\n\n  function nextAll(selector) {\n    const nextEls = [];\n    let el = this[0];\n    if (!el) return $([]);\n\n    while (el.nextElementSibling) {\n      const next = el.nextElementSibling; // eslint-disable-line\n\n      if (selector) {\n        if ($(next).is(selector)) nextEls.push(next);\n      } else nextEls.push(next);\n\n      el = next;\n    }\n\n    return $(nextEls);\n  }\n\n  function prev(selector) {\n    if (this.length > 0) {\n      const el = this[0];\n\n      if (selector) {\n        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {\n          return $([el.previousElementSibling]);\n        }\n\n        return $([]);\n      }\n\n      if (el.previousElementSibling) return $([el.previousElementSibling]);\n      return $([]);\n    }\n\n    return $([]);\n  }\n\n  function prevAll(selector) {\n    const prevEls = [];\n    let el = this[0];\n    if (!el) return $([]);\n\n    while (el.previousElementSibling) {\n      const prev = el.previousElementSibling; // eslint-disable-line\n\n      if (selector) {\n        if ($(prev).is(selector)) prevEls.push(prev);\n      } else prevEls.push(prev);\n\n      el = prev;\n    }\n\n    return $(prevEls);\n  }\n\n  function parent(selector) {\n    const parents = []; // eslint-disable-line\n\n    for (let i = 0; i < this.length; i += 1) {\n      if (this[i].parentNode !== null) {\n        if (selector) {\n          if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);\n        } else {\n          parents.push(this[i].parentNode);\n        }\n      }\n    }\n\n    return $(parents);\n  }\n\n  function parents(selector) {\n    const parents = []; // eslint-disable-line\n\n    for (let i = 0; i < this.length; i += 1) {\n      let parent = this[i].parentNode; // eslint-disable-line\n\n      while (parent) {\n        if (selector) {\n          if ($(parent).is(selector)) parents.push(parent);\n        } else {\n          parents.push(parent);\n        }\n\n        parent = parent.parentNode;\n      }\n    }\n\n    return $(parents);\n  }\n\n  function closest(selector) {\n    let closest = this; // eslint-disable-line\n\n    if (typeof selector === 'undefined') {\n      return $([]);\n    }\n\n    if (!closest.is(selector)) {\n      closest = closest.parents(selector).eq(0);\n    }\n\n    return closest;\n  }\n\n  function find(selector) {\n    const foundElements = [];\n\n    for (let i = 0; i < this.length; i += 1) {\n      const found = this[i].querySelectorAll(selector);\n\n      for (let j = 0; j < found.length; j += 1) {\n        foundElements.push(found[j]);\n      }\n    }\n\n    return $(foundElements);\n  }\n\n  function children(selector) {\n    const children = []; // eslint-disable-line\n\n    for (let i = 0; i < this.length; i += 1) {\n      const childNodes = this[i].children;\n\n      for (let j = 0; j < childNodes.length; j += 1) {\n        if (!selector || $(childNodes[j]).is(selector)) {\n          children.push(childNodes[j]);\n        }\n      }\n    }\n\n    return $(children);\n  }\n\n  function remove() {\n    for (let i = 0; i < this.length; i += 1) {\n      if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);\n    }\n\n    return this;\n  }\n\n  const Methods = {\n    addClass,\n    removeClass,\n    hasClass,\n    toggleClass,\n    attr,\n    removeAttr,\n    transform,\n    transition: transition$1,\n    on,\n    off,\n    trigger,\n    transitionEnd: transitionEnd$1,\n    outerWidth,\n    outerHeight,\n    styles,\n    offset,\n    css,\n    each,\n    html,\n    text,\n    is,\n    index,\n    eq,\n    append,\n    prepend,\n    next,\n    nextAll,\n    prev,\n    prevAll,\n    parent,\n    parents,\n    closest,\n    find,\n    children,\n    filter,\n    remove,\n  };\n  Object.keys(Methods).forEach((methodName) => {\n    Object.defineProperty($.fn, methodName, {\n      value: Methods[methodName],\n      writable: true,\n    });\n  });\n\n  function deleteProps(obj) {\n    const object = obj;\n    Object.keys(object).forEach((key) => {\n      try {\n        object[key] = null;\n      } catch (e) {\n        // no getter for object\n      }\n\n      try {\n        delete object[key];\n      } catch (e) {\n        // something got wrong\n      }\n    });\n  }\n\n  function nextTick(callback, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return setTimeout(callback, delay);\n  }\n\n  function now() {\n    return Date.now();\n  }\n\n  function getComputedStyle$1(el) {\n    const window = getWindow();\n    let style;\n\n    if (window.getComputedStyle) {\n      style = window.getComputedStyle(el, null);\n    }\n\n    if (!style && el.currentStyle) {\n      style = el.currentStyle;\n    }\n\n    if (!style) {\n      style = el.style;\n    }\n\n    return style;\n  }\n\n  function getTranslate(el, axis) {\n    if (axis === void 0) {\n      axis = 'x';\n    }\n\n    const window = getWindow();\n    let matrix;\n    let curTransform;\n    let transformMatrix;\n    const curStyle = getComputedStyle$1(el);\n\n    if (window.WebKitCSSMatrix) {\n      curTransform = curStyle.transform || curStyle.webkitTransform;\n\n      if (curTransform.split(',').length > 6) {\n        curTransform = curTransform\n          .split(', ')\n          .map((a) => a.replace(',', '.'))\n          .join(', ');\n      } // Some old versions of Webkit choke when 'none' is passed; pass\n      // empty string instead in this case\n\n      transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n    } else {\n      transformMatrix =\n        curStyle.MozTransform ||\n        curStyle.OTransform ||\n        curStyle.MsTransform ||\n        curStyle.msTransform ||\n        curStyle.transform ||\n        curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n      matrix = transformMatrix.toString().split(',');\n    }\n\n    if (axis === 'x') {\n      // Latest Chrome and webkits Fix\n      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers\n      else curTransform = parseFloat(matrix[4]);\n    }\n\n    if (axis === 'y') {\n      // Latest Chrome and webkits Fix\n      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers\n      else curTransform = parseFloat(matrix[5]);\n    }\n\n    return curTransform || 0;\n  }\n\n  function isObject(o) {\n    return (\n      typeof o === 'object' &&\n      o !== null &&\n      o.constructor &&\n      Object.prototype.toString.call(o).slice(8, -1) === 'Object'\n    );\n  }\n\n  function isNode(node) {\n    // eslint-disable-next-line\n    if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n      return node instanceof HTMLElement;\n    }\n\n    return node && (node.nodeType === 1 || node.nodeType === 11);\n  }\n\n  function extend() {\n    const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n    const noExtend = ['__proto__', 'constructor', 'prototype'];\n\n    for (let i = 1; i < arguments.length; i += 1) {\n      const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n      if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n        const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);\n\n        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n          const nextKey = keysArray[nextIndex];\n          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\n          if (desc !== undefined && desc.enumerable) {\n            if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n              if (nextSource[nextKey].__swiper__) {\n                to[nextKey] = nextSource[nextKey];\n              } else {\n                extend(to[nextKey], nextSource[nextKey]);\n              }\n            } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n              to[nextKey] = {};\n\n              if (nextSource[nextKey].__swiper__) {\n                to[nextKey] = nextSource[nextKey];\n              } else {\n                extend(to[nextKey], nextSource[nextKey]);\n              }\n            } else {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n    }\n\n    return to;\n  }\n\n  function setCSSProperty(el, varName, varValue) {\n    el.style.setProperty(varName, varValue);\n  }\n\n  function animateCSSModeScroll(_ref) {\n    const { swiper, targetPosition, side } = _ref;\n    const window = getWindow();\n    const startPosition = -swiper.translate;\n    let startTime = null;\n    let time;\n    const duration = swiper.params.speed;\n    swiper.wrapperEl.style.scrollSnapType = 'none';\n    window.cancelAnimationFrame(swiper.cssModeFrameID);\n    const dir = targetPosition > startPosition ? 'next' : 'prev';\n\n    const isOutOfBound = (current, target) =>\n      (dir === 'next' && current >= target) || (dir === 'prev' && current <= target);\n\n    const animate = () => {\n      time = new Date().getTime();\n\n      if (startTime === null) {\n        startTime = time;\n      }\n\n      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n\n      if (isOutOfBound(currentPosition, targetPosition)) {\n        currentPosition = targetPosition;\n      }\n\n      swiper.wrapperEl.scrollTo({\n        [side]: currentPosition,\n      });\n\n      if (isOutOfBound(currentPosition, targetPosition)) {\n        swiper.wrapperEl.style.overflow = 'hidden';\n        swiper.wrapperEl.style.scrollSnapType = '';\n        setTimeout(() => {\n          swiper.wrapperEl.style.overflow = '';\n          swiper.wrapperEl.scrollTo({\n            [side]: currentPosition,\n          });\n        });\n        window.cancelAnimationFrame(swiper.cssModeFrameID);\n        return;\n      }\n\n      swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n    };\n\n    animate();\n  }\n\n  let support;\n\n  function calcSupport() {\n    const window = getWindow();\n    const document = getDocument();\n    return {\n      smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,\n      touch: !!('ontouchstart' in window || (window.DocumentTouch && document instanceof window.DocumentTouch)),\n      passiveListener: (function checkPassiveListener() {\n        let supportsPassive = false;\n\n        try {\n          const opts = Object.defineProperty({}, 'passive', {\n            // eslint-disable-next-line\n            get() {\n              supportsPassive = true;\n            },\n          });\n          window.addEventListener('testPassiveListener', null, opts);\n        } catch (e) {\n          // No support\n        }\n\n        return supportsPassive;\n      })(),\n      gestures: (function checkGestures() {\n        return 'ongesturestart' in window;\n      })(),\n    };\n  }\n\n  function getSupport() {\n    if (!support) {\n      support = calcSupport();\n    }\n\n    return support;\n  }\n\n  let deviceCached;\n\n  function calcDevice(_temp) {\n    const { userAgent } = _temp === void 0 ? {} : _temp;\n    const support = getSupport();\n    const window = getWindow();\n    const { platform } = window.navigator;\n    const ua = userAgent || window.navigator.userAgent;\n    const device = {\n      ios: false,\n      android: false,\n    };\n    const screenWidth = window.screen.width;\n    const screenHeight = window.screen.height;\n    const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n\n    let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n    const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n    const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n    const windows = platform === 'Win32';\n    let macos = platform === 'MacIntel'; // iPadOs 13 fix\n\n    const iPadScreens = [\n      '1024x1366',\n      '1366x1024',\n      '834x1194',\n      '1194x834',\n      '834x1112',\n      '1112x834',\n      '768x1024',\n      '1024x768',\n      '820x1180',\n      '1180x820',\n      '810x1080',\n      '1080x810',\n    ];\n\n    if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n      ipad = ua.match(/(Version)\\/([\\d.]+)/);\n      if (!ipad) ipad = [0, 1, '13_0_0'];\n      macos = false;\n    } // Android\n\n    if (android && !windows) {\n      device.os = 'android';\n      device.android = true;\n    }\n\n    if (ipad || iphone || ipod) {\n      device.os = 'ios';\n      device.ios = true;\n    } // Export object\n\n    return device;\n  }\n\n  function getDevice(overrides) {\n    if (overrides === void 0) {\n      overrides = {};\n    }\n\n    if (!deviceCached) {\n      deviceCached = calcDevice(overrides);\n    }\n\n    return deviceCached;\n  }\n\n  let browser;\n\n  function calcBrowser() {\n    const window = getWindow();\n\n    function isSafari() {\n      const ua = window.navigator.userAgent.toLowerCase();\n      return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n    }\n\n    return {\n      isSafari: isSafari(),\n      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),\n    };\n  }\n\n  function getBrowser() {\n    if (!browser) {\n      browser = calcBrowser();\n    }\n\n    return browser;\n  }\n\n  function Resize(_ref) {\n    const { swiper, on, emit } = _ref;\n    const window = getWindow();\n    let observer = null;\n    let animationFrame = null;\n\n    const resizeHandler = () => {\n      if (!swiper || swiper.destroyed || !swiper.initialized) return;\n      emit('beforeResize');\n      emit('resize');\n    };\n\n    const createObserver = () => {\n      if (!swiper || swiper.destroyed || !swiper.initialized) return;\n      observer = new ResizeObserver((entries) => {\n        animationFrame = window.requestAnimationFrame(() => {\n          const { width, height } = swiper;\n          let newWidth = width;\n          let newHeight = height;\n          entries.forEach((_ref2) => {\n            const { contentBoxSize, contentRect, target } = _ref2;\n            if (target && target !== swiper.el) return;\n            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n          });\n\n          if (newWidth !== width || newHeight !== height) {\n            resizeHandler();\n          }\n        });\n      });\n      observer.observe(swiper.el);\n    };\n\n    const removeObserver = () => {\n      if (animationFrame) {\n        window.cancelAnimationFrame(animationFrame);\n      }\n\n      if (observer && observer.unobserve && swiper.el) {\n        observer.unobserve(swiper.el);\n        observer = null;\n      }\n    };\n\n    const orientationChangeHandler = () => {\n      if (!swiper || swiper.destroyed || !swiper.initialized) return;\n      emit('orientationchange');\n    };\n\n    on('init', () => {\n      if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n        createObserver();\n        return;\n      }\n\n      window.addEventListener('resize', resizeHandler);\n      window.addEventListener('orientationchange', orientationChangeHandler);\n    });\n    on('destroy', () => {\n      removeObserver();\n      window.removeEventListener('resize', resizeHandler);\n      window.removeEventListener('orientationchange', orientationChangeHandler);\n    });\n  }\n\n  function Observer(_ref) {\n    const { swiper, extendParams, on, emit } = _ref;\n    const observers = [];\n    const window = getWindow();\n\n    const attach = function (target, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n      const observer = new ObserverFunc((mutations) => {\n        // The observerUpdate event should only be triggered\n        // once despite the number of mutations.  Additional\n        // triggers are redundant and are very costly\n        if (mutations.length === 1) {\n          emit('observerUpdate', mutations[0]);\n          return;\n        }\n\n        const observerUpdate = function observerUpdate() {\n          emit('observerUpdate', mutations[0]);\n        };\n\n        if (window.requestAnimationFrame) {\n          window.requestAnimationFrame(observerUpdate);\n        } else {\n          window.setTimeout(observerUpdate, 0);\n        }\n      });\n      observer.observe(target, {\n        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n        childList: typeof options.childList === 'undefined' ? true : options.childList,\n        characterData: typeof options.characterData === 'undefined' ? true : options.characterData,\n      });\n      observers.push(observer);\n    };\n\n    const init = () => {\n      if (!swiper.params.observer) return;\n\n      if (swiper.params.observeParents) {\n        const containerParents = swiper.$el.parents();\n\n        for (let i = 0; i < containerParents.length; i += 1) {\n          attach(containerParents[i]);\n        }\n      } // Observe container\n\n      attach(swiper.$el[0], {\n        childList: swiper.params.observeSlideChildren,\n      }); // Observe wrapper\n\n      attach(swiper.$wrapperEl[0], {\n        attributes: false,\n      });\n    };\n\n    const destroy = () => {\n      observers.forEach((observer) => {\n        observer.disconnect();\n      });\n      observers.splice(0, observers.length);\n    };\n\n    extendParams({\n      observer: false,\n      observeParents: false,\n      observeSlideChildren: false,\n    });\n    on('init', init);\n    on('destroy', destroy);\n  }\n\n  /* eslint-disable no-underscore-dangle */\n  const eventsEmitter = {\n    on(events, handler, priority) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (typeof handler !== 'function') return self;\n      const method = priority ? 'unshift' : 'push';\n      events.split(' ').forEach((event) => {\n        if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n        self.eventsListeners[event][method](handler);\n      });\n      return self;\n    },\n\n    once(events, handler, priority) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (typeof handler !== 'function') return self;\n\n      function onceHandler() {\n        self.off(events, onceHandler);\n\n        if (onceHandler.__emitterProxy) {\n          delete onceHandler.__emitterProxy;\n        }\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        handler.apply(self, args);\n      }\n\n      onceHandler.__emitterProxy = handler;\n      return self.on(events, onceHandler, priority);\n    },\n\n    onAny(handler, priority) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (typeof handler !== 'function') return self;\n      const method = priority ? 'unshift' : 'push';\n\n      if (self.eventsAnyListeners.indexOf(handler) < 0) {\n        self.eventsAnyListeners[method](handler);\n      }\n\n      return self;\n    },\n\n    offAny(handler) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (!self.eventsAnyListeners) return self;\n      const index = self.eventsAnyListeners.indexOf(handler);\n\n      if (index >= 0) {\n        self.eventsAnyListeners.splice(index, 1);\n      }\n\n      return self;\n    },\n\n    off(events, handler) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (!self.eventsListeners) return self;\n      events.split(' ').forEach((event) => {\n        if (typeof handler === 'undefined') {\n          self.eventsListeners[event] = [];\n        } else if (self.eventsListeners[event]) {\n          self.eventsListeners[event].forEach((eventHandler, index) => {\n            if (eventHandler === handler || (eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler)) {\n              self.eventsListeners[event].splice(index, 1);\n            }\n          });\n        }\n      });\n      return self;\n    },\n\n    emit() {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (!self.eventsListeners) return self;\n      let events;\n      let data;\n      let context;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n        events = args[0];\n        data = args.slice(1, args.length);\n        context = self;\n      } else {\n        events = args[0].events;\n        data = args[0].data;\n        context = args[0].context || self;\n      }\n\n      data.unshift(context);\n      const eventsArray = Array.isArray(events) ? events : events.split(' ');\n      eventsArray.forEach((event) => {\n        if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n          self.eventsAnyListeners.forEach((eventHandler) => {\n            eventHandler.apply(context, [event, ...data]);\n          });\n        }\n\n        if (self.eventsListeners && self.eventsListeners[event]) {\n          self.eventsListeners[event].forEach((eventHandler) => {\n            eventHandler.apply(context, data);\n          });\n        }\n      });\n      return self;\n    },\n  };\n\n  function updateSize() {\n    const swiper = this;\n    let width;\n    let height;\n    const { $el } = swiper;\n\n    if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n      width = swiper.params.width;\n    } else {\n      width = $el[0].clientWidth;\n    }\n\n    if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n      height = swiper.params.height;\n    } else {\n      height = $el[0].clientHeight;\n    }\n\n    if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {\n      return;\n    } // Subtract paddings\n\n    width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);\n    height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);\n    if (Number.isNaN(width)) width = 0;\n    if (Number.isNaN(height)) height = 0;\n    Object.assign(swiper, {\n      width,\n      height,\n      size: swiper.isHorizontal() ? width : height,\n    });\n  }\n\n  function updateSlides() {\n    const swiper = this;\n\n    function getDirectionLabel(property) {\n      if (swiper.isHorizontal()) {\n        return property;\n      } // prettier-ignore\n\n      return {\n        width: 'height',\n        'margin-top': 'margin-left',\n        'margin-bottom ': 'margin-right',\n        'margin-left': 'margin-top',\n        'margin-right': 'margin-bottom',\n        'padding-left': 'padding-top',\n        'padding-right': 'padding-bottom',\n        marginRight: 'marginBottom',\n      }[property];\n    }\n\n    function getDirectionPropertyValue(node, label) {\n      return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n    }\n\n    const { params } = swiper;\n    const { $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n    const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);\n    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n    let snapGrid = [];\n    const slidesGrid = [];\n    const slidesSizesGrid = [];\n    let offsetBefore = params.slidesOffsetBefore;\n\n    if (typeof offsetBefore === 'function') {\n      offsetBefore = params.slidesOffsetBefore.call(swiper);\n    }\n\n    let offsetAfter = params.slidesOffsetAfter;\n\n    if (typeof offsetAfter === 'function') {\n      offsetAfter = params.slidesOffsetAfter.call(swiper);\n    }\n\n    const previousSnapGridLength = swiper.snapGrid.length;\n    const previousSlidesGridLength = swiper.slidesGrid.length;\n    let { spaceBetween } = params;\n    let slidePosition = -offsetBefore;\n    let prevSlideSize = 0;\n    let index = 0;\n\n    if (typeof swiperSize === 'undefined') {\n      return;\n    }\n\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n      spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;\n    }\n\n    swiper.virtualSize = -spaceBetween; // reset margins\n\n    if (rtl) {\n      slides.css({\n        marginLeft: '',\n        marginBottom: '',\n        marginTop: '',\n      });\n    } else {\n      slides.css({\n        marginRight: '',\n        marginBottom: '',\n        marginTop: '',\n      });\n    } // reset cssMode offsets\n\n    if (params.centeredSlides && params.cssMode) {\n      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');\n      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');\n    }\n\n    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n\n    if (gridEnabled) {\n      swiper.grid.initSlides(slidesLength);\n    } // Calc slides\n\n    let slideSize;\n    const shouldResetSlideSize =\n      params.slidesPerView === 'auto' &&\n      params.breakpoints &&\n      Object.keys(params.breakpoints).filter((key) => typeof params.breakpoints[key].slidesPerView !== 'undefined')\n        .length > 0;\n\n    for (let i = 0; i < slidesLength; i += 1) {\n      slideSize = 0;\n      const slide = slides.eq(i);\n\n      if (gridEnabled) {\n        swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n      }\n\n      if (slide.css('display') === 'none') continue; // eslint-disable-line\n\n      if (params.slidesPerView === 'auto') {\n        if (shouldResetSlideSize) {\n          slides[i].style[getDirectionLabel('width')] = '';\n        }\n\n        const slideStyles = getComputedStyle(slide[0]);\n        const currentTransform = slide[0].style.transform;\n        const currentWebKitTransform = slide[0].style.webkitTransform;\n\n        if (currentTransform) {\n          slide[0].style.transform = 'none';\n        }\n\n        if (currentWebKitTransform) {\n          slide[0].style.webkitTransform = 'none';\n        }\n\n        if (params.roundLengths) {\n          slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);\n        } else {\n          // eslint-disable-next-line\n          const width = getDirectionPropertyValue(slideStyles, 'width');\n          const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n          const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n          const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n          const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n          const boxSizing = slideStyles.getPropertyValue('box-sizing');\n\n          if (boxSizing && boxSizing === 'border-box') {\n            slideSize = width + marginLeft + marginRight;\n          } else {\n            const { clientWidth, offsetWidth } = slide[0];\n            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n          }\n        }\n\n        if (currentTransform) {\n          slide[0].style.transform = currentTransform;\n        }\n\n        if (currentWebKitTransform) {\n          slide[0].style.webkitTransform = currentWebKitTransform;\n        }\n\n        if (params.roundLengths) slideSize = Math.floor(slideSize);\n      } else {\n        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n        if (params.roundLengths) slideSize = Math.floor(slideSize);\n\n        if (slides[i]) {\n          slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n        }\n      }\n\n      if (slides[i]) {\n        slides[i].swiperSlideSize = slideSize;\n      }\n\n      slidesSizesGrid.push(slideSize);\n\n      if (params.centeredSlides) {\n        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n        if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n        if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n        if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n        if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n        if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n        slidesGrid.push(slidePosition);\n      } else {\n        if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) {\n          snapGrid.push(slidePosition);\n        }\n        slidesGrid.push(slidePosition);\n        slidePosition = slidePosition + slideSize + spaceBetween;\n      }\n\n      swiper.virtualSize += slideSize + spaceBetween;\n      prevSlideSize = slideSize;\n      index += 1;\n    }\n\n    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n\n    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n      $wrapperEl.css({\n        width: `${swiper.virtualSize + params.spaceBetween}px`,\n      });\n    }\n\n    if (params.setWrapperSize) {\n      $wrapperEl.css({\n        [getDirectionLabel('width')]: `${swiper.virtualSize + params.spaceBetween}px`,\n      });\n    }\n\n    if (gridEnabled) {\n      swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n    } // Remove last grid elements depending on width\n\n    if (!params.centeredSlides) {\n      const newSlidesGrid = [];\n\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n\n        if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n          newSlidesGrid.push(slidesGridItem);\n        }\n      }\n\n      snapGrid = newSlidesGrid;\n\n      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n        snapGrid.push(swiper.virtualSize - swiperSize);\n      }\n    }\n\n    if (snapGrid.length === 0) snapGrid = [0];\n\n    if (params.spaceBetween !== 0) {\n      const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n      slides\n        .filter((_, slideIndex) => {\n          if (!params.cssMode) return true;\n\n          if (slideIndex === slides.length - 1) {\n            return false;\n          }\n\n          return true;\n        })\n        .css({\n          [key]: `${spaceBetween}px`,\n        });\n    }\n\n    if (params.centeredSlides && params.centeredSlidesBounds) {\n      let allSlidesSize = 0;\n      slidesSizesGrid.forEach((slideSizeValue) => {\n        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n      });\n      allSlidesSize -= params.spaceBetween;\n      const maxSnap = allSlidesSize - swiperSize;\n      snapGrid = snapGrid.map((snap) => {\n        if (snap < 0) return -offsetBefore;\n        if (snap > maxSnap) return maxSnap + offsetAfter;\n        return snap;\n      });\n    }\n\n    if (params.centerInsufficientSlides) {\n      let allSlidesSize = 0;\n      slidesSizesGrid.forEach((slideSizeValue) => {\n        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\n      });\n      allSlidesSize -= params.spaceBetween;\n\n      if (allSlidesSize < swiperSize) {\n        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n        snapGrid.forEach((snap, snapIndex) => {\n          snapGrid[snapIndex] = snap - allSlidesOffset;\n        });\n        slidesGrid.forEach((snap, snapIndex) => {\n          slidesGrid[snapIndex] = snap + allSlidesOffset;\n        });\n      }\n    }\n\n    Object.assign(swiper, {\n      slides,\n      snapGrid,\n      slidesGrid,\n      slidesSizesGrid,\n    });\n\n    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n      setCSSProperty(\n        swiper.wrapperEl,\n        '--swiper-centered-offset-after',\n        `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`\n      );\n      const addToSnapGrid = -swiper.snapGrid[0];\n      const addToSlidesGrid = -swiper.slidesGrid[0];\n      swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);\n      swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);\n    }\n\n    if (slidesLength !== previousSlidesLength) {\n      swiper.emit('slidesLengthChange');\n    }\n\n    if (snapGrid.length !== previousSnapGridLength) {\n      if (swiper.params.watchOverflow) swiper.checkOverflow();\n      swiper.emit('snapGridLengthChange');\n    }\n\n    if (slidesGrid.length !== previousSlidesGridLength) {\n      swiper.emit('slidesGridLengthChange');\n    }\n\n    if (params.watchSlidesProgress) {\n      swiper.updateSlidesOffset();\n    }\n\n    if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n      const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);\n\n      if (slidesLength <= params.maxBackfaceHiddenSlides) {\n        if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);\n      } else if (hasClassBackfaceClassAdded) {\n        swiper.$el.removeClass(backFaceHiddenClass);\n      }\n    }\n  }\n\n  function updateAutoHeight(speed) {\n    const swiper = this;\n    const activeSlides = [];\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let newHeight = 0;\n    let i;\n\n    if (typeof speed === 'number') {\n      swiper.setTransition(speed);\n    } else if (speed === true) {\n      swiper.setTransition(swiper.params.speed);\n    }\n\n    const getSlideByIndex = (index) => {\n      if (isVirtual) {\n        return swiper.slides.filter((el) => parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index)[0];\n      }\n\n      return swiper.slides.eq(index)[0];\n    }; // Find slides currently in view\n\n    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n      if (swiper.params.centeredSlides) {\n        (swiper.visibleSlides || $([])).each((slide) => {\n          activeSlides.push(slide);\n        });\n      } else {\n        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n          const index = swiper.activeIndex + i;\n          if (index > swiper.slides.length && !isVirtual) break;\n          activeSlides.push(getSlideByIndex(index));\n        }\n      }\n    } else {\n      activeSlides.push(getSlideByIndex(swiper.activeIndex));\n    } // Find new height from highest slide in view\n\n    for (i = 0; i < activeSlides.length; i += 1) {\n      if (typeof activeSlides[i] !== 'undefined') {\n        const height = activeSlides[i].offsetHeight;\n        newHeight = height > newHeight ? height : newHeight;\n      }\n    } // Update Height\n\n    if (newHeight || newHeight === 0) swiper.$wrapperEl.css('height', `${newHeight}px`);\n  }\n\n  function updateSlidesOffset() {\n    const swiper = this;\n    const { slides } = swiper;\n\n    for (let i = 0; i < slides.length; i += 1) {\n      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\n    }\n  }\n\n  function updateSlidesProgress(translate) {\n    if (translate === void 0) {\n      translate = (this && this.translate) || 0;\n    }\n\n    const swiper = this;\n    const { params } = swiper;\n    const { slides, rtlTranslate: rtl, snapGrid } = swiper;\n    if (slides.length === 0) return;\n    if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n    let offsetCenter = -translate;\n    if (rtl) offsetCenter = translate; // Visible Slides\n\n    slides.removeClass(params.slideVisibleClass);\n    swiper.visibleSlidesIndexes = [];\n    swiper.visibleSlides = [];\n\n    for (let i = 0; i < slides.length; i += 1) {\n      const slide = slides[i];\n      let slideOffset = slide.swiperSlideOffset;\n\n      if (params.cssMode && params.centeredSlides) {\n        slideOffset -= slides[0].swiperSlideOffset;\n      }\n\n      const slideProgress =\n        (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) /\n        (slide.swiperSlideSize + params.spaceBetween);\n      const originalSlideProgress =\n        (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) /\n        (slide.swiperSlideSize + params.spaceBetween);\n      const slideBefore = -(offsetCenter - slideOffset);\n      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n      const isVisible =\n        (slideBefore >= 0 && slideBefore < swiper.size - 1) ||\n        (slideAfter > 1 && slideAfter <= swiper.size) ||\n        (slideBefore <= 0 && slideAfter >= swiper.size);\n\n      if (isVisible) {\n        swiper.visibleSlides.push(slide);\n        swiper.visibleSlidesIndexes.push(i);\n        slides.eq(i).addClass(params.slideVisibleClass);\n      }\n\n      slide.progress = rtl ? -slideProgress : slideProgress;\n      slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n    }\n\n    swiper.visibleSlides = $(swiper.visibleSlides);\n  }\n\n  function updateProgress(translate) {\n    const swiper = this;\n\n    if (typeof translate === 'undefined') {\n      const multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line\n\n      translate = (swiper && swiper.translate && swiper.translate * multiplier) || 0;\n    }\n\n    const { params } = swiper;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    let { progress, isBeginning, isEnd } = swiper;\n    const wasBeginning = isBeginning;\n    const wasEnd = isEnd;\n\n    if (translatesDiff === 0) {\n      progress = 0;\n      isBeginning = true;\n      isEnd = true;\n    } else {\n      progress = (translate - swiper.minTranslate()) / translatesDiff;\n      isBeginning = progress <= 0;\n      isEnd = progress >= 1;\n    }\n\n    Object.assign(swiper, {\n      progress,\n      isBeginning,\n      isEnd,\n    });\n    if (params.watchSlidesProgress || (params.centeredSlides && params.autoHeight)) {\n      swiper.updateSlidesProgress(translate);\n    }\n\n    if (isBeginning && !wasBeginning) {\n      swiper.emit('reachBeginning toEdge');\n    }\n\n    if (isEnd && !wasEnd) {\n      swiper.emit('reachEnd toEdge');\n    }\n\n    if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\n      swiper.emit('fromEdge');\n    }\n\n    swiper.emit('progress', progress);\n  }\n\n  function updateSlidesClasses() {\n    const swiper = this;\n    const { slides, params, $wrapperEl, activeIndex, realIndex } = swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    slides.removeClass(\n      `${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`\n    );\n    let activeSlide;\n\n    if (isVirtual) {\n      activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index=\"${activeIndex}\"]`);\n    } else {\n      activeSlide = slides.eq(activeIndex);\n    } // Active classes\n\n    activeSlide.addClass(params.slideActiveClass);\n\n    if (params.loop) {\n      // Duplicate to all looped slides\n      if (activeSlide.hasClass(params.slideDuplicateClass)) {\n        $wrapperEl\n          .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${realIndex}\"]`)\n          .addClass(params.slideDuplicateActiveClass);\n      } else {\n        $wrapperEl\n          .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${realIndex}\"]`)\n          .addClass(params.slideDuplicateActiveClass);\n      }\n    } // Next Slide\n\n    let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);\n\n    if (params.loop && nextSlide.length === 0) {\n      nextSlide = slides.eq(0);\n      nextSlide.addClass(params.slideNextClass);\n    } // Prev Slide\n\n    let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);\n\n    if (params.loop && prevSlide.length === 0) {\n      prevSlide = slides.eq(-1);\n      prevSlide.addClass(params.slidePrevClass);\n    }\n\n    if (params.loop) {\n      // Duplicate to all looped slides\n      if (nextSlide.hasClass(params.slideDuplicateClass)) {\n        $wrapperEl\n          .children(\n            `.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${nextSlide.attr(\n              'data-swiper-slide-index'\n            )}\"]`\n          )\n          .addClass(params.slideDuplicateNextClass);\n      } else {\n        $wrapperEl\n          .children(\n            `.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${nextSlide.attr(\n              'data-swiper-slide-index'\n            )}\"]`\n          )\n          .addClass(params.slideDuplicateNextClass);\n      }\n\n      if (prevSlide.hasClass(params.slideDuplicateClass)) {\n        $wrapperEl\n          .children(\n            `.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index=\"${prevSlide.attr(\n              'data-swiper-slide-index'\n            )}\"]`\n          )\n          .addClass(params.slideDuplicatePrevClass);\n      } else {\n        $wrapperEl\n          .children(\n            `.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index=\"${prevSlide.attr(\n              'data-swiper-slide-index'\n            )}\"]`\n          )\n          .addClass(params.slideDuplicatePrevClass);\n      }\n    }\n\n    swiper.emitSlidesClasses();\n  }\n\n  function updateActiveIndex(newActiveIndex) {\n    const swiper = this;\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    const {\n      slidesGrid,\n      snapGrid,\n      params,\n      activeIndex: previousIndex,\n      realIndex: previousRealIndex,\n      snapIndex: previousSnapIndex,\n    } = swiper;\n    let activeIndex = newActiveIndex;\n    let snapIndex;\n\n    if (typeof activeIndex === 'undefined') {\n      for (let i = 0; i < slidesGrid.length; i += 1) {\n        if (typeof slidesGrid[i + 1] !== 'undefined') {\n          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n            activeIndex = i;\n          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n            activeIndex = i + 1;\n          }\n        } else if (translate >= slidesGrid[i]) {\n          activeIndex = i;\n        }\n      } // Normalize slideIndex\n\n      if (params.normalizeSlideIndex) {\n        if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n      }\n    }\n\n    if (snapGrid.indexOf(translate) >= 0) {\n      snapIndex = snapGrid.indexOf(translate);\n    } else {\n      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n    }\n\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n    if (activeIndex === previousIndex) {\n      if (snapIndex !== previousSnapIndex) {\n        swiper.snapIndex = snapIndex;\n        swiper.emit('snapIndexChange');\n      }\n\n      return;\n    } // Get real index\n\n    const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);\n    Object.assign(swiper, {\n      snapIndex,\n      realIndex,\n      previousIndex,\n      activeIndex,\n    });\n    swiper.emit('activeIndexChange');\n    swiper.emit('snapIndexChange');\n\n    if (previousRealIndex !== realIndex) {\n      swiper.emit('realIndexChange');\n    }\n\n    if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n      swiper.emit('slideChange');\n    }\n  }\n\n  function updateClickedSlide(e) {\n    const swiper = this;\n    const { params } = swiper;\n    const slide = $(e).closest(`.${params.slideClass}`)[0];\n    let slideFound = false;\n    let slideIndex;\n\n    if (slide) {\n      for (let i = 0; i < swiper.slides.length; i += 1) {\n        if (swiper.slides[i] === slide) {\n          slideFound = true;\n          slideIndex = i;\n          break;\n        }\n      }\n    }\n\n    if (slide && slideFound) {\n      swiper.clickedSlide = slide;\n\n      if (swiper.virtual && swiper.params.virtual.enabled) {\n        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);\n      } else {\n        swiper.clickedIndex = slideIndex;\n      }\n    } else {\n      swiper.clickedSlide = undefined;\n      swiper.clickedIndex = undefined;\n      return;\n    }\n\n    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n      swiper.slideToClickedSlide();\n    }\n  }\n\n  const update = {\n    updateSize,\n    updateSlides,\n    updateAutoHeight,\n    updateSlidesOffset,\n    updateSlidesProgress,\n    updateProgress,\n    updateSlidesClasses,\n    updateActiveIndex,\n    updateClickedSlide,\n  };\n\n  function getSwiperTranslate(axis) {\n    if (axis === void 0) {\n      axis = this.isHorizontal() ? 'x' : 'y';\n    }\n\n    const swiper = this;\n    const { params, rtlTranslate: rtl, translate, $wrapperEl } = swiper;\n\n    if (params.virtualTranslate) {\n      return rtl ? -translate : translate;\n    }\n\n    if (params.cssMode) {\n      return translate;\n    }\n\n    let currentTranslate = getTranslate($wrapperEl[0], axis);\n    if (rtl) currentTranslate = -currentTranslate;\n    return currentTranslate || 0;\n  }\n\n  function setTranslate(translate, byController) {\n    const swiper = this;\n    const { rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress } = swiper;\n    let x = 0;\n    let y = 0;\n    const z = 0;\n\n    if (swiper.isHorizontal()) {\n      x = rtl ? -translate : translate;\n    } else {\n      y = translate;\n    }\n\n    if (params.roundLengths) {\n      x = Math.floor(x);\n      y = Math.floor(y);\n    }\n\n    if (params.cssMode) {\n      wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n    } else if (!params.virtualTranslate) {\n      $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);\n    }\n\n    swiper.previousTranslate = swiper.translate;\n    swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress\n\n    let newProgress;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\n    if (translatesDiff === 0) {\n      newProgress = 0;\n    } else {\n      newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n    }\n\n    if (newProgress !== progress) {\n      swiper.updateProgress(translate);\n    }\n\n    swiper.emit('setTranslate', swiper.translate, byController);\n  }\n\n  function minTranslate() {\n    return -this.snapGrid[0];\n  }\n\n  function maxTranslate() {\n    return -this.snapGrid[this.snapGrid.length - 1];\n  }\n\n  function translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n    if (translate === void 0) {\n      translate = 0;\n    }\n\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n\n    if (translateBounds === void 0) {\n      translateBounds = true;\n    }\n\n    const swiper = this;\n    const { params, wrapperEl } = swiper;\n\n    if (swiper.animating && params.preventInteractionOnTransition) {\n      return false;\n    }\n\n    const minTranslate = swiper.minTranslate();\n    const maxTranslate = swiper.maxTranslate();\n    let newTranslate;\n    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;\n    else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;\n    else newTranslate = translate; // Update progress\n\n    swiper.updateProgress(newTranslate);\n\n    if (params.cssMode) {\n      const isH = swiper.isHorizontal();\n\n      if (speed === 0) {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n      } else {\n        if (!swiper.support.smoothScroll) {\n          animateCSSModeScroll({\n            swiper,\n            targetPosition: -newTranslate,\n            side: isH ? 'left' : 'top',\n          });\n          return true;\n        }\n\n        wrapperEl.scrollTo({\n          [isH ? 'left' : 'top']: -newTranslate,\n          behavior: 'smooth',\n        });\n      }\n\n      return true;\n    }\n\n    if (speed === 0) {\n      swiper.setTransition(0);\n      swiper.setTranslate(newTranslate);\n\n      if (runCallbacks) {\n        swiper.emit('beforeTransitionStart', speed, internal);\n        swiper.emit('transitionEnd');\n      }\n    } else {\n      swiper.setTransition(speed);\n      swiper.setTranslate(newTranslate);\n\n      if (runCallbacks) {\n        swiper.emit('beforeTransitionStart', speed, internal);\n        swiper.emit('transitionStart');\n      }\n\n      if (!swiper.animating) {\n        swiper.animating = true;\n\n        if (!swiper.onTranslateToWrapperTransitionEnd) {\n          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n            if (!swiper || swiper.destroyed) return;\n            if (e.target !== this) return;\n            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);\n            swiper.onTranslateToWrapperTransitionEnd = null;\n            delete swiper.onTranslateToWrapperTransitionEnd;\n\n            if (runCallbacks) {\n              swiper.emit('transitionEnd');\n            }\n          };\n        }\n\n        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);\n      }\n    }\n\n    return true;\n  }\n\n  const translate = {\n    getTranslate: getSwiperTranslate,\n    setTranslate,\n    minTranslate,\n    maxTranslate,\n    translateTo,\n  };\n\n  function setTransition(duration, byController) {\n    const swiper = this;\n\n    if (!swiper.params.cssMode) {\n      swiper.$wrapperEl.transition(duration);\n    }\n\n    swiper.emit('setTransition', duration, byController);\n  }\n\n  function transitionEmit(_ref) {\n    const { swiper, runCallbacks, direction, step } = _ref;\n    const { activeIndex, previousIndex } = swiper;\n    let dir = direction;\n\n    if (!dir) {\n      if (activeIndex > previousIndex) dir = 'next';\n      else if (activeIndex < previousIndex) dir = 'prev';\n      else dir = 'reset';\n    }\n\n    swiper.emit(`transition${step}`);\n\n    if (runCallbacks && activeIndex !== previousIndex) {\n      if (dir === 'reset') {\n        swiper.emit(`slideResetTransition${step}`);\n        return;\n      }\n\n      swiper.emit(`slideChangeTransition${step}`);\n\n      if (dir === 'next') {\n        swiper.emit(`slideNextTransition${step}`);\n      } else {\n        swiper.emit(`slidePrevTransition${step}`);\n      }\n    }\n  }\n\n  function transitionStart(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n\n    const swiper = this;\n    const { params } = swiper;\n    if (params.cssMode) return;\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n\n    transitionEmit({\n      swiper,\n      runCallbacks,\n      direction,\n      step: 'Start',\n    });\n  }\n\n  function transitionEnd(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n\n    const swiper = this;\n    const { params } = swiper;\n    swiper.animating = false;\n    if (params.cssMode) return;\n    swiper.setTransition(0);\n    transitionEmit({\n      swiper,\n      runCallbacks,\n      direction,\n      step: 'End',\n    });\n  }\n\n  const transition = {\n    setTransition,\n    transitionStart,\n    transitionEnd,\n  };\n\n  function slideTo(index, speed, runCallbacks, internal, initial) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n\n    if (typeof index !== 'number' && typeof index !== 'string') {\n      throw new Error(\n        `The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`\n      );\n    }\n\n    if (typeof index === 'string') {\n      /**\n       * The `index` argument converted from `string` to `number`.\n       * @type {number}\n       */\n      const indexAsNumber = parseInt(index, 10);\n      /**\n       * Determines whether the `index` argument is a valid `number`\n       * after being converted from the `string` type.\n       * @type {boolean}\n       */\n\n      const isValidNumber = isFinite(indexAsNumber);\n\n      if (!isValidNumber) {\n        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);\n      } // Knowing that the converted `index` is a valid number,\n      // we can update the original argument's value.\n\n      index = indexAsNumber;\n    }\n\n    const swiper = this;\n    let slideIndex = index;\n    if (slideIndex < 0) slideIndex = 0;\n    const { params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled } = swiper;\n\n    if ((swiper.animating && params.preventInteractionOnTransition) || (!enabled && !internal && !initial)) {\n      return false;\n    }\n\n    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n      swiper.emit('beforeSlideChangeStart');\n    }\n\n    const translate = -snapGrid[snapIndex]; // Update progress\n\n    swiper.updateProgress(translate); // Normalize slideIndex\n\n    if (params.normalizeSlideIndex) {\n      for (let i = 0; i < slidesGrid.length; i += 1) {\n        const normalizedTranslate = -Math.floor(translate * 100);\n        const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n\n        if (typeof slidesGrid[i + 1] !== 'undefined') {\n          if (\n            normalizedTranslate >= normalizedGrid &&\n            normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2\n          ) {\n            slideIndex = i;\n          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n            slideIndex = i + 1;\n          }\n        } else if (normalizedTranslate >= normalizedGrid) {\n          slideIndex = i;\n        }\n      }\n    } // Directions locks\n\n    if (swiper.initialized && slideIndex !== activeIndex) {\n      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n        return false;\n      }\n\n      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n        if ((activeIndex || 0) !== slideIndex) return false;\n      }\n    }\n\n    let direction;\n    if (slideIndex > activeIndex) direction = 'next';\n    else if (slideIndex < activeIndex) direction = 'prev';\n    else direction = 'reset'; // Update Index\n\n    if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\n      swiper.updateActiveIndex(slideIndex); // Update Height\n\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n\n      swiper.updateSlidesClasses();\n\n      if (params.effect !== 'slide') {\n        swiper.setTranslate(translate);\n      }\n\n      if (direction !== 'reset') {\n        swiper.transitionStart(runCallbacks, direction);\n        swiper.transitionEnd(runCallbacks, direction);\n      }\n\n      return false;\n    }\n\n    if (params.cssMode) {\n      const isH = swiper.isHorizontal();\n      const t = rtl ? translate : -translate;\n\n      if (speed === 0) {\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n        if (isVirtual) {\n          swiper.wrapperEl.style.scrollSnapType = 'none';\n          swiper._immediateVirtual = true;\n        }\n\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n\n        if (isVirtual) {\n          requestAnimationFrame(() => {\n            swiper.wrapperEl.style.scrollSnapType = '';\n            swiper._swiperImmediateVirtual = false;\n          });\n        }\n      } else {\n        if (!swiper.support.smoothScroll) {\n          animateCSSModeScroll({\n            swiper,\n            targetPosition: t,\n            side: isH ? 'left' : 'top',\n          });\n          return true;\n        }\n\n        wrapperEl.scrollTo({\n          [isH ? 'left' : 'top']: t,\n          behavior: 'smooth',\n        });\n      }\n\n      return true;\n    }\n\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n\n    if (speed === 0) {\n      swiper.transitionEnd(runCallbacks, direction);\n    } else if (!swiper.animating) {\n      swiper.animating = true;\n\n      if (!swiper.onSlideToWrapperTransitionEnd) {\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n          swiper.onSlideToWrapperTransitionEnd = null;\n          delete swiper.onSlideToWrapperTransitionEnd;\n          swiper.transitionEnd(runCallbacks, direction);\n        };\n      }\n\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n    }\n\n    return true;\n  }\n\n  function slideToLoop(index, speed, runCallbacks, internal) {\n    if (index === void 0) {\n      index = 0;\n    }\n\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n\n    if (typeof index === 'string') {\n      /**\n       * The `index` argument converted from `string` to `number`.\n       * @type {number}\n       */\n      const indexAsNumber = parseInt(index, 10);\n      /**\n       * Determines whether the `index` argument is a valid `number`\n       * after being converted from the `string` type.\n       * @type {boolean}\n       */\n\n      const isValidNumber = isFinite(indexAsNumber);\n\n      if (!isValidNumber) {\n        throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);\n      } // Knowing that the converted `index` is a valid number,\n      // we can update the original argument's value.\n\n      index = indexAsNumber;\n    }\n\n    const swiper = this;\n    let newIndex = index;\n\n    if (swiper.params.loop) {\n      newIndex += swiper.loopedSlides;\n    }\n\n    return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slideNext(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n\n    const swiper = this;\n    const { animating, enabled, params } = swiper;\n    if (!enabled) return swiper;\n    let perGroup = params.slidesPerGroup;\n\n    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n      perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n    }\n\n    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n\n    if (params.loop) {\n      if (animating && params.loopPreventsSlide) return false;\n      swiper.loopFix(); // eslint-disable-next-line\n\n      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n    }\n\n    if (params.rewind && swiper.isEnd) {\n      return swiper.slideTo(0, speed, runCallbacks, internal);\n    }\n\n    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slidePrev(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n\n    const swiper = this;\n    const { params, animating, snapGrid, slidesGrid, rtlTranslate, enabled } = swiper;\n    if (!enabled) return swiper;\n\n    if (params.loop) {\n      if (animating && params.loopPreventsSlide) return false;\n      swiper.loopFix(); // eslint-disable-next-line\n\n      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n    }\n\n    const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n\n    function normalize(val) {\n      if (val < 0) return -Math.floor(Math.abs(val));\n      return Math.floor(val);\n    }\n\n    const normalizedTranslate = normalize(translate);\n    const normalizedSnapGrid = snapGrid.map((val) => normalize(val));\n    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n\n    if (typeof prevSnap === 'undefined' && params.cssMode) {\n      let prevSnapIndex;\n      snapGrid.forEach((snap, snapIndex) => {\n        if (normalizedTranslate >= snap) {\n          // prevSnap = snap;\n          prevSnapIndex = snapIndex;\n        }\n      });\n\n      if (typeof prevSnapIndex !== 'undefined') {\n        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n      }\n    }\n\n    let prevIndex = 0;\n\n    if (typeof prevSnap !== 'undefined') {\n      prevIndex = slidesGrid.indexOf(prevSnap);\n      if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n\n      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n        prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n        prevIndex = Math.max(prevIndex, 0);\n      }\n    }\n\n    if (params.rewind && swiper.isBeginning) {\n      const lastIndex =\n        swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual\n          ? swiper.virtual.slides.length - 1\n          : swiper.slides.length - 1;\n      return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n    }\n\n    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slideReset(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n\n    const swiper = this;\n    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slideToClosest(speed, runCallbacks, internal, threshold) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n\n    if (threshold === void 0) {\n      threshold = 0.5;\n    }\n\n    const swiper = this;\n    let index = swiper.activeIndex;\n    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n\n    if (translate >= swiper.snapGrid[snapIndex]) {\n      // The current translate is on or after the current snap index, so the choice\n      // is between the current index and the one after it.\n      const currentSnap = swiper.snapGrid[snapIndex];\n      const nextSnap = swiper.snapGrid[snapIndex + 1];\n\n      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n        index += swiper.params.slidesPerGroup;\n      }\n    } else {\n      // The current translate is before the current snap index, so the choice\n      // is between the current index and the one before it.\n      const prevSnap = swiper.snapGrid[snapIndex - 1];\n      const currentSnap = swiper.snapGrid[snapIndex];\n\n      if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n        index -= swiper.params.slidesPerGroup;\n      }\n    }\n\n    index = Math.max(index, 0);\n    index = Math.min(index, swiper.slidesGrid.length - 1);\n    return swiper.slideTo(index, speed, runCallbacks, internal);\n  }\n\n  function slideToClickedSlide() {\n    const swiper = this;\n    const { params, $wrapperEl } = swiper;\n    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n    let slideToIndex = swiper.clickedIndex;\n    let realIndex;\n\n    if (params.loop) {\n      if (swiper.animating) return;\n      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n\n      if (params.centeredSlides) {\n        if (\n          slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||\n          slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2\n        ) {\n          swiper.loopFix();\n          slideToIndex = $wrapperEl\n            .children(\n              `.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`\n            )\n            .eq(0)\n            .index();\n          nextTick(() => {\n            swiper.slideTo(slideToIndex);\n          });\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n        swiper.loopFix();\n        slideToIndex = $wrapperEl\n          .children(`.${params.slideClass}[data-swiper-slide-index=\"${realIndex}\"]:not(.${params.slideDuplicateClass})`)\n          .eq(0)\n          .index();\n        nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  }\n\n  const slide = {\n    slideTo,\n    slideToLoop,\n    slideNext,\n    slidePrev,\n    slideReset,\n    slideToClosest,\n    slideToClickedSlide,\n  };\n\n  function loopCreate() {\n    const swiper = this;\n    const document = getDocument();\n    const { params, $wrapperEl } = swiper; // Remove duplicated slides\n\n    const $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;\n    $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();\n    let slides = $selector.children(`.${params.slideClass}`);\n\n    if (params.loopFillGroupWithBlank) {\n      const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);\n\n      if (blankSlidesNum !== params.slidesPerGroup) {\n        for (let i = 0; i < blankSlidesNum; i += 1) {\n          const blankNode = $(document.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);\n          $selector.append(blankNode);\n        }\n\n        slides = $selector.children(`.${params.slideClass}`);\n      }\n    }\n\n    if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;\n    swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));\n    swiper.loopedSlides += params.loopAdditionalSlides;\n\n    if (swiper.loopedSlides > slides.length) {\n      swiper.loopedSlides = slides.length;\n    }\n\n    const prependSlides = [];\n    const appendSlides = [];\n    slides.each((el, index) => {\n      const slide = $(el);\n\n      if (index < swiper.loopedSlides) {\n        appendSlides.push(el);\n      }\n\n      if (index < slides.length && index >= slides.length - swiper.loopedSlides) {\n        prependSlides.push(el);\n      }\n\n      slide.attr('data-swiper-slide-index', index);\n    });\n\n    for (let i = 0; i < appendSlides.length; i += 1) {\n      $selector.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n    }\n\n    for (let i = prependSlides.length - 1; i >= 0; i -= 1) {\n      $selector.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));\n    }\n  }\n\n  function loopFix() {\n    const swiper = this;\n    swiper.emit('beforeLoopFix');\n    const { activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl } = swiper;\n    let newIndex;\n    swiper.allowSlidePrev = true;\n    swiper.allowSlideNext = true;\n    const snapTranslate = -snapGrid[activeIndex];\n    const diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding\n\n    if (activeIndex < loopedSlides) {\n      newIndex = slides.length - loopedSlides * 3 + activeIndex;\n      newIndex += loopedSlides;\n      const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n\n      if (slideChanged && diff !== 0) {\n        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n      }\n    } else if (activeIndex >= slides.length - loopedSlides) {\n      // Fix For Positive Oversliding\n      newIndex = -slides.length + activeIndex + loopedSlides;\n      newIndex += loopedSlides;\n      const slideChanged = swiper.slideTo(newIndex, 0, false, true);\n\n      if (slideChanged && diff !== 0) {\n        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\n      }\n    }\n\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    swiper.emit('loopFix');\n  }\n\n  function loopDestroy() {\n    const swiper = this;\n    const { $wrapperEl, params, slides } = swiper;\n    $wrapperEl\n      .children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`)\n      .remove();\n    slides.removeAttr('data-swiper-slide-index');\n  }\n\n  const loop = {\n    loopCreate,\n    loopFix,\n    loopDestroy,\n  };\n\n  function setGrabCursor(moving) {\n    const swiper = this;\n    if (\n      swiper.support.touch ||\n      !swiper.params.simulateTouch ||\n      (swiper.params.watchOverflow && swiper.isLocked) ||\n      swiper.params.cssMode\n    ) {\n      return;\n    }\n    const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n    el.style.cursor = 'move';\n    el.style.cursor = moving ? 'grabbing' : 'grab';\n  }\n\n  function unsetGrabCursor() {\n    const swiper = this;\n\n    if (swiper.support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) {\n      return;\n    }\n\n    swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n  }\n\n  const grabCursor = {\n    setGrabCursor,\n    unsetGrabCursor,\n  };\n\n  function closestElement(selector, base) {\n    if (base === void 0) {\n      base = this;\n    }\n\n    function __closestFrom(el) {\n      if (!el || el === getDocument() || el === getWindow()) return null;\n      if (el.assignedSlot) el = el.assignedSlot;\n      const found = el.closest(selector);\n\n      if (!found && !el.getRootNode) {\n        return null;\n      }\n\n      return found || __closestFrom(el.getRootNode().host);\n    }\n\n    return __closestFrom(base);\n  }\n\n  function onTouchStart(event) {\n    const swiper = this;\n    const document = getDocument();\n    const window = getWindow();\n    const data = swiper.touchEventsData;\n    const { params, touches, enabled } = swiper;\n    if (!enabled) return;\n\n    if (swiper.animating && params.preventInteractionOnTransition) {\n      return;\n    }\n\n    if (!swiper.animating && params.cssMode && params.loop) {\n      swiper.loopFix();\n    }\n\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    let $targetEl = $(e.target);\n\n    if (params.touchEventsTarget === 'wrapper') {\n      if (!$targetEl.closest(swiper.wrapperEl).length) return;\n    }\n\n    data.isTouchEvent = e.type === 'touchstart';\n    if (!data.isTouchEvent && 'which' in e && e.which === 3) return;\n    if (!data.isTouchEvent && 'button' in e && e.button > 0) return;\n    if (data.isTouched && data.isMoved) return; // change target el for shadow root component\n\n    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n\n    if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {\n      $targetEl = $(event.path[0]);\n    }\n\n    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n    const isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element\n\n    if (\n      params.noSwiping &&\n      (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])\n    ) {\n      swiper.allowClick = true;\n      return;\n    }\n\n    if (params.swipeHandler) {\n      if (!$targetEl.closest(params.swipeHandler)[0]) return;\n    }\n\n    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n    const startX = touches.currentX;\n    const startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n\n    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n      if (edgeSwipeDetection === 'prevent') {\n        event.preventDefault();\n      } else {\n        return;\n      }\n    }\n\n    Object.assign(data, {\n      isTouched: true,\n      isMoved: false,\n      allowTouchCallbacks: true,\n      isScrolling: undefined,\n      startMoving: undefined,\n    });\n    touches.startX = startX;\n    touches.startY = startY;\n    data.touchStartTime = now();\n    swiper.allowClick = true;\n    swiper.updateSize();\n    swiper.swipeDirection = undefined;\n    if (params.threshold > 0) data.allowThresholdMove = false;\n\n    if (e.type !== 'touchstart') {\n      let preventDefault = true;\n\n      if ($targetEl.is(data.focusableElements)) {\n        preventDefault = false;\n\n        if ($targetEl[0].nodeName === 'SELECT') {\n          data.isTouched = false;\n        }\n      }\n\n      if (\n        document.activeElement &&\n        $(document.activeElement).is(data.focusableElements) &&\n        document.activeElement !== $targetEl[0]\n      ) {\n        document.activeElement.blur();\n      }\n\n      const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n\n      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {\n        e.preventDefault();\n      }\n    }\n\n    if (\n      swiper.params.freeMode &&\n      swiper.params.freeMode.enabled &&\n      swiper.freeMode &&\n      swiper.animating &&\n      !params.cssMode\n    ) {\n      swiper.freeMode.onTouchStart();\n    }\n\n    swiper.emit('touchStart', e);\n  }\n\n  function onTouchMove(event) {\n    const document = getDocument();\n    const swiper = this;\n    const data = swiper.touchEventsData;\n    const { params, touches, rtlTranslate: rtl, enabled } = swiper;\n    if (!enabled) return;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n\n    if (!data.isTouched) {\n      if (data.startMoving && data.isScrolling) {\n        swiper.emit('touchMoveOpposite', e);\n      }\n\n      return;\n    }\n\n    if (data.isTouchEvent && e.type !== 'touchmove') return;\n    const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);\n    const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;\n    const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;\n\n    if (e.preventedByNestedSwiper) {\n      touches.startX = pageX;\n      touches.startY = pageY;\n      return;\n    }\n\n    if (!swiper.allowTouchMove) {\n      if (!$(e.target).is(data.focusableElements)) {\n        swiper.allowClick = false;\n      }\n\n      if (data.isTouched) {\n        Object.assign(touches, {\n          startX: pageX,\n          startY: pageY,\n          currentX: pageX,\n          currentY: pageY,\n        });\n        data.touchStartTime = now();\n      }\n\n      return;\n    }\n\n    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\n      if (swiper.isVertical()) {\n        // Vertical\n        if (\n          (pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) ||\n          (pageY > touches.startY && swiper.translate >= swiper.minTranslate())\n        ) {\n          data.isTouched = false;\n          data.isMoved = false;\n          return;\n        }\n      } else if (\n        (pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) ||\n        (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\n      ) {\n        return;\n      }\n    }\n\n    if (data.isTouchEvent && document.activeElement) {\n      if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {\n        data.isMoved = true;\n        swiper.allowClick = false;\n        return;\n      }\n    }\n\n    if (data.allowTouchCallbacks) {\n      swiper.emit('touchMove', e);\n    }\n\n    if (e.targetTouches && e.targetTouches.length > 1) return;\n    touches.currentX = pageX;\n    touches.currentY = pageY;\n    const diffX = touches.currentX - touches.startX;\n    const diffY = touches.currentY - touches.startY;\n    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n\n    if (typeof data.isScrolling === 'undefined') {\n      let touchAngle;\n\n      if (\n        (swiper.isHorizontal() && touches.currentY === touches.startY) ||\n        (swiper.isVertical() && touches.currentX === touches.startX)\n      ) {\n        data.isScrolling = false;\n      } else {\n        // eslint-disable-next-line\n        if (diffX * diffX + diffY * diffY >= 25) {\n          touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\n          data.isScrolling = swiper.isHorizontal()\n            ? touchAngle > params.touchAngle\n            : 90 - touchAngle > params.touchAngle;\n        }\n      }\n    }\n\n    if (data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n\n    if (typeof data.startMoving === 'undefined') {\n      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n        data.startMoving = true;\n      }\n    }\n\n    if (data.isScrolling) {\n      data.isTouched = false;\n      return;\n    }\n\n    if (!data.startMoving) {\n      return;\n    }\n\n    swiper.allowClick = false;\n\n    if (!params.cssMode && e.cancelable) {\n      e.preventDefault();\n    }\n\n    if (params.touchMoveStopPropagation && !params.nested) {\n      e.stopPropagation();\n    }\n\n    if (!data.isMoved) {\n      if (params.loop && !params.cssMode) {\n        swiper.loopFix();\n      }\n\n      data.startTranslate = swiper.getTranslate();\n      swiper.setTransition(0);\n\n      if (swiper.animating) {\n        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');\n      }\n\n      data.allowMomentumBounce = false; // Grab Cursor\n\n      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n        swiper.setGrabCursor(true);\n      }\n\n      swiper.emit('sliderFirstMove', e);\n    }\n\n    swiper.emit('sliderMove', e);\n    data.isMoved = true;\n    let diff = swiper.isHorizontal() ? diffX : diffY;\n    touches.diff = diff;\n    diff *= params.touchRatio;\n    if (rtl) diff = -diff;\n    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n    data.currentTranslate = diff + data.startTranslate;\n    let disableParentSwiper = true;\n    let { resistanceRatio } = params;\n\n    if (params.touchReleaseOnEdges) {\n      resistanceRatio = 0;\n    }\n\n    if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate =\n          swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n      }\n    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate =\n          swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n      }\n    }\n\n    if (disableParentSwiper) {\n      e.preventedByNestedSwiper = true;\n    } // Directions locks\n\n    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n      data.currentTranslate = data.startTranslate;\n    }\n\n    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n      data.currentTranslate = data.startTranslate;\n    }\n\n    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n      data.currentTranslate = data.startTranslate;\n    } // Threshold\n\n    if (params.threshold > 0) {\n      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n        if (!data.allowThresholdMove) {\n          data.allowThresholdMove = true;\n          touches.startX = touches.currentX;\n          touches.startY = touches.currentY;\n          data.currentTranslate = data.startTranslate;\n          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n          return;\n        }\n      } else {\n        data.currentTranslate = data.startTranslate;\n        return;\n      }\n    }\n\n    if (!params.followFinger || params.cssMode) return; // Update active index in free mode\n\n    if ((params.freeMode && params.freeMode.enabled && swiper.freeMode) || params.watchSlidesProgress) {\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n      swiper.freeMode.onTouchMove();\n    } // Update progress\n\n    swiper.updateProgress(data.currentTranslate); // Update translate\n\n    swiper.setTranslate(data.currentTranslate);\n  }\n\n  function onTouchEnd(event) {\n    const swiper = this;\n    const data = swiper.touchEventsData;\n    const { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;\n    if (!enabled) return;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n\n    if (data.allowTouchCallbacks) {\n      swiper.emit('touchEnd', e);\n    }\n\n    data.allowTouchCallbacks = false;\n\n    if (!data.isTouched) {\n      if (data.isMoved && params.grabCursor) {\n        swiper.setGrabCursor(false);\n      }\n\n      data.isMoved = false;\n      data.startMoving = false;\n      return;\n    } // Return Grab Cursor\n\n    if (\n      params.grabCursor &&\n      data.isMoved &&\n      data.isTouched &&\n      (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)\n    ) {\n      swiper.setGrabCursor(false);\n    } // Time diff\n\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n    if (swiper.allowClick) {\n      const pathTree = e.path || (e.composedPath && e.composedPath());\n      swiper.updateClickedSlide((pathTree && pathTree[0]) || e.target);\n      swiper.emit('tap click', e);\n\n      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n        swiper.emit('doubleTap doubleClick', e);\n      }\n    }\n\n    data.lastClickTime = now();\n    nextTick(() => {\n      if (!swiper.destroyed) swiper.allowClick = true;\n    });\n\n    if (\n      !data.isTouched ||\n      !data.isMoved ||\n      !swiper.swipeDirection ||\n      touches.diff === 0 ||\n      data.currentTranslate === data.startTranslate\n    ) {\n      data.isTouched = false;\n      data.isMoved = false;\n      data.startMoving = false;\n      return;\n    }\n\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    let currentPos;\n\n    if (params.followFinger) {\n      currentPos = rtl ? swiper.translate : -swiper.translate;\n    } else {\n      currentPos = -data.currentTranslate;\n    }\n\n    if (params.cssMode) {\n      return;\n    }\n\n    if (swiper.params.freeMode && params.freeMode.enabled) {\n      swiper.freeMode.onTouchEnd({\n        currentPos,\n      });\n      return;\n    } // Find current slide\n\n    let stopIndex = 0;\n    let groupSize = swiper.slidesSizesGrid[0];\n\n    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n      const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n      if (typeof slidesGrid[i + increment] !== 'undefined') {\n        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n          stopIndex = i;\n          groupSize = slidesGrid[i + increment] - slidesGrid[i];\n        }\n      } else if (currentPos >= slidesGrid[i]) {\n        stopIndex = i;\n        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n      }\n    }\n\n    let rewindFirstIndex = null;\n    let rewindLastIndex = null;\n\n    if (params.rewind) {\n      if (swiper.isBeginning) {\n        rewindLastIndex =\n          swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual\n            ? swiper.virtual.slides.length - 1\n            : swiper.slides.length - 1;\n      } else if (swiper.isEnd) {\n        rewindFirstIndex = 0;\n      }\n    } // Find current slide size\n\n    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n    if (timeDiff > params.longSwipesMs) {\n      // Long touches\n      if (!params.longSwipes) {\n        swiper.slideTo(swiper.activeIndex);\n        return;\n      }\n\n      if (swiper.swipeDirection === 'next') {\n        if (ratio >= params.longSwipesRatio) {\n          swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);\n        } else swiper.slideTo(stopIndex);\n      }\n\n      if (swiper.swipeDirection === 'prev') {\n        if (ratio > 1 - params.longSwipesRatio) {\n          swiper.slideTo(stopIndex + increment);\n        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n          swiper.slideTo(rewindLastIndex);\n        } else {\n          swiper.slideTo(stopIndex);\n        }\n      }\n    } else {\n      // Short swipes\n      if (!params.shortSwipes) {\n        swiper.slideTo(swiper.activeIndex);\n        return;\n      }\n\n      const isNavButtonTarget =\n        swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n      if (!isNavButtonTarget) {\n        if (swiper.swipeDirection === 'next') {\n          swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n        }\n\n        if (swiper.swipeDirection === 'prev') {\n          swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n        }\n      } else if (e.target === swiper.navigation.nextEl) {\n        swiper.slideTo(stopIndex + increment);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  }\n\n  function onResize() {\n    const swiper = this;\n    const { params, el } = swiper;\n    if (el && el.offsetWidth === 0) return; // Breakpoints\n\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    } // Save locks\n\n    const { allowSlideNext, allowSlidePrev, snapGrid } = swiper; // Disable locks on resize\n\n    swiper.allowSlideNext = true;\n    swiper.allowSlidePrev = true;\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateSlidesClasses();\n\n    if (\n      (params.slidesPerView === 'auto' || params.slidesPerView > 1) &&\n      swiper.isEnd &&\n      !swiper.isBeginning &&\n      !swiper.params.centeredSlides\n    ) {\n      swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n\n    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n      swiper.autoplay.run();\n    } // Return locks after resize\n\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n\n    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n  }\n\n  function onClick(e) {\n    const swiper = this;\n    if (!swiper.enabled) return;\n\n    if (!swiper.allowClick) {\n      if (swiper.params.preventClicks) e.preventDefault();\n\n      if (swiper.params.preventClicksPropagation && swiper.animating) {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      }\n    }\n  }\n\n  function onScroll() {\n    const swiper = this;\n    const { wrapperEl, rtlTranslate, enabled } = swiper;\n    if (!enabled) return;\n    swiper.previousTranslate = swiper.translate;\n\n    if (swiper.isHorizontal()) {\n      swiper.translate = -wrapperEl.scrollLeft;\n    } else {\n      swiper.translate = -wrapperEl.scrollTop;\n    } // eslint-disable-next-line\n\n    if (swiper.translate === 0) swiper.translate = 0;\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n    let newProgress;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n\n    if (translatesDiff === 0) {\n      newProgress = 0;\n    } else {\n      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n    }\n\n    if (newProgress !== swiper.progress) {\n      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n    }\n\n    swiper.emit('setTranslate', swiper.translate, false);\n  }\n\n  let dummyEventAttached = false;\n\n  function dummyEventListener() {}\n\n  const events = (swiper, method) => {\n    const document = getDocument();\n    const { params, touchEvents, el, wrapperEl, device, support } = swiper;\n    const capture = !!params.nested;\n    const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n    const swiperMethod = method; // Touch Events\n\n    if (!support.touch) {\n      el[domMethod](touchEvents.start, swiper.onTouchStart, false);\n      document[domMethod](touchEvents.move, swiper.onTouchMove, capture);\n      document[domMethod](touchEvents.end, swiper.onTouchEnd, false);\n    } else {\n      const passiveListener =\n        touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners\n          ? {\n              passive: true,\n              capture: false,\n            }\n          : false;\n      el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);\n      el[domMethod](\n        touchEvents.move,\n        swiper.onTouchMove,\n        support.passiveListener\n          ? {\n              passive: false,\n              capture,\n            }\n          : capture\n      );\n      el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);\n\n      if (touchEvents.cancel) {\n        el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);\n      }\n    } // Prevent Links Clicks\n\n    if (params.preventClicks || params.preventClicksPropagation) {\n      el[domMethod]('click', swiper.onClick, true);\n    }\n\n    if (params.cssMode) {\n      wrapperEl[domMethod]('scroll', swiper.onScroll);\n    } // Resize handler\n\n    if (params.updateOnWindowResize) {\n      swiper[swiperMethod](\n        device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate',\n        onResize,\n        true\n      );\n    } else {\n      swiper[swiperMethod]('observerUpdate', onResize, true);\n    }\n  };\n\n  function attachEvents() {\n    const swiper = this;\n    const document = getDocument();\n    const { params, support } = swiper;\n    swiper.onTouchStart = onTouchStart.bind(swiper);\n    swiper.onTouchMove = onTouchMove.bind(swiper);\n    swiper.onTouchEnd = onTouchEnd.bind(swiper);\n\n    if (params.cssMode) {\n      swiper.onScroll = onScroll.bind(swiper);\n    }\n\n    swiper.onClick = onClick.bind(swiper);\n\n    if (support.touch && !dummyEventAttached) {\n      document.addEventListener('touchstart', dummyEventListener);\n      dummyEventAttached = true;\n    }\n\n    events(swiper, 'on');\n  }\n\n  function detachEvents() {\n    const swiper = this;\n    events(swiper, 'off');\n  }\n\n  const events$1 = {\n    attachEvents,\n    detachEvents,\n  };\n\n  const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;\n\n  function setBreakpoint() {\n    const swiper = this;\n    const { activeIndex, initialized, loopedSlides = 0, params, $el } = swiper;\n    const { breakpoints } = params;\n    if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return; // Get breakpoint for window width and update parameters\n\n    const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n    const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n    const wasMultiRow = isGridEnabled(swiper, params);\n    const isMultiRow = isGridEnabled(swiper, breakpointParams);\n    const wasEnabled = params.enabled;\n\n    if (wasMultiRow && !isMultiRow) {\n      $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);\n      swiper.emitContainerClasses();\n    } else if (!wasMultiRow && isMultiRow) {\n      $el.addClass(`${params.containerModifierClass}grid`);\n\n      if (\n        (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column') ||\n        (!breakpointParams.grid.fill && params.grid.fill === 'column')\n      ) {\n        $el.addClass(`${params.containerModifierClass}grid-column`);\n      }\n\n      swiper.emitContainerClasses();\n    } // Toggle navigation, pagination, scrollbar\n\n    ['navigation', 'pagination', 'scrollbar'].forEach((prop) => {\n      const wasModuleEnabled = params[prop] && params[prop].enabled;\n      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n\n      if (wasModuleEnabled && !isModuleEnabled) {\n        swiper[prop].disable();\n      }\n\n      if (!wasModuleEnabled && isModuleEnabled) {\n        swiper[prop].enable();\n      }\n    });\n    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n\n    if (directionChanged && initialized) {\n      swiper.changeDirection();\n    }\n\n    extend(swiper.params, breakpointParams);\n    const isEnabled = swiper.params.enabled;\n    Object.assign(swiper, {\n      allowTouchMove: swiper.params.allowTouchMove,\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n    });\n\n    if (wasEnabled && !isEnabled) {\n      swiper.disable();\n    } else if (!wasEnabled && isEnabled) {\n      swiper.enable();\n    }\n\n    swiper.currentBreakpoint = breakpoint;\n    swiper.emit('_beforeBreakpoint', breakpointParams);\n\n    if (needsReLoop && initialized) {\n      swiper.loopDestroy();\n      swiper.loopCreate();\n      swiper.updateSlides();\n      swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);\n    }\n\n    swiper.emit('breakpoint', breakpointParams);\n  }\n\n  function getBreakpoint(breakpoints, base, containerEl) {\n    if (base === void 0) {\n      base = 'window';\n    }\n\n    if (!breakpoints || (base === 'container' && !containerEl)) return undefined;\n    let breakpoint = false;\n    const window = getWindow();\n    const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n    const points = Object.keys(breakpoints).map((point) => {\n      if (typeof point === 'string' && point.indexOf('@') === 0) {\n        const minRatio = parseFloat(point.substr(1));\n        const value = currentHeight * minRatio;\n        return {\n          value,\n          point,\n        };\n      }\n\n      return {\n        value: point,\n        point,\n      };\n    });\n    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n\n    for (let i = 0; i < points.length; i += 1) {\n      const { point, value } = points[i];\n\n      if (base === 'window') {\n        if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n          breakpoint = point;\n        }\n      } else if (value <= containerEl.clientWidth) {\n        breakpoint = point;\n      }\n    }\n\n    return breakpoint || 'max';\n  }\n\n  const breakpoints = {\n    setBreakpoint,\n    getBreakpoint,\n  };\n\n  function prepareClasses(entries, prefix) {\n    const resultClasses = [];\n    entries.forEach((item) => {\n      if (typeof item === 'object') {\n        Object.keys(item).forEach((classNames) => {\n          if (item[classNames]) {\n            resultClasses.push(prefix + classNames);\n          }\n        });\n      } else if (typeof item === 'string') {\n        resultClasses.push(prefix + item);\n      }\n    });\n    return resultClasses;\n  }\n\n  function addClasses() {\n    const swiper = this;\n    const {\n      classNames,\n      params,\n      rtl,\n      $el,\n      device,\n      support,\n    } = swiper; // prettier-ignore\n\n    const suffixes = prepareClasses(\n      [\n        'initialized',\n        params.direction,\n        {\n          'pointer-events': !support.touch,\n        },\n        {\n          'free-mode': swiper.params.freeMode && params.freeMode.enabled,\n        },\n        {\n          autoheight: params.autoHeight,\n        },\n        {\n          rtl,\n        },\n        {\n          grid: params.grid && params.grid.rows > 1,\n        },\n        {\n          'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column',\n        },\n        {\n          android: device.android,\n        },\n        {\n          ios: device.ios,\n        },\n        {\n          'css-mode': params.cssMode,\n        },\n        {\n          centered: params.cssMode && params.centeredSlides,\n        },\n        {\n          'watch-progress': params.watchSlidesProgress,\n        },\n      ],\n      params.containerModifierClass\n    );\n    classNames.push(...suffixes);\n    $el.addClass([...classNames].join(' '));\n    swiper.emitContainerClasses();\n  }\n\n  function removeClasses() {\n    const swiper = this;\n    const { $el, classNames } = swiper;\n    $el.removeClass(classNames.join(' '));\n    swiper.emitContainerClasses();\n  }\n\n  const classes = {\n    addClasses,\n    removeClasses,\n  };\n\n  function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {\n    const window = getWindow();\n    let image;\n\n    function onReady() {\n      if (callback) callback();\n    }\n\n    const isPicture = $(imageEl).parent('picture')[0];\n\n    if (!isPicture && (!imageEl.complete || !checkForComplete)) {\n      if (src) {\n        image = new window.Image();\n        image.onload = onReady;\n        image.onerror = onReady;\n\n        if (sizes) {\n          image.sizes = sizes;\n        }\n\n        if (srcset) {\n          image.srcset = srcset;\n        }\n\n        if (src) {\n          image.src = src;\n        }\n      } else {\n        onReady();\n      }\n    } else {\n      // image already loaded...\n      onReady();\n    }\n  }\n\n  function preloadImages() {\n    const swiper = this;\n    swiper.imagesToLoad = swiper.$el.find('img');\n\n    function onReady() {\n      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;\n      if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;\n\n      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\n        if (swiper.params.updateOnImagesReady) swiper.update();\n        swiper.emit('imagesReady');\n      }\n    }\n\n    for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {\n      const imageEl = swiper.imagesToLoad[i];\n      swiper.loadImage(\n        imageEl,\n        imageEl.currentSrc || imageEl.getAttribute('src'),\n        imageEl.srcset || imageEl.getAttribute('srcset'),\n        imageEl.sizes || imageEl.getAttribute('sizes'),\n        true,\n        onReady\n      );\n    }\n  }\n\n  const images = {\n    loadImage,\n    preloadImages,\n  };\n\n  function checkOverflow() {\n    const swiper = this;\n    const { isLocked: wasLocked, params } = swiper;\n    const { slidesOffsetBefore } = params;\n\n    if (slidesOffsetBefore) {\n      const lastSlideIndex = swiper.slides.length - 1;\n      const lastSlideRightEdge =\n        swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n      swiper.isLocked = swiper.size > lastSlideRightEdge;\n    } else {\n      swiper.isLocked = swiper.snapGrid.length === 1;\n    }\n\n    if (params.allowSlideNext === true) {\n      swiper.allowSlideNext = !swiper.isLocked;\n    }\n\n    if (params.allowSlidePrev === true) {\n      swiper.allowSlidePrev = !swiper.isLocked;\n    }\n\n    if (wasLocked && wasLocked !== swiper.isLocked) {\n      swiper.isEnd = false;\n    }\n\n    if (wasLocked !== swiper.isLocked) {\n      swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n    }\n  }\n\n  const checkOverflow$1 = {\n    checkOverflow,\n  };\n\n  const defaults = {\n    init: true,\n    direction: 'horizontal',\n    touchEventsTarget: 'wrapper',\n    initialSlide: 0,\n    speed: 300,\n    cssMode: false,\n    updateOnWindowResize: true,\n    resizeObserver: true,\n    nested: false,\n    createElements: false,\n    enabled: true,\n    focusableElements: 'input, select, option, textarea, button, video, label',\n    // Overrides\n    width: null,\n    height: null,\n    //\n    preventInteractionOnTransition: false,\n    // ssr\n    userAgent: null,\n    url: null,\n    // To support iOS's swipe-to-go-back gesture (when being used in-app).\n    edgeSwipeDetection: false,\n    edgeSwipeThreshold: 20,\n    // Autoheight\n    autoHeight: false,\n    // Set wrapper width\n    setWrapperSize: false,\n    // Virtual Translate\n    virtualTranslate: false,\n    // Effects\n    effect: 'slide',\n    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n    // Breakpoints\n    breakpoints: undefined,\n    breakpointsBase: 'window',\n    // Slides grid\n    spaceBetween: 0,\n    slidesPerView: 1,\n    slidesPerGroup: 1,\n    slidesPerGroupSkip: 0,\n    slidesPerGroupAuto: false,\n    centeredSlides: false,\n    centeredSlidesBounds: false,\n    slidesOffsetBefore: 0,\n    // in px\n    slidesOffsetAfter: 0,\n    // in px\n    normalizeSlideIndex: true,\n    centerInsufficientSlides: false,\n    // Disable swiper and hide navigation when container not overflow\n    watchOverflow: true,\n    // Round length\n    roundLengths: false,\n    // Touches\n    touchRatio: 1,\n    touchAngle: 45,\n    simulateTouch: true,\n    shortSwipes: true,\n    longSwipes: true,\n    longSwipesRatio: 0.5,\n    longSwipesMs: 300,\n    followFinger: true,\n    allowTouchMove: true,\n    threshold: 0,\n    touchMoveStopPropagation: false,\n    touchStartPreventDefault: true,\n    touchStartForcePreventDefault: false,\n    touchReleaseOnEdges: false,\n    // Unique Navigation Elements\n    uniqueNavElements: true,\n    // Resistance\n    resistance: true,\n    resistanceRatio: 0.85,\n    // Progress\n    watchSlidesProgress: false,\n    // Cursor\n    grabCursor: false,\n    // Clicks\n    preventClicks: true,\n    preventClicksPropagation: true,\n    slideToClickedSlide: false,\n    // Images\n    preloadImages: true,\n    updateOnImagesReady: true,\n    // loop\n    loop: false,\n    loopAdditionalSlides: 0,\n    loopedSlides: null,\n    loopFillGroupWithBlank: false,\n    loopPreventsSlide: true,\n    // rewind\n    rewind: false,\n    // Swiping/no swiping\n    allowSlidePrev: true,\n    allowSlideNext: true,\n    swipeHandler: null,\n    // '.swipe-handler',\n    noSwiping: true,\n    noSwipingClass: 'swiper-no-swiping',\n    noSwipingSelector: null,\n    // Passive Listeners\n    passiveListeners: true,\n    maxBackfaceHiddenSlides: 10,\n    // NS\n    containerModifierClass: 'swiper-',\n    // NEW\n    slideClass: 'swiper-slide',\n    slideBlankClass: 'swiper-slide-invisible-blank',\n    slideActiveClass: 'swiper-slide-active',\n    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',\n    slideVisibleClass: 'swiper-slide-visible',\n    slideDuplicateClass: 'swiper-slide-duplicate',\n    slideNextClass: 'swiper-slide-next',\n    slideDuplicateNextClass: 'swiper-slide-duplicate-next',\n    slidePrevClass: 'swiper-slide-prev',\n    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',\n    wrapperClass: 'swiper-wrapper',\n    // Callbacks\n    runCallbacksOnInit: true,\n    // Internals\n    _emitClasses: false,\n  };\n\n  function moduleExtendParams(params, allModulesParams) {\n    return function extendParams(obj) {\n      if (obj === void 0) {\n        obj = {};\n      }\n\n      const moduleParamName = Object.keys(obj)[0];\n      const moduleParams = obj[moduleParamName];\n\n      if (typeof moduleParams !== 'object' || moduleParams === null) {\n        extend(allModulesParams, obj);\n        return;\n      }\n\n      if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n        params[moduleParamName] = {\n          auto: true,\n        };\n      }\n\n      if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n        extend(allModulesParams, obj);\n        return;\n      }\n\n      if (params[moduleParamName] === true) {\n        params[moduleParamName] = {\n          enabled: true,\n        };\n      }\n\n      if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n        params[moduleParamName].enabled = true;\n      }\n\n      if (!params[moduleParamName]) {\n        params[moduleParamName] = {\n          enabled: false,\n        };\n      }\n      extend(allModulesParams, obj);\n    };\n  }\n\n  /* eslint no-param-reassign: \"off\" */\n  const prototypes = {\n    eventsEmitter,\n    update,\n    translate,\n    transition,\n    slide,\n    loop,\n    grabCursor,\n    events: events$1,\n    breakpoints,\n    checkOverflow: checkOverflow$1,\n    classes,\n    images,\n  };\n  const extendedDefaults = {};\n\n  class Swiper {\n    constructor() {\n      let el;\n      let params;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (\n        args.length === 1 &&\n        args[0].constructor &&\n        Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object'\n      ) {\n        params = args[0];\n      } else {\n        [el, params] = args;\n      }\n\n      if (!params) params = {};\n      params = extend({}, params);\n      if (el && !params.el) params.el = el;\n\n      if (params.el && $(params.el).length > 1) {\n        const swipers = [];\n        $(params.el).each((containerEl) => {\n          const newParams = extend({}, params, {\n            el: containerEl,\n          });\n          swipers.push(new Swiper(newParams));\n        });\n        return swipers;\n      } // Swiper Instance\n\n      const swiper = this;\n      swiper.__swiper__ = true;\n      swiper.support = getSupport();\n      swiper.device = getDevice({\n        userAgent: params.userAgent,\n      });\n      swiper.browser = getBrowser();\n      swiper.eventsListeners = {};\n      swiper.eventsAnyListeners = [];\n      swiper.modules = [...swiper.__modules__];\n\n      if (params.modules && Array.isArray(params.modules)) {\n        swiper.modules.push(...params.modules);\n      }\n\n      const allModulesParams = {};\n      swiper.modules.forEach((mod) => {\n        mod({\n          swiper,\n          extendParams: moduleExtendParams(params, allModulesParams),\n          on: swiper.on.bind(swiper),\n          once: swiper.once.bind(swiper),\n          off: swiper.off.bind(swiper),\n          emit: swiper.emit.bind(swiper),\n        });\n      }); // Extend defaults with modules params\n\n      const swiperParams = extend({}, defaults, allModulesParams); // Extend defaults with passed params\n\n      swiper.params = extend({}, swiperParams, extendedDefaults, params);\n      swiper.originalParams = extend({}, swiper.params);\n      swiper.passedParams = extend({}, params); // add event listeners\n\n      if (swiper.params && swiper.params.on) {\n        Object.keys(swiper.params.on).forEach((eventName) => {\n          swiper.on(eventName, swiper.params.on[eventName]);\n        });\n      }\n\n      if (swiper.params && swiper.params.onAny) {\n        swiper.onAny(swiper.params.onAny);\n      } // Save Dom lib\n\n      swiper.$ = $; // Extend Swiper\n\n      Object.assign(swiper, {\n        enabled: swiper.params.enabled,\n        el,\n        // Classes\n        classNames: [],\n        // Slides\n        slides: $(),\n        slidesGrid: [],\n        snapGrid: [],\n        slidesSizesGrid: [],\n\n        // isDirection\n        isHorizontal() {\n          return swiper.params.direction === 'horizontal';\n        },\n\n        isVertical() {\n          return swiper.params.direction === 'vertical';\n        },\n\n        // Indexes\n        activeIndex: 0,\n        realIndex: 0,\n        //\n        isBeginning: true,\n        isEnd: false,\n        // Props\n        translate: 0,\n        previousTranslate: 0,\n        progress: 0,\n        velocity: 0,\n        animating: false,\n        // Locks\n        allowSlideNext: swiper.params.allowSlideNext,\n        allowSlidePrev: swiper.params.allowSlidePrev,\n        // Touch Events\n        touchEvents: (function touchEvents() {\n          const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n          const desktop = ['pointerdown', 'pointermove', 'pointerup'];\n          swiper.touchEventsTouch = {\n            start: touch[0],\n            move: touch[1],\n            end: touch[2],\n            cancel: touch[3],\n          };\n          swiper.touchEventsDesktop = {\n            start: desktop[0],\n            move: desktop[1],\n            end: desktop[2],\n          };\n          return swiper.support.touch || !swiper.params.simulateTouch\n            ? swiper.touchEventsTouch\n            : swiper.touchEventsDesktop;\n        })(),\n        touchEventsData: {\n          isTouched: undefined,\n          isMoved: undefined,\n          allowTouchCallbacks: undefined,\n          touchStartTime: undefined,\n          isScrolling: undefined,\n          currentTranslate: undefined,\n          startTranslate: undefined,\n          allowThresholdMove: undefined,\n          // Form elements to match\n          focusableElements: swiper.params.focusableElements,\n          // Last click time\n          lastClickTime: now(),\n          clickTimeout: undefined,\n          // Velocities\n          velocities: [],\n          allowMomentumBounce: undefined,\n          isTouchEvent: undefined,\n          startMoving: undefined,\n        },\n        // Clicks\n        allowClick: true,\n        // Touches\n        allowTouchMove: swiper.params.allowTouchMove,\n        touches: {\n          startX: 0,\n          startY: 0,\n          currentX: 0,\n          currentY: 0,\n          diff: 0,\n        },\n        // Images\n        imagesToLoad: [],\n        imagesLoaded: 0,\n      });\n      swiper.emit('_swiper'); // Init\n\n      if (swiper.params.init) {\n        swiper.init();\n      } // Return app instance\n\n      return swiper;\n    }\n\n    enable() {\n      const swiper = this;\n      if (swiper.enabled) return;\n      swiper.enabled = true;\n\n      if (swiper.params.grabCursor) {\n        swiper.setGrabCursor();\n      }\n\n      swiper.emit('enable');\n    }\n\n    disable() {\n      const swiper = this;\n      if (!swiper.enabled) return;\n      swiper.enabled = false;\n\n      if (swiper.params.grabCursor) {\n        swiper.unsetGrabCursor();\n      }\n\n      swiper.emit('disable');\n    }\n\n    setProgress(progress, speed) {\n      const swiper = this;\n      progress = Math.min(Math.max(progress, 0), 1);\n      const min = swiper.minTranslate();\n      const max = swiper.maxTranslate();\n      const current = (max - min) * progress + min;\n      swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    emitContainerClasses() {\n      const swiper = this;\n      if (!swiper.params._emitClasses || !swiper.el) return;\n      const cls = swiper.el.className\n        .split(' ')\n        .filter(\n          (className) =>\n            className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0\n        );\n      swiper.emit('_containerClasses', cls.join(' '));\n    }\n\n    getSlideClasses(slideEl) {\n      const swiper = this;\n      if (swiper.destroyed) return '';\n      return slideEl.className\n        .split(' ')\n        .filter(\n          (className) => className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0\n        )\n        .join(' ');\n    }\n\n    emitSlidesClasses() {\n      const swiper = this;\n      if (!swiper.params._emitClasses || !swiper.el) return;\n      const updates = [];\n      swiper.slides.each((slideEl) => {\n        const classNames = swiper.getSlideClasses(slideEl);\n        updates.push({\n          slideEl,\n          classNames,\n        });\n        swiper.emit('_slideClass', slideEl, classNames);\n      });\n      swiper.emit('_slideClasses', updates);\n    }\n\n    slidesPerViewDynamic(view, exact) {\n      if (view === void 0) {\n        view = 'current';\n      }\n\n      if (exact === void 0) {\n        exact = false;\n      }\n\n      const swiper = this;\n      const { params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex } = swiper;\n      let spv = 1;\n\n      if (params.centeredSlides) {\n        let slideSize = slides[activeIndex].swiperSlideSize;\n        let breakLoop;\n\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          if (slides[i] && !breakLoop) {\n            slideSize += slides[i].swiperSlideSize;\n            spv += 1;\n            if (slideSize > swiperSize) breakLoop = true;\n          }\n        }\n\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          if (slides[i] && !breakLoop) {\n            slideSize += slides[i].swiperSlideSize;\n            spv += 1;\n            if (slideSize > swiperSize) breakLoop = true;\n          }\n        }\n      } else {\n        // eslint-disable-next-line\n        if (view === 'current') {\n          for (let i = activeIndex + 1; i < slides.length; i += 1) {\n            const slideInView = exact\n              ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize\n              : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n\n            if (slideInView) {\n              spv += 1;\n            }\n          }\n        } else {\n          // previous\n          for (let i = activeIndex - 1; i >= 0; i -= 1) {\n            const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n\n            if (slideInView) {\n              spv += 1;\n            }\n          }\n        }\n      }\n\n      return spv;\n    }\n\n    update() {\n      const swiper = this;\n      if (!swiper || swiper.destroyed) return;\n      const { snapGrid, params } = swiper; // Breakpoints\n\n      if (params.breakpoints) {\n        swiper.setBreakpoint();\n      }\n\n      swiper.updateSize();\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n\n      function setTranslate() {\n        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n        swiper.setTranslate(newTranslate);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n\n      let translated;\n\n      if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\n        setTranslate();\n\n        if (swiper.params.autoHeight) {\n          swiper.updateAutoHeight();\n        }\n      } else {\n        if (\n          (swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) &&\n          swiper.isEnd &&\n          !swiper.params.centeredSlides\n        ) {\n          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n        } else {\n          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n        }\n\n        if (!translated) {\n          setTranslate();\n        }\n      }\n\n      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n        swiper.checkOverflow();\n      }\n\n      swiper.emit('update');\n    }\n\n    changeDirection(newDirection, needUpdate) {\n      if (needUpdate === void 0) {\n        needUpdate = true;\n      }\n\n      const swiper = this;\n      const currentDirection = swiper.params.direction;\n\n      if (!newDirection) {\n        // eslint-disable-next-line\n        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n      }\n\n      if (newDirection === currentDirection || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {\n        return swiper;\n      }\n\n      swiper.$el\n        .removeClass(`${swiper.params.containerModifierClass}${currentDirection}`)\n        .addClass(`${swiper.params.containerModifierClass}${newDirection}`);\n      swiper.emitContainerClasses();\n      swiper.params.direction = newDirection;\n      swiper.slides.each((slideEl) => {\n        if (newDirection === 'vertical') {\n          slideEl.style.width = '';\n        } else {\n          slideEl.style.height = '';\n        }\n      });\n      swiper.emit('changeDirection');\n      if (needUpdate) swiper.update();\n      return swiper;\n    }\n\n    changeLanguageDirection(direction) {\n      const swiper = this;\n      if ((swiper.rtl && direction === 'rtl') || (!swiper.rtl && direction === 'ltr')) return;\n      swiper.rtl = direction === 'rtl';\n      swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n\n      if (swiper.rtl) {\n        swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);\n        swiper.el.dir = 'rtl';\n      } else {\n        swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);\n        swiper.el.dir = 'ltr';\n      }\n\n      swiper.update();\n    }\n\n    mount(el) {\n      const swiper = this;\n      if (swiper.mounted) return true; // Find el\n\n      const $el = $(el || swiper.params.el);\n      el = $el[0];\n\n      if (!el) {\n        return false;\n      }\n\n      el.swiper = swiper;\n\n      const getWrapperSelector = () => `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n\n      const getWrapper = () => {\n        if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n          const res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items\n\n          res.children = (options) => $el.children(options);\n\n          return res;\n        }\n\n        if (!$el.children) {\n          return $($el).children(getWrapperSelector());\n        }\n\n        return $el.children(getWrapperSelector());\n      }; // Find Wrapper\n\n      let $wrapperEl = getWrapper();\n\n      if ($wrapperEl.length === 0 && swiper.params.createElements) {\n        const document = getDocument();\n        const wrapper = document.createElement('div');\n        $wrapperEl = $(wrapper);\n        wrapper.className = swiper.params.wrapperClass;\n        $el.append(wrapper);\n        $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {\n          $wrapperEl.append(slideEl);\n        });\n      }\n\n      Object.assign(swiper, {\n        $el,\n        el,\n        $wrapperEl,\n        wrapperEl: $wrapperEl[0],\n        mounted: true,\n        // RTL\n        rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',\n        rtlTranslate:\n          swiper.params.direction === 'horizontal' &&\n          (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\n        wrongRTL: $wrapperEl.css('display') === '-webkit-box',\n      });\n      return true;\n    }\n\n    init(el) {\n      const swiper = this;\n      if (swiper.initialized) return swiper;\n      const mounted = swiper.mount(el);\n      if (mounted === false) return swiper;\n      swiper.emit('beforeInit'); // Set breakpoint\n\n      if (swiper.params.breakpoints) {\n        swiper.setBreakpoint();\n      } // Add Classes\n\n      swiper.addClasses(); // Create loop\n\n      if (swiper.params.loop) {\n        swiper.loopCreate();\n      } // Update size\n\n      swiper.updateSize(); // Update slides\n\n      swiper.updateSlides();\n\n      if (swiper.params.watchOverflow) {\n        swiper.checkOverflow();\n      } // Set Grab Cursor\n\n      if (swiper.params.grabCursor && swiper.enabled) {\n        swiper.setGrabCursor();\n      }\n\n      if (swiper.params.preloadImages) {\n        swiper.preloadImages();\n      } // Slide To Initial Slide\n\n      if (swiper.params.loop) {\n        swiper.slideTo(\n          swiper.params.initialSlide + swiper.loopedSlides,\n          0,\n          swiper.params.runCallbacksOnInit,\n          false,\n          true\n        );\n      } else {\n        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n      } // Attach events\n\n      swiper.attachEvents(); // Init Flag\n\n      swiper.initialized = true; // Emit\n\n      swiper.emit('init');\n      swiper.emit('afterInit');\n      return swiper;\n    }\n\n    destroy(deleteInstance, cleanStyles) {\n      if (deleteInstance === void 0) {\n        deleteInstance = true;\n      }\n\n      if (cleanStyles === void 0) {\n        cleanStyles = true;\n      }\n\n      const swiper = this;\n      const { params, $el, $wrapperEl, slides } = swiper;\n\n      if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n        return null;\n      }\n\n      swiper.emit('beforeDestroy'); // Init Flag\n\n      swiper.initialized = false; // Detach events\n\n      swiper.detachEvents(); // Destroy loop\n\n      if (params.loop) {\n        swiper.loopDestroy();\n      } // Cleanup styles\n\n      if (cleanStyles) {\n        swiper.removeClasses();\n        $el.removeAttr('style');\n        $wrapperEl.removeAttr('style');\n\n        if (slides && slides.length) {\n          slides\n            .removeClass(\n              [params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(\n                ' '\n              )\n            )\n            .removeAttr('style')\n            .removeAttr('data-swiper-slide-index');\n        }\n      }\n\n      swiper.emit('destroy'); // Detach emitter events\n\n      Object.keys(swiper.eventsListeners).forEach((eventName) => {\n        swiper.off(eventName);\n      });\n\n      if (deleteInstance !== false) {\n        swiper.$el[0].swiper = null;\n        deleteProps(swiper);\n      }\n\n      swiper.destroyed = true;\n      return null;\n    }\n\n    static extendDefaults(newDefaults) {\n      extend(extendedDefaults, newDefaults);\n    }\n\n    static get extendedDefaults() {\n      return extendedDefaults;\n    }\n\n    static get defaults() {\n      return defaults;\n    }\n\n    static installModule(mod) {\n      if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n      const modules = Swiper.prototype.__modules__;\n\n      if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n        modules.push(mod);\n      }\n    }\n\n    static use(module) {\n      if (Array.isArray(module)) {\n        module.forEach((m) => Swiper.installModule(m));\n        return Swiper;\n      }\n\n      Swiper.installModule(module);\n      return Swiper;\n    }\n  }\n\n  Object.keys(prototypes).forEach((prototypeGroup) => {\n    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {\n      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n    });\n  });\n  Swiper.use([Resize, Observer]);\n\n  function Virtual(_ref) {\n    const { swiper, extendParams, on, emit } = _ref;\n    extendParams({\n      virtual: {\n        enabled: false,\n        slides: [],\n        cache: true,\n        renderSlide: null,\n        renderExternal: null,\n        renderExternalUpdate: true,\n        addSlidesBefore: 0,\n        addSlidesAfter: 0,\n      },\n    });\n    let cssModeTimeout;\n    swiper.virtual = {\n      cache: {},\n      from: undefined,\n      to: undefined,\n      slides: [],\n      offset: 0,\n      slidesGrid: [],\n    };\n\n    function renderSlide(slide, index) {\n      const params = swiper.params.virtual;\n\n      if (params.cache && swiper.virtual.cache[index]) {\n        return swiper.virtual.cache[index];\n      }\n\n      const $slideEl = params.renderSlide\n        ? $(params.renderSlide.call(swiper, slide, index))\n        : $(`<div class=\"${swiper.params.slideClass}\" data-swiper-slide-index=\"${index}\">${slide}</div>`);\n      if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);\n      if (params.cache) swiper.virtual.cache[index] = $slideEl;\n      return $slideEl;\n    }\n\n    function update(force) {\n      const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;\n      const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;\n      const {\n        from: previousFrom,\n        to: previousTo,\n        slides,\n        slidesGrid: previousSlidesGrid,\n        offset: previousOffset,\n      } = swiper.virtual;\n\n      if (!swiper.params.cssMode) {\n        swiper.updateActiveIndex();\n      }\n\n      const activeIndex = swiper.activeIndex || 0;\n      let offsetProp;\n      if (swiper.rtlTranslate) offsetProp = 'right';\n      else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n      let slidesAfter;\n      let slidesBefore;\n\n      if (centeredSlides) {\n        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n      } else {\n        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n        slidesBefore = slidesPerGroup + addSlidesBefore;\n      }\n\n      const from = Math.max((activeIndex || 0) - slidesBefore, 0);\n      const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);\n      const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n      Object.assign(swiper.virtual, {\n        from,\n        to,\n        offset,\n        slidesGrid: swiper.slidesGrid,\n      });\n\n      function onRendered() {\n        swiper.updateSlides();\n        swiper.updateProgress();\n        swiper.updateSlidesClasses();\n\n        if (swiper.lazy && swiper.params.lazy.enabled) {\n          swiper.lazy.load();\n        }\n\n        emit('virtualUpdate');\n      }\n\n      if (previousFrom === from && previousTo === to && !force) {\n        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n          swiper.slides.css(offsetProp, `${offset}px`);\n        }\n\n        swiper.updateProgress();\n        emit('virtualUpdate');\n        return;\n      }\n\n      if (swiper.params.virtual.renderExternal) {\n        swiper.params.virtual.renderExternal.call(swiper, {\n          offset,\n          from,\n          to,\n          slides: (function getSlides() {\n            const slidesToRender = [];\n\n            for (let i = from; i <= to; i += 1) {\n              slidesToRender.push(slides[i]);\n            }\n\n            return slidesToRender;\n          })(),\n        });\n\n        if (swiper.params.virtual.renderExternalUpdate) {\n          onRendered();\n        } else {\n          emit('virtualUpdate');\n        }\n\n        return;\n      }\n\n      const prependIndexes = [];\n      const appendIndexes = [];\n\n      if (force) {\n        swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();\n      } else {\n        for (let i = previousFrom; i <= previousTo; i += 1) {\n          if (i < from || i > to) {\n            swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${i}\"]`).remove();\n          }\n        }\n      }\n\n      for (let i = 0; i < slides.length; i += 1) {\n        if (i >= from && i <= to) {\n          if (typeof previousTo === 'undefined' || force) {\n            appendIndexes.push(i);\n          } else {\n            if (i > previousTo) appendIndexes.push(i);\n            if (i < previousFrom) prependIndexes.push(i);\n          }\n        }\n      }\n\n      appendIndexes.forEach((index) => {\n        swiper.$wrapperEl.append(renderSlide(slides[index], index));\n      });\n      prependIndexes\n        .sort((a, b) => b - a)\n        .forEach((index) => {\n          swiper.$wrapperEl.prepend(renderSlide(slides[index], index));\n        });\n      swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);\n      onRendered();\n    }\n\n    function appendSlide(slides) {\n      if (typeof slides === 'object' && 'length' in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) swiper.virtual.slides.push(slides[i]);\n        }\n      } else {\n        swiper.virtual.slides.push(slides);\n      }\n\n      update(true);\n    }\n\n    function prependSlide(slides) {\n      const { activeIndex } = swiper;\n      let newActiveIndex = activeIndex + 1;\n      let numberOfNewSlides = 1;\n\n      if (Array.isArray(slides)) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n        }\n\n        newActiveIndex = activeIndex + slides.length;\n        numberOfNewSlides = slides.length;\n      } else {\n        swiper.virtual.slides.unshift(slides);\n      }\n\n      if (swiper.params.virtual.cache) {\n        const { cache } = swiper.virtual;\n        const newCache = {};\n        Object.keys(cache).forEach((cachedIndex) => {\n          const $cachedEl = cache[cachedIndex];\n          const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');\n\n          if (cachedElIndex) {\n            $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n          }\n\n          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;\n        });\n        swiper.virtual.cache = newCache;\n      }\n\n      update(true);\n      swiper.slideTo(newActiveIndex, 0);\n    }\n\n    function removeSlide(slidesIndexes) {\n      if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n      let { activeIndex } = swiper;\n\n      if (Array.isArray(slidesIndexes)) {\n        for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n          swiper.virtual.slides.splice(slidesIndexes[i], 1);\n\n          if (swiper.params.virtual.cache) {\n            delete swiper.virtual.cache[slidesIndexes[i]];\n          }\n\n          if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n          activeIndex = Math.max(activeIndex, 0);\n        }\n      } else {\n        swiper.virtual.slides.splice(slidesIndexes, 1);\n\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes];\n        }\n\n        if (slidesIndexes < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n\n      update(true);\n      swiper.slideTo(activeIndex, 0);\n    }\n\n    function removeAllSlides() {\n      swiper.virtual.slides = [];\n\n      if (swiper.params.virtual.cache) {\n        swiper.virtual.cache = {};\n      }\n\n      update(true);\n      swiper.slideTo(0, 0);\n    }\n\n    on('beforeInit', () => {\n      if (!swiper.params.virtual.enabled) return;\n      swiper.virtual.slides = swiper.params.virtual.slides;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n\n      if (!swiper.params.initialSlide) {\n        update();\n      }\n    });\n    on('setTranslate', () => {\n      if (!swiper.params.virtual.enabled) return;\n\n      if (swiper.params.cssMode && !swiper._immediateVirtual) {\n        clearTimeout(cssModeTimeout);\n        cssModeTimeout = setTimeout(() => {\n          update();\n        }, 100);\n      } else {\n        update();\n      }\n    });\n    on('init update resize', () => {\n      if (!swiper.params.virtual.enabled) return;\n\n      if (swiper.params.cssMode) {\n        setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n      }\n    });\n    Object.assign(swiper.virtual, {\n      appendSlide,\n      prependSlide,\n      removeSlide,\n      removeAllSlides,\n      update,\n    });\n  }\n\n  /* eslint-disable consistent-return */\n  function Keyboard(_ref) {\n    const { swiper, extendParams, on, emit } = _ref;\n    const document = getDocument();\n    const window = getWindow();\n    swiper.keyboard = {\n      enabled: false,\n    };\n    extendParams({\n      keyboard: {\n        enabled: false,\n        onlyInViewport: true,\n        pageUpDown: true,\n      },\n    });\n\n    function handle(event) {\n      if (!swiper.enabled) return;\n      const { rtlTranslate: rtl } = swiper;\n      let e = event;\n      if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n      const kc = e.keyCode || e.charCode;\n      const { pageUpDown } = swiper.params.keyboard;\n      const isPageUp = pageUpDown && kc === 33;\n      const isPageDown = pageUpDown && kc === 34;\n      const isArrowLeft = kc === 37;\n      const isArrowRight = kc === 39;\n      const isArrowUp = kc === 38;\n      const isArrowDown = kc === 40; // Directions locks\n\n      if (\n        !swiper.allowSlideNext &&\n        ((swiper.isHorizontal() && isArrowRight) || (swiper.isVertical() && isArrowDown) || isPageDown)\n      ) {\n        return false;\n      }\n\n      if (\n        !swiper.allowSlidePrev &&\n        ((swiper.isHorizontal() && isArrowLeft) || (swiper.isVertical() && isArrowUp) || isPageUp)\n      ) {\n        return false;\n      }\n\n      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n        return undefined;\n      }\n\n      if (\n        document.activeElement &&\n        document.activeElement.nodeName &&\n        (document.activeElement.nodeName.toLowerCase() === 'input' ||\n          document.activeElement.nodeName.toLowerCase() === 'textarea')\n      ) {\n        return undefined;\n      }\n\n      if (\n        swiper.params.keyboard.onlyInViewport &&\n        (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)\n      ) {\n        let inView = false; // Check that swiper should be inside of visible area of window\n\n        if (\n          swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 &&\n          swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0\n        ) {\n          return undefined;\n        }\n\n        const { $el } = swiper;\n        const swiperWidth = $el[0].clientWidth;\n        const swiperHeight = $el[0].clientHeight;\n        const windowWidth = window.innerWidth;\n        const windowHeight = window.innerHeight;\n        const swiperOffset = swiper.$el.offset();\n        if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;\n        const swiperCoord = [\n          [swiperOffset.left, swiperOffset.top],\n          [swiperOffset.left + swiperWidth, swiperOffset.top],\n          [swiperOffset.left, swiperOffset.top + swiperHeight],\n          [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight],\n        ];\n\n        for (let i = 0; i < swiperCoord.length; i += 1) {\n          const point = swiperCoord[i];\n\n          if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n            if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n\n            inView = true;\n          }\n        }\n\n        if (!inView) return undefined;\n      }\n\n      if (swiper.isHorizontal()) {\n        if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n          if (e.preventDefault) e.preventDefault();\n          else e.returnValue = false;\n        }\n\n        if (((isPageDown || isArrowRight) && !rtl) || ((isPageUp || isArrowLeft) && rtl)) swiper.slideNext();\n        if (((isPageUp || isArrowLeft) && !rtl) || ((isPageDown || isArrowRight) && rtl)) swiper.slidePrev();\n      } else {\n        if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n          if (e.preventDefault) e.preventDefault();\n          else e.returnValue = false;\n        }\n\n        if (isPageDown || isArrowDown) swiper.slideNext();\n        if (isPageUp || isArrowUp) swiper.slidePrev();\n      }\n\n      emit('keyPress', kc);\n      return undefined;\n    }\n\n    function enable() {\n      if (swiper.keyboard.enabled) return;\n      $(document).on('keydown', handle);\n      swiper.keyboard.enabled = true;\n    }\n\n    function disable() {\n      if (!swiper.keyboard.enabled) return;\n      $(document).off('keydown', handle);\n      swiper.keyboard.enabled = false;\n    }\n\n    on('init', () => {\n      if (swiper.params.keyboard.enabled) {\n        enable();\n      }\n    });\n    on('destroy', () => {\n      if (swiper.keyboard.enabled) {\n        disable();\n      }\n    });\n    Object.assign(swiper.keyboard, {\n      enable,\n      disable,\n    });\n  }\n\n  /* eslint-disable consistent-return */\n  function Mousewheel(_ref) {\n    const { swiper, extendParams, on, emit } = _ref;\n    const window = getWindow();\n    extendParams({\n      mousewheel: {\n        enabled: false,\n        releaseOnEdges: false,\n        invert: false,\n        forceToAxis: false,\n        sensitivity: 1,\n        eventsTarget: 'container',\n        thresholdDelta: null,\n        thresholdTime: null,\n      },\n    });\n    swiper.mousewheel = {\n      enabled: false,\n    };\n    let timeout;\n    let lastScrollTime = now();\n    let lastEventBeforeSnap;\n    const recentWheelEvents = [];\n\n    function normalize(e) {\n      // Reasonable defaults\n      const PIXEL_STEP = 10;\n      const LINE_HEIGHT = 40;\n      const PAGE_HEIGHT = 800;\n      let sX = 0;\n      let sY = 0; // spinX, spinY\n\n      let pX = 0;\n      let pY = 0; // pixelX, pixelY\n      // Legacy\n\n      if ('detail' in e) {\n        sY = e.detail;\n      }\n\n      if ('wheelDelta' in e) {\n        sY = -e.wheelDelta / 120;\n      }\n\n      if ('wheelDeltaY' in e) {\n        sY = -e.wheelDeltaY / 120;\n      }\n\n      if ('wheelDeltaX' in e) {\n        sX = -e.wheelDeltaX / 120;\n      } // side scrolling on FF with DOMMouseScroll\n\n      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n        sX = sY;\n        sY = 0;\n      }\n\n      pX = sX * PIXEL_STEP;\n      pY = sY * PIXEL_STEP;\n\n      if ('deltaY' in e) {\n        pY = e.deltaY;\n      }\n\n      if ('deltaX' in e) {\n        pX = e.deltaX;\n      }\n\n      if (e.shiftKey && !pX) {\n        // if user scrolls with shift he wants horizontal scroll\n        pX = pY;\n        pY = 0;\n      }\n\n      if ((pX || pY) && e.deltaMode) {\n        if (e.deltaMode === 1) {\n          // delta in LINE units\n          pX *= LINE_HEIGHT;\n          pY *= LINE_HEIGHT;\n        } else {\n          // delta in PAGE units\n          pX *= PAGE_HEIGHT;\n          pY *= PAGE_HEIGHT;\n        }\n      } // Fall-back if spin cannot be determined\n\n      if (pX && !sX) {\n        sX = pX < 1 ? -1 : 1;\n      }\n\n      if (pY && !sY) {\n        sY = pY < 1 ? -1 : 1;\n      }\n\n      return {\n        spinX: sX,\n        spinY: sY,\n        pixelX: pX,\n        pixelY: pY,\n      };\n    }\n\n    function handleMouseEnter() {\n      if (!swiper.enabled) return;\n      swiper.mouseEntered = true;\n    }\n\n    function handleMouseLeave() {\n      if (!swiper.enabled) return;\n      swiper.mouseEntered = false;\n    }\n\n    function animateSlider(newEvent) {\n      if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n        // Prevent if delta of wheel scroll delta is below configured threshold\n        return false;\n      }\n\n      if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n        // Prevent if time between scrolls is below configured threshold\n        return false;\n      } // If the movement is NOT big enough and\n      // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n      //   Don't go any further (avoid insignificant scroll movement).\n\n      if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n        // Return false as a default\n        return true;\n      } // If user is scrolling towards the end:\n      //   If the slider hasn't hit the latest slide or\n      //   if the slider is a loop and\n      //   if the slider isn't moving right now:\n      //     Go to next slide and\n      //     emit a scroll event.\n      // Else (the user is scrolling towards the beginning) and\n      // if the slider hasn't hit the first slide or\n      // if the slider is a loop and\n      // if the slider isn't moving right now:\n      //   Go to prev slide and\n      //   emit a scroll event.\n\n      if (newEvent.direction < 0) {\n        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n          swiper.slideNext();\n          emit('scroll', newEvent.raw);\n        }\n      } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n        swiper.slidePrev();\n        emit('scroll', newEvent.raw);\n      } // If you got here is because an animation has been triggered so store the current time\n\n      lastScrollTime = new window.Date().getTime(); // Return false as a default\n\n      return false;\n    }\n\n    function releaseScroll(newEvent) {\n      const params = swiper.params.mousewheel;\n\n      if (newEvent.direction < 0) {\n        if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n          // Return true to animate scroll on edges\n          return true;\n        }\n      } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n\n      return false;\n    }\n\n    function handle(event) {\n      let e = event;\n      let disableParentSwiper = true;\n      if (!swiper.enabled) return;\n      const params = swiper.params.mousewheel;\n\n      if (swiper.params.cssMode) {\n        e.preventDefault();\n      }\n\n      let target = swiper.$el;\n\n      if (swiper.params.mousewheel.eventsTarget !== 'container') {\n        target = $(swiper.params.mousewheel.eventsTarget);\n      }\n\n      if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\n      if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n      let delta = 0;\n      const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n      const data = normalize(e);\n\n      if (params.forceToAxis) {\n        if (swiper.isHorizontal()) {\n          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;\n          else return true;\n        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;\n        else return true;\n      } else {\n        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n      }\n\n      if (delta === 0) return true;\n      if (params.invert) delta = -delta; // Get the scroll positions\n\n      let positions = swiper.getTranslate() + delta * params.sensitivity;\n      if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n      if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:\n      //     the disableParentSwiper will be true.\n      // When loop is false:\n      //     if the scroll positions is not on edge,\n      //     then the disableParentSwiper will be true.\n      //     if the scroll on edge positions,\n      //     then the disableParentSwiper will be false.\n\n      disableParentSwiper = swiper.params.loop\n        ? true\n        : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n      if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\n      if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n        // Register the new event in a variable which stores the relevant data\n        const newEvent = {\n          time: now(),\n          delta: Math.abs(delta),\n          direction: Math.sign(delta),\n          raw: event,\n        }; // Keep the most recent events\n\n        if (recentWheelEvents.length >= 2) {\n          recentWheelEvents.shift(); // only store the last N events\n        }\n\n        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n        recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\n        //   If direction has changed or\n        //   if the scroll is quicker than the previous one:\n        //     Animate the slider.\n        // Else (this is the first time the wheel is moved):\n        //     Animate the slider.\n\n        if (prevEvent) {\n          if (\n            newEvent.direction !== prevEvent.direction ||\n            newEvent.delta > prevEvent.delta ||\n            newEvent.time > prevEvent.time + 150\n          ) {\n            animateSlider(newEvent);\n          }\n        } else {\n          animateSlider(newEvent);\n        } // If it's time to release the scroll:\n        //   Return now so you don't hit the preventDefault.\n\n        if (releaseScroll(newEvent)) {\n          return true;\n        }\n      } else {\n        // Freemode or scrollContainer:\n        // If we recently snapped after a momentum scroll, then ignore wheel events\n        // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n        // or if it's a new scroll (larger delta or inverse sign as last event before\n        // an end-of-momentum snap).\n        const newEvent = {\n          time: now(),\n          delta: Math.abs(delta),\n          direction: Math.sign(delta),\n        };\n        const ignoreWheelEvents =\n          lastEventBeforeSnap &&\n          newEvent.time < lastEventBeforeSnap.time + 500 &&\n          newEvent.delta <= lastEventBeforeSnap.delta &&\n          newEvent.direction === lastEventBeforeSnap.direction;\n\n        if (!ignoreWheelEvents) {\n          lastEventBeforeSnap = undefined;\n\n          if (swiper.params.loop) {\n            swiper.loopFix();\n          }\n\n          let position = swiper.getTranslate() + delta * params.sensitivity;\n          const wasBeginning = swiper.isBeginning;\n          const wasEnd = swiper.isEnd;\n          if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n          if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n          swiper.setTransition(0);\n          swiper.setTranslate(position);\n          swiper.updateProgress();\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n\n          if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {\n            swiper.updateSlidesClasses();\n          }\n\n          if (swiper.params.freeMode.sticky) {\n            // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n            // the end of a momentum scroll by storing recent (N=15?) wheel events.\n            // 1. do all N events have decreasing or same (absolute value) delta?\n            // 2. did all N events arrive in the last M (M=500?) msecs?\n            // 3. does the earliest event have an (absolute value) delta that's\n            //    at least P (P=1?) larger than the most recent event's delta?\n            // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n            // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n            // Snap immediately and ignore remaining wheel events in this scroll.\n            // See comment above for \"remaining wheel events in this scroll\" determination.\n            // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n            clearTimeout(timeout);\n            timeout = undefined;\n\n            if (recentWheelEvents.length >= 15) {\n              recentWheelEvents.shift(); // only store the last N events\n            }\n\n            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n            const firstEvent = recentWheelEvents[0];\n            recentWheelEvents.push(newEvent);\n\n            if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n              // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n              recentWheelEvents.splice(0);\n            } else if (\n              recentWheelEvents.length >= 15 &&\n              newEvent.time - firstEvent.time < 500 &&\n              firstEvent.delta - newEvent.delta >= 1 &&\n              newEvent.delta <= 6\n            ) {\n              // We're at the end of the deceleration of a momentum scroll, so there's no need\n              // to wait for more events. Snap ASAP on the next tick.\n              // Also, because there's some remaining momentum we'll bias the snap in the\n              // direction of the ongoing scroll because it's better UX for the scroll to snap\n              // in the same direction as the scroll instead of reversing to snap.  Therefore,\n              // if it's already scrolled more than 20% in the current direction, keep going.\n              const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              timeout = nextTick(() => {\n                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n              }, 0); // no delay; move on next tick\n            }\n\n            if (!timeout) {\n              // if we get here, then we haven't detected the end of a momentum scroll, so\n              // we'll consider a scroll \"complete\" when there haven't been any wheel events\n              // for 500ms.\n              timeout = nextTick(() => {\n                const snapToThreshold = 0.5;\n                lastEventBeforeSnap = newEvent;\n                recentWheelEvents.splice(0);\n                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n              }, 500);\n            }\n          } // Emit event\n\n          if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay\n\n          if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\n\n          if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n        }\n      }\n\n      if (e.preventDefault) e.preventDefault();\n      else e.returnValue = false;\n      return false;\n    }\n\n    function events(method) {\n      let target = swiper.$el;\n\n      if (swiper.params.mousewheel.eventsTarget !== 'container') {\n        target = $(swiper.params.mousewheel.eventsTarget);\n      }\n\n      target[method]('mouseenter', handleMouseEnter);\n      target[method]('mouseleave', handleMouseLeave);\n      target[method]('wheel', handle);\n    }\n\n    function enable() {\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.removeEventListener('wheel', handle);\n        return true;\n      }\n\n      if (swiper.mousewheel.enabled) return false;\n      events('on');\n      swiper.mousewheel.enabled = true;\n      return true;\n    }\n\n    function disable() {\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.addEventListener(event, handle);\n        return true;\n      }\n\n      if (!swiper.mousewheel.enabled) return false;\n      events('off');\n      swiper.mousewheel.enabled = false;\n      return true;\n    }\n\n    on('init', () => {\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n        disable();\n      }\n\n      if (swiper.params.mousewheel.enabled) enable();\n    });\n    on('destroy', () => {\n      if (swiper.params.cssMode) {\n        enable();\n      }\n\n      if (swiper.mousewheel.enabled) disable();\n    });\n    Object.assign(swiper.mousewheel, {\n      enable,\n      disable,\n    });\n  }\n\n  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n    const document = getDocument();\n\n    if (swiper.params.createElements) {\n      Object.keys(checkProps).forEach((key) => {\n        if (!params[key] && params.auto === true) {\n          let element = swiper.$el.children(`.${checkProps[key]}`)[0];\n\n          if (!element) {\n            element = document.createElement('div');\n            element.className = checkProps[key];\n            swiper.$el.append(element);\n          }\n\n          params[key] = element;\n          originalParams[key] = element;\n        }\n      });\n    }\n\n    return params;\n  }\n\n  function Navigation(_ref) {\n    const { swiper, extendParams, on, emit } = _ref;\n    extendParams({\n      navigation: {\n        nextEl: null,\n        prevEl: null,\n        hideOnClick: false,\n        disabledClass: 'swiper-button-disabled',\n        hiddenClass: 'swiper-button-hidden',\n        lockClass: 'swiper-button-lock',\n        navigationDisabledClass: 'swiper-navigation-disabled',\n      },\n    });\n    swiper.navigation = {\n      nextEl: null,\n      $nextEl: null,\n      prevEl: null,\n      $prevEl: null,\n    };\n\n    function getEl(el) {\n      let $el;\n\n      if (el) {\n        $el = $(el);\n\n        if (\n          swiper.params.uniqueNavElements &&\n          typeof el === 'string' &&\n          $el.length > 1 &&\n          swiper.$el.find(el).length === 1\n        ) {\n          $el = swiper.$el.find(el);\n        }\n      }\n\n      return $el;\n    }\n\n    function toggleEl($el, disabled) {\n      const params = swiper.params.navigation;\n\n      if ($el && $el.length > 0) {\n        $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);\n        if ($el[0] && $el[0].tagName === 'BUTTON') $el[0].disabled = disabled;\n\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n        }\n      }\n    }\n\n    function update() {\n      // Update Navigation Buttons\n      if (swiper.params.loop) return;\n      const { $nextEl, $prevEl } = swiper.navigation;\n      toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);\n      toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);\n    }\n\n    function onPrevClick(e) {\n      e.preventDefault();\n      if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n      swiper.slidePrev();\n      emit('navigationPrev');\n    }\n\n    function onNextClick(e) {\n      e.preventDefault();\n      if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n      swiper.slideNext();\n      emit('navigationNext');\n    }\n\n    function init() {\n      const params = swiper.params.navigation;\n      swiper.params.navigation = createElementIfNotDefined(\n        swiper,\n        swiper.originalParams.navigation,\n        swiper.params.navigation,\n        {\n          nextEl: 'swiper-button-next',\n          prevEl: 'swiper-button-prev',\n        }\n      );\n      if (!(params.nextEl || params.prevEl)) return;\n      const $nextEl = getEl(params.nextEl);\n      const $prevEl = getEl(params.prevEl);\n\n      if ($nextEl && $nextEl.length > 0) {\n        $nextEl.on('click', onNextClick);\n      }\n\n      if ($prevEl && $prevEl.length > 0) {\n        $prevEl.on('click', onPrevClick);\n      }\n\n      Object.assign(swiper.navigation, {\n        $nextEl,\n        nextEl: $nextEl && $nextEl[0],\n        $prevEl,\n        prevEl: $prevEl && $prevEl[0],\n      });\n\n      if (!swiper.enabled) {\n        if ($nextEl) $nextEl.addClass(params.lockClass);\n        if ($prevEl) $prevEl.addClass(params.lockClass);\n      }\n    }\n\n    function destroy() {\n      const { $nextEl, $prevEl } = swiper.navigation;\n\n      if ($nextEl && $nextEl.length) {\n        $nextEl.off('click', onNextClick);\n        $nextEl.removeClass(swiper.params.navigation.disabledClass);\n      }\n\n      if ($prevEl && $prevEl.length) {\n        $prevEl.off('click', onPrevClick);\n        $prevEl.removeClass(swiper.params.navigation.disabledClass);\n      }\n    }\n\n    on('init', () => {\n      if (swiper.params.navigation.enabled === false) {\n        // eslint-disable-next-line\n        disable();\n      } else {\n        init();\n        update();\n      }\n    });\n    on('toEdge fromEdge lock unlock', () => {\n      update();\n    });\n    on('destroy', () => {\n      destroy();\n    });\n    on('enable disable', () => {\n      const { $nextEl, $prevEl } = swiper.navigation;\n\n      if ($nextEl) {\n        $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);\n      }\n\n      if ($prevEl) {\n        $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);\n      }\n    });\n    on('click', (_s, e) => {\n      const { $nextEl, $prevEl } = swiper.navigation;\n      const targetEl = e.target;\n\n      if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {\n        if (\n          swiper.pagination &&\n          swiper.params.pagination &&\n          swiper.params.pagination.clickable &&\n          (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))\n        ) {\n          return;\n        }\n        let isHidden;\n\n        if ($nextEl) {\n          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);\n        } else if ($prevEl) {\n          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);\n        }\n\n        if (isHidden === true) {\n          emit('navigationShow');\n        } else {\n          emit('navigationHide');\n        }\n\n        if ($nextEl) {\n          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);\n        }\n\n        if ($prevEl) {\n          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);\n        }\n      }\n    });\n\n    const enable = () => {\n      swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);\n      init();\n      update();\n    };\n\n    const disable = () => {\n      swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);\n      destroy();\n    };\n\n    Object.assign(swiper.navigation, {\n      enable,\n      disable,\n      update,\n      init,\n      destroy,\n    });\n  }\n\n  function classesToSelector(classes) {\n    if (classes === void 0) {\n      classes = '';\n    }\n\n    return `.${classes\n      .trim()\n      .replace(/([\\.:!\\/])/g, '\\\\$1') // eslint-disable-line\n      .replace(/ /g, '.')}`;\n  }\n\n  function Pagination(_ref) {\n    const { swiper, extendParams, on, emit } = _ref;\n    const pfx = 'swiper-pagination';\n    extendParams({\n      pagination: {\n        el: null,\n        bulletElement: 'span',\n        clickable: false,\n        hideOnClick: false,\n        renderBullet: null,\n        renderProgressbar: null,\n        renderFraction: null,\n        renderCustom: null,\n        progressbarOpposite: false,\n        type: 'bullets',\n        // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n        dynamicBullets: false,\n        dynamicMainBullets: 1,\n        formatFractionCurrent: (number) => number,\n        formatFractionTotal: (number) => number,\n        bulletClass: `${pfx}-bullet`,\n        bulletActiveClass: `${pfx}-bullet-active`,\n        modifierClass: `${pfx}-`,\n        currentClass: `${pfx}-current`,\n        totalClass: `${pfx}-total`,\n        hiddenClass: `${pfx}-hidden`,\n        progressbarFillClass: `${pfx}-progressbar-fill`,\n        progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n        clickableClass: `${pfx}-clickable`,\n        lockClass: `${pfx}-lock`,\n        horizontalClass: `${pfx}-horizontal`,\n        verticalClass: `${pfx}-vertical`,\n        paginationDisabledClass: `${pfx}-disabled`,\n      },\n    });\n    swiper.pagination = {\n      el: null,\n      $el: null,\n      bullets: [],\n    };\n    let bulletSize;\n    let dynamicBulletIndex = 0;\n\n    function isPaginationDisabled() {\n      return (\n        !swiper.params.pagination.el ||\n        !swiper.pagination.el ||\n        !swiper.pagination.$el ||\n        swiper.pagination.$el.length === 0\n      );\n    }\n\n    function setSideBullets($bulletEl, position) {\n      const { bulletActiveClass } = swiper.params.pagination;\n      $bulletEl[position]()\n        .addClass(`${bulletActiveClass}-${position}`)\n        [position]()\n        .addClass(`${bulletActiveClass}-${position}-${position}`);\n    }\n\n    function update() {\n      // Render || Update Pagination bullets/items\n      const { rtl } = swiper;\n      const params = swiper.params.pagination;\n      if (isPaginationDisabled()) return;\n      const slidesLength =\n        swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n      const { $el } = swiper.pagination; // Current/Total\n\n      let current;\n      const total = swiper.params.loop\n        ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup)\n        : swiper.snapGrid.length;\n\n      if (swiper.params.loop) {\n        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\n\n        if (current > slidesLength - 1 - swiper.loopedSlides * 2) {\n          current -= slidesLength - swiper.loopedSlides * 2;\n        }\n\n        if (current > total - 1) current -= total;\n        if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;\n      } else if (typeof swiper.snapIndex !== 'undefined') {\n        current = swiper.snapIndex;\n      } else {\n        current = swiper.activeIndex || 0;\n      } // Types\n\n      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n        const { bullets } = swiper.pagination;\n        let firstIndex;\n        let lastIndex;\n        let midIndex;\n\n        if (params.dynamicBullets) {\n          bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\n          $el.css(swiper.isHorizontal() ? 'width' : 'height', `${bulletSize * (params.dynamicMainBullets + 4)}px`);\n\n          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {\n            dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);\n\n            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n              dynamicBulletIndex = params.dynamicMainBullets - 1;\n            } else if (dynamicBulletIndex < 0) {\n              dynamicBulletIndex = 0;\n            }\n          }\n\n          firstIndex = Math.max(current - dynamicBulletIndex, 0);\n          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n          midIndex = (lastIndex + firstIndex) / 2;\n        }\n\n        bullets.removeClass(\n          ['', '-next', '-next-next', '-prev', '-prev-prev', '-main']\n            .map((suffix) => `${params.bulletActiveClass}${suffix}`)\n            .join(' ')\n        );\n\n        if ($el.length > 1) {\n          bullets.each((bullet) => {\n            const $bullet = $(bullet);\n            const bulletIndex = $bullet.index();\n\n            if (bulletIndex === current) {\n              $bullet.addClass(params.bulletActiveClass);\n            }\n\n            if (params.dynamicBullets) {\n              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n                $bullet.addClass(`${params.bulletActiveClass}-main`);\n              }\n\n              if (bulletIndex === firstIndex) {\n                setSideBullets($bullet, 'prev');\n              }\n\n              if (bulletIndex === lastIndex) {\n                setSideBullets($bullet, 'next');\n              }\n            }\n          });\n        } else {\n          const $bullet = bullets.eq(current);\n          const bulletIndex = $bullet.index();\n          $bullet.addClass(params.bulletActiveClass);\n\n          if (params.dynamicBullets) {\n            const $firstDisplayedBullet = bullets.eq(firstIndex);\n            const $lastDisplayedBullet = bullets.eq(lastIndex);\n\n            for (let i = firstIndex; i <= lastIndex; i += 1) {\n              bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);\n            }\n\n            if (swiper.params.loop) {\n              if (bulletIndex >= bullets.length) {\n                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {\n                  bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);\n                }\n\n                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);\n              } else {\n                setSideBullets($firstDisplayedBullet, 'prev');\n                setSideBullets($lastDisplayedBullet, 'next');\n              }\n            } else {\n              setSideBullets($firstDisplayedBullet, 'prev');\n              setSideBullets($lastDisplayedBullet, 'next');\n            }\n          }\n        }\n\n        if (params.dynamicBullets) {\n          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n          const offsetProp = rtl ? 'right' : 'left';\n          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);\n        }\n      }\n\n      if (params.type === 'fraction') {\n        $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));\n        $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));\n      }\n\n      if (params.type === 'progressbar') {\n        let progressbarDirection;\n\n        if (params.progressbarOpposite) {\n          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n        } else {\n          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n        }\n\n        const scale = (current + 1) / total;\n        let scaleX = 1;\n        let scaleY = 1;\n\n        if (progressbarDirection === 'horizontal') {\n          scaleX = scale;\n        } else {\n          scaleY = scale;\n        }\n\n        $el\n          .find(classesToSelector(params.progressbarFillClass))\n          .transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`)\n          .transition(swiper.params.speed);\n      }\n\n      if (params.type === 'custom' && params.renderCustom) {\n        $el.html(params.renderCustom(swiper, current + 1, total));\n        emit('paginationRender', $el[0]);\n      } else {\n        emit('paginationUpdate', $el[0]);\n      }\n\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\n      }\n    }\n\n    function render() {\n      // Render Container\n      const params = swiper.params.pagination;\n      if (isPaginationDisabled()) return;\n      const slidesLength =\n        swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n      const { $el } = swiper.pagination;\n      let paginationHTML = '';\n\n      if (params.type === 'bullets') {\n        let numberOfBullets = swiper.params.loop\n          ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup)\n          : swiper.snapGrid.length;\n\n        if (\n          swiper.params.freeMode &&\n          swiper.params.freeMode.enabled &&\n          !swiper.params.loop &&\n          numberOfBullets > slidesLength\n        ) {\n          numberOfBullets = slidesLength;\n        }\n\n        for (let i = 0; i < numberOfBullets; i += 1) {\n          if (params.renderBullet) {\n            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n          } else {\n            paginationHTML += `<${params.bulletElement} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n          }\n        }\n\n        $el.html(paginationHTML);\n        swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));\n      }\n\n      if (params.type === 'fraction') {\n        if (params.renderFraction) {\n          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n        } else {\n          paginationHTML =\n            `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n        }\n\n        $el.html(paginationHTML);\n      }\n\n      if (params.type === 'progressbar') {\n        if (params.renderProgressbar) {\n          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n        } else {\n          paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n        }\n\n        $el.html(paginationHTML);\n      }\n\n      if (params.type !== 'custom') {\n        emit('paginationRender', swiper.pagination.$el[0]);\n      }\n    }\n\n    function init() {\n      swiper.params.pagination = createElementIfNotDefined(\n        swiper,\n        swiper.originalParams.pagination,\n        swiper.params.pagination,\n        {\n          el: 'swiper-pagination',\n        }\n      );\n      const params = swiper.params.pagination;\n      if (!params.el) return;\n      let $el = $(params.el);\n      if ($el.length === 0) return;\n\n      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {\n        $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper\n\n        if ($el.length > 1) {\n          $el = $el.filter((el) => {\n            if ($(el).parents('.swiper')[0] !== swiper.el) return false;\n            return true;\n          });\n        }\n      }\n\n      if (params.type === 'bullets' && params.clickable) {\n        $el.addClass(params.clickableClass);\n      }\n\n      $el.addClass(params.modifierClass + params.type);\n      $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n\n      if (params.type === 'bullets' && params.dynamicBullets) {\n        $el.addClass(`${params.modifierClass}${params.type}-dynamic`);\n        dynamicBulletIndex = 0;\n\n        if (params.dynamicMainBullets < 1) {\n          params.dynamicMainBullets = 1;\n        }\n      }\n\n      if (params.type === 'progressbar' && params.progressbarOpposite) {\n        $el.addClass(params.progressbarOppositeClass);\n      }\n\n      if (params.clickable) {\n        $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {\n          e.preventDefault();\n          let index = $(this).index() * swiper.params.slidesPerGroup;\n          if (swiper.params.loop) index += swiper.loopedSlides;\n          swiper.slideTo(index);\n        });\n      }\n\n      Object.assign(swiper.pagination, {\n        $el,\n        el: $el[0],\n      });\n\n      if (!swiper.enabled) {\n        $el.addClass(params.lockClass);\n      }\n    }\n\n    function destroy() {\n      const params = swiper.params.pagination;\n      if (isPaginationDisabled()) return;\n      const { $el } = swiper.pagination;\n      $el.removeClass(params.hiddenClass);\n      $el.removeClass(params.modifierClass + params.type);\n      $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) {\n        swiper.pagination.bullets.removeClass(params.bulletActiveClass);\n      }\n\n      if (params.clickable) {\n        $el.off('click', classesToSelector(params.bulletClass));\n      }\n    }\n\n    on('init', () => {\n      if (swiper.params.pagination.enabled === false) {\n        // eslint-disable-next-line\n        disable();\n      } else {\n        init();\n        render();\n        update();\n      }\n    });\n    on('activeIndexChange', () => {\n      if (swiper.params.loop) {\n        update();\n      } else if (typeof swiper.snapIndex === 'undefined') {\n        update();\n      }\n    });\n    on('snapIndexChange', () => {\n      if (!swiper.params.loop) {\n        update();\n      }\n    });\n    on('slidesLengthChange', () => {\n      if (swiper.params.loop) {\n        render();\n        update();\n      }\n    });\n    on('snapGridLengthChange', () => {\n      if (!swiper.params.loop) {\n        render();\n        update();\n      }\n    });\n    on('destroy', () => {\n      destroy();\n    });\n    on('enable disable', () => {\n      const { $el } = swiper.pagination;\n\n      if ($el) {\n        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);\n      }\n    });\n    on('lock unlock', () => {\n      update();\n    });\n    on('click', (_s, e) => {\n      const targetEl = e.target;\n      const { $el } = swiper.pagination;\n\n      if (\n        swiper.params.pagination.el &&\n        swiper.params.pagination.hideOnClick &&\n        $el &&\n        $el.length > 0 &&\n        !$(targetEl).hasClass(swiper.params.pagination.bulletClass)\n      ) {\n        if (\n          swiper.navigation &&\n          ((swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) ||\n            (swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))\n        ) {\n          return;\n        }\n        const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);\n\n        if (isHidden === true) {\n          emit('paginationShow');\n        } else {\n          emit('paginationHide');\n        }\n\n        $el.toggleClass(swiper.params.pagination.hiddenClass);\n      }\n    });\n\n    const enable = () => {\n      swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);\n\n      if (swiper.pagination.$el) {\n        swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);\n      }\n\n      init();\n      render();\n      update();\n    };\n\n    const disable = () => {\n      swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);\n\n      if (swiper.pagination.$el) {\n        swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);\n      }\n\n      destroy();\n    };\n\n    Object.assign(swiper.pagination, {\n      enable,\n      disable,\n      render,\n      update,\n      init,\n      destroy,\n    });\n  }\n\n  function Scrollbar(_ref) {\n    const { swiper, extendParams, on, emit } = _ref;\n    const document = getDocument();\n    let isTouched = false;\n    let timeout = null;\n    let dragTimeout = null;\n    let dragStartPos;\n    let dragSize;\n    let trackSize;\n    let divider;\n    extendParams({\n      scrollbar: {\n        el: null,\n        dragSize: 'auto',\n        hide: false,\n        draggable: false,\n        snapOnRelease: true,\n        lockClass: 'swiper-scrollbar-lock',\n        dragClass: 'swiper-scrollbar-drag',\n        scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n        horizontalClass: 'swiper-scrollbar-horizontal',\n        verticalClass: 'swiper-scrollbar-vertical',\n      },\n    });\n    swiper.scrollbar = {\n      el: null,\n      dragEl: null,\n      $el: null,\n      $dragEl: null,\n    };\n\n    function setTranslate() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      const { scrollbar, rtlTranslate: rtl, progress } = swiper;\n      const { $dragEl, $el } = scrollbar;\n      const params = swiper.params.scrollbar;\n      let newSize = dragSize;\n      let newPos = (trackSize - dragSize) * progress;\n\n      if (rtl) {\n        newPos = -newPos;\n\n        if (newPos > 0) {\n          newSize = dragSize - newPos;\n          newPos = 0;\n        } else if (-newPos + dragSize > trackSize) {\n          newSize = trackSize + newPos;\n        }\n      } else if (newPos < 0) {\n        newSize = dragSize + newPos;\n        newPos = 0;\n      } else if (newPos + dragSize > trackSize) {\n        newSize = trackSize - newPos;\n      }\n\n      if (swiper.isHorizontal()) {\n        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);\n        $dragEl[0].style.width = `${newSize}px`;\n      } else {\n        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);\n        $dragEl[0].style.height = `${newSize}px`;\n      }\n\n      if (params.hide) {\n        clearTimeout(timeout);\n        $el[0].style.opacity = 1;\n        timeout = setTimeout(() => {\n          $el[0].style.opacity = 0;\n          $el.transition(400);\n        }, 1000);\n      }\n    }\n\n    function setTransition(duration) {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      swiper.scrollbar.$dragEl.transition(duration);\n    }\n\n    function updateSize() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      const { scrollbar } = swiper;\n      const { $dragEl, $el } = scrollbar;\n      $dragEl[0].style.width = '';\n      $dragEl[0].style.height = '';\n      trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;\n      divider =\n        swiper.size /\n        (swiper.virtualSize +\n          swiper.params.slidesOffsetBefore -\n          (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n\n      if (swiper.params.scrollbar.dragSize === 'auto') {\n        dragSize = trackSize * divider;\n      } else {\n        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n      }\n\n      if (swiper.isHorizontal()) {\n        $dragEl[0].style.width = `${dragSize}px`;\n      } else {\n        $dragEl[0].style.height = `${dragSize}px`;\n      }\n\n      if (divider >= 1) {\n        $el[0].style.display = 'none';\n      } else {\n        $el[0].style.display = '';\n      }\n\n      if (swiper.params.scrollbar.hide) {\n        $el[0].style.opacity = 0;\n      }\n\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);\n      }\n    }\n\n    function getPointerPosition(e) {\n      if (swiper.isHorizontal()) {\n        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;\n      }\n\n      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;\n    }\n\n    function setDragPosition(e) {\n      const { scrollbar, rtlTranslate: rtl } = swiper;\n      const { $el } = scrollbar;\n      let positionRatio;\n      positionRatio =\n        (getPointerPosition(e) -\n          $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] -\n          (dragStartPos !== null ? dragStartPos : dragSize / 2)) /\n        (trackSize - dragSize);\n      positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n\n      if (rtl) {\n        positionRatio = 1 - positionRatio;\n      }\n\n      const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n      swiper.updateProgress(position);\n      swiper.setTranslate(position);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    function onDragStart(e) {\n      const params = swiper.params.scrollbar;\n      const { scrollbar, $wrapperEl } = swiper;\n      const { $el, $dragEl } = scrollbar;\n      isTouched = true;\n      dragStartPos =\n        e.target === $dragEl[0] || e.target === $dragEl\n          ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top']\n          : null;\n      e.preventDefault();\n      e.stopPropagation();\n      $wrapperEl.transition(100);\n      $dragEl.transition(100);\n      setDragPosition(e);\n      clearTimeout(dragTimeout);\n      $el.transition(0);\n\n      if (params.hide) {\n        $el.css('opacity', 1);\n      }\n\n      if (swiper.params.cssMode) {\n        swiper.$wrapperEl.css('scroll-snap-type', 'none');\n      }\n\n      emit('scrollbarDragStart', e);\n    }\n\n    function onDragMove(e) {\n      const { scrollbar, $wrapperEl } = swiper;\n      const { $el, $dragEl } = scrollbar;\n      if (!isTouched) return;\n      if (e.preventDefault) e.preventDefault();\n      else e.returnValue = false;\n      setDragPosition(e);\n      $wrapperEl.transition(0);\n      $el.transition(0);\n      $dragEl.transition(0);\n      emit('scrollbarDragMove', e);\n    }\n\n    function onDragEnd(e) {\n      const params = swiper.params.scrollbar;\n      const { scrollbar, $wrapperEl } = swiper;\n      const { $el } = scrollbar;\n      if (!isTouched) return;\n      isTouched = false;\n\n      if (swiper.params.cssMode) {\n        swiper.$wrapperEl.css('scroll-snap-type', '');\n        $wrapperEl.transition('');\n      }\n\n      if (params.hide) {\n        clearTimeout(dragTimeout);\n        dragTimeout = nextTick(() => {\n          $el.css('opacity', 0);\n          $el.transition(400);\n        }, 1000);\n      }\n\n      emit('scrollbarDragEnd', e);\n\n      if (params.snapOnRelease) {\n        swiper.slideToClosest();\n      }\n    }\n\n    function events(method) {\n      const { scrollbar, touchEventsTouch, touchEventsDesktop, params, support } = swiper;\n      const { $el } = scrollbar;\n      if (!$el) return;\n      const target = $el[0];\n      const activeListener =\n        support.passiveListener && params.passiveListeners\n          ? {\n              passive: false,\n              capture: false,\n            }\n          : false;\n      const passiveListener =\n        support.passiveListener && params.passiveListeners\n          ? {\n              passive: true,\n              capture: false,\n            }\n          : false;\n      if (!target) return;\n      const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n\n      if (!support.touch) {\n        target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);\n        document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);\n        document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);\n      } else {\n        target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);\n        target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);\n        target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);\n      }\n    }\n\n    function enableDraggable() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      events('on');\n    }\n\n    function disableDraggable() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      events('off');\n    }\n\n    function init() {\n      const { scrollbar, $el: $swiperEl } = swiper;\n      swiper.params.scrollbar = createElementIfNotDefined(\n        swiper,\n        swiper.originalParams.scrollbar,\n        swiper.params.scrollbar,\n        {\n          el: 'swiper-scrollbar',\n        }\n      );\n      const params = swiper.params.scrollbar;\n      if (!params.el) return;\n      let $el = $(params.el);\n\n      if (\n        swiper.params.uniqueNavElements &&\n        typeof params.el === 'string' &&\n        $el.length > 1 &&\n        $swiperEl.find(params.el).length === 1\n      ) {\n        $el = $swiperEl.find(params.el);\n      }\n\n      $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);\n\n      if ($dragEl.length === 0) {\n        $dragEl = $(`<div class=\"${swiper.params.scrollbar.dragClass}\"></div>`);\n        $el.append($dragEl);\n      }\n\n      Object.assign(scrollbar, {\n        $el,\n        el: $el[0],\n        $dragEl,\n        dragEl: $dragEl[0],\n      });\n\n      if (params.draggable) {\n        enableDraggable();\n      }\n\n      if ($el) {\n        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);\n      }\n    }\n\n    function destroy() {\n      const params = swiper.params.scrollbar;\n      const { $el } = swiper.scrollbar;\n\n      if ($el) {\n        $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      }\n\n      disableDraggable();\n    }\n\n    on('init', () => {\n      if (swiper.params.scrollbar.enabled === false) {\n        // eslint-disable-next-line\n        disable();\n      } else {\n        init();\n        updateSize();\n        setTranslate();\n      }\n    });\n    on('update resize observerUpdate lock unlock', () => {\n      updateSize();\n    });\n    on('setTranslate', () => {\n      setTranslate();\n    });\n    on('setTransition', (_s, duration) => {\n      setTransition(duration);\n    });\n    on('enable disable', () => {\n      const { $el } = swiper.scrollbar;\n\n      if ($el) {\n        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);\n      }\n    });\n    on('destroy', () => {\n      destroy();\n    });\n\n    const enable = () => {\n      swiper.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);\n\n      if (swiper.scrollbar.$el) {\n        swiper.scrollbar.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);\n      }\n\n      init();\n      updateSize();\n      setTranslate();\n    };\n\n    const disable = () => {\n      swiper.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);\n\n      if (swiper.scrollbar.$el) {\n        swiper.scrollbar.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);\n      }\n\n      destroy();\n    };\n\n    Object.assign(swiper.scrollbar, {\n      enable,\n      disable,\n      updateSize,\n      setTranslate,\n      init,\n      destroy,\n    });\n  }\n\n  function Parallax(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      parallax: {\n        enabled: false,\n      },\n    });\n\n    const setTransform = (el, progress) => {\n      const { rtl } = swiper;\n      const $el = $(el);\n      const rtlFactor = rtl ? -1 : 1;\n      const p = $el.attr('data-swiper-parallax') || '0';\n      let x = $el.attr('data-swiper-parallax-x');\n      let y = $el.attr('data-swiper-parallax-y');\n      const scale = $el.attr('data-swiper-parallax-scale');\n      const opacity = $el.attr('data-swiper-parallax-opacity');\n\n      if (x || y) {\n        x = x || '0';\n        y = y || '0';\n      } else if (swiper.isHorizontal()) {\n        x = p;\n        y = '0';\n      } else {\n        y = p;\n        x = '0';\n      }\n\n      if (x.indexOf('%') >= 0) {\n        x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n      } else {\n        x = `${x * progress * rtlFactor}px`;\n      }\n\n      if (y.indexOf('%') >= 0) {\n        y = `${parseInt(y, 10) * progress}%`;\n      } else {\n        y = `${y * progress}px`;\n      }\n\n      if (typeof opacity !== 'undefined' && opacity !== null) {\n        const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n        $el[0].style.opacity = currentOpacity;\n      }\n\n      if (typeof scale === 'undefined' || scale === null) {\n        $el.transform(`translate3d(${x}, ${y}, 0px)`);\n      } else {\n        const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n        $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);\n      }\n    };\n\n    const setTranslate = () => {\n      const { $el, slides, progress, snapGrid } = swiper;\n      $el\n        .children(\n          '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]'\n        )\n        .each((el) => {\n          setTransform(el, progress);\n        });\n      slides.each((slideEl, slideIndex) => {\n        let slideProgress = slideEl.progress;\n\n        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n          slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n        }\n\n        slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n        $(slideEl)\n          .find(\n            '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]'\n          )\n          .each((el) => {\n            setTransform(el, slideProgress);\n          });\n      });\n    };\n\n    const setTransition = function (duration) {\n      if (duration === void 0) {\n        duration = swiper.params.speed;\n      }\n\n      const { $el } = swiper;\n      $el\n        .find(\n          '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]'\n        )\n        .each((parallaxEl) => {\n          const $parallaxEl = $(parallaxEl);\n          let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;\n          if (duration === 0) parallaxDuration = 0;\n          $parallaxEl.transition(parallaxDuration);\n        });\n    };\n\n    on('beforeInit', () => {\n      if (!swiper.params.parallax.enabled) return;\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n    });\n    on('init', () => {\n      if (!swiper.params.parallax.enabled) return;\n      setTranslate();\n    });\n    on('setTranslate', () => {\n      if (!swiper.params.parallax.enabled) return;\n      setTranslate();\n    });\n    on('setTransition', (_swiper, duration) => {\n      if (!swiper.params.parallax.enabled) return;\n      setTransition(duration);\n    });\n  }\n\n  function Zoom(_ref) {\n    const { swiper, extendParams, on, emit } = _ref;\n    const window = getWindow();\n    extendParams({\n      zoom: {\n        enabled: false,\n        maxRatio: 3,\n        minRatio: 1,\n        toggle: true,\n        containerClass: 'swiper-zoom-container',\n        zoomedSlideClass: 'swiper-slide-zoomed',\n      },\n    });\n    swiper.zoom = {\n      enabled: false,\n    };\n    let currentScale = 1;\n    let isScaling = false;\n    let gesturesEnabled;\n    let fakeGestureTouched;\n    let fakeGestureMoved;\n    const gesture = {\n      $slideEl: undefined,\n      slideWidth: undefined,\n      slideHeight: undefined,\n      $imageEl: undefined,\n      $imageWrapEl: undefined,\n      maxRatio: 3,\n    };\n    const image = {\n      isTouched: undefined,\n      isMoved: undefined,\n      currentX: undefined,\n      currentY: undefined,\n      minX: undefined,\n      minY: undefined,\n      maxX: undefined,\n      maxY: undefined,\n      width: undefined,\n      height: undefined,\n      startX: undefined,\n      startY: undefined,\n      touchesStart: {},\n      touchesCurrent: {},\n    };\n    const velocity = {\n      x: undefined,\n      y: undefined,\n      prevPositionX: undefined,\n      prevPositionY: undefined,\n      prevTime: undefined,\n    };\n    let scale = 1;\n    Object.defineProperty(swiper.zoom, 'scale', {\n      get() {\n        return scale;\n      },\n\n      set(value) {\n        if (scale !== value) {\n          const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;\n          const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;\n          emit('zoomChange', value, imageEl, slideEl);\n        }\n\n        scale = value;\n      },\n    });\n\n    function getDistanceBetweenTouches(e) {\n      if (e.targetTouches.length < 2) return 1;\n      const x1 = e.targetTouches[0].pageX;\n      const y1 = e.targetTouches[0].pageY;\n      const x2 = e.targetTouches[1].pageX;\n      const y2 = e.targetTouches[1].pageY;\n      const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n      return distance;\n    } // Events\n\n    function onGestureStart(e) {\n      const { support } = swiper;\n      const params = swiper.params.zoom;\n      fakeGestureTouched = false;\n      fakeGestureMoved = false;\n\n      if (!support.gestures) {\n        if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {\n          return;\n        }\n\n        fakeGestureTouched = true;\n        gesture.scaleStart = getDistanceBetweenTouches(e);\n      }\n\n      if (!gesture.$slideEl || !gesture.$slideEl.length) {\n        gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);\n        if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n        gesture.$imageEl = gesture.$slideEl\n          .find(`.${params.containerClass}`)\n          .eq(0)\n          .find('picture, img, svg, canvas, .swiper-zoom-target')\n          .eq(0);\n        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n        gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n\n        if (gesture.$imageWrapEl.length === 0) {\n          gesture.$imageEl = undefined;\n          return;\n        }\n      }\n\n      if (gesture.$imageEl) {\n        gesture.$imageEl.transition(0);\n      }\n\n      isScaling = true;\n    }\n\n    function onGestureChange(e) {\n      const { support } = swiper;\n      const params = swiper.params.zoom;\n      const { zoom } = swiper;\n\n      if (!support.gestures) {\n        if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {\n          return;\n        }\n\n        fakeGestureMoved = true;\n        gesture.scaleMove = getDistanceBetweenTouches(e);\n      }\n\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {\n        if (e.type === 'gesturechange') onGestureStart(e);\n        return;\n      }\n\n      if (support.gestures) {\n        zoom.scale = e.scale * currentScale;\n      } else {\n        zoom.scale = (gesture.scaleMove / gesture.scaleStart) * currentScale;\n      }\n\n      if (zoom.scale > gesture.maxRatio) {\n        zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n      }\n\n      if (zoom.scale < params.minRatio) {\n        zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n      }\n\n      gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n    }\n\n    function onGestureEnd(e) {\n      const { device } = swiper;\n      const { support } = swiper;\n      const params = swiper.params.zoom;\n      const { zoom } = swiper;\n\n      if (!support.gestures) {\n        if (!fakeGestureTouched || !fakeGestureMoved) {\n          return;\n        }\n\n        if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !device.android)) {\n          return;\n        }\n\n        fakeGestureTouched = false;\n        fakeGestureMoved = false;\n      }\n\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n      gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n      currentScale = zoom.scale;\n      isScaling = false;\n      if (zoom.scale === 1) gesture.$slideEl = undefined;\n    }\n\n    function onTouchStart(e) {\n      const { device } = swiper;\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n      if (image.isTouched) return;\n      if (device.android && e.cancelable) e.preventDefault();\n      image.isTouched = true;\n      image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\n      image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\n    }\n\n    function onTouchMove(e) {\n      const { zoom } = swiper;\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n      swiper.allowClick = false;\n      if (!image.isTouched || !gesture.$slideEl) return;\n\n      if (!image.isMoved) {\n        image.width = gesture.$imageEl[0].offsetWidth;\n        image.height = gesture.$imageEl[0].offsetHeight;\n        image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;\n        image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;\n        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;\n        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;\n        gesture.$imageWrapEl.transition(0);\n      } // Define if we need image drag\n\n      const scaledWidth = image.width * zoom.scale;\n      const scaledHeight = image.height * zoom.scale;\n      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n      image.maxX = -image.minX;\n      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n      image.maxY = -image.minY;\n      image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\n      image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\n\n      if (!image.isMoved && !isScaling) {\n        if (\n          swiper.isHorizontal() &&\n          ((Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x) ||\n            (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x))\n        ) {\n          image.isTouched = false;\n          return;\n        }\n\n        if (\n          !swiper.isHorizontal() &&\n          ((Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y) ||\n            (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y))\n        ) {\n          image.isTouched = false;\n          return;\n        }\n      }\n\n      if (e.cancelable) {\n        e.preventDefault();\n      }\n\n      e.stopPropagation();\n      image.isMoved = true;\n      image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;\n      image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;\n\n      if (image.currentX < image.minX) {\n        image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n      }\n\n      if (image.currentX > image.maxX) {\n        image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n      }\n\n      if (image.currentY < image.minY) {\n        image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n      }\n\n      if (image.currentY > image.maxY) {\n        image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n      } // Velocity\n\n      if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n      if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n      if (!velocity.prevTime) velocity.prevTime = Date.now();\n      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n      velocity.prevPositionX = image.touchesCurrent.x;\n      velocity.prevPositionY = image.touchesCurrent.y;\n      velocity.prevTime = Date.now();\n      gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n    }\n\n    function onTouchEnd() {\n      const { zoom } = swiper;\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;\n\n      if (!image.isTouched || !image.isMoved) {\n        image.isTouched = false;\n        image.isMoved = false;\n        return;\n      }\n\n      image.isTouched = false;\n      image.isMoved = false;\n      let momentumDurationX = 300;\n      let momentumDurationY = 300;\n      const momentumDistanceX = velocity.x * momentumDurationX;\n      const newPositionX = image.currentX + momentumDistanceX;\n      const momentumDistanceY = velocity.y * momentumDurationY;\n      const newPositionY = image.currentY + momentumDistanceY; // Fix duration\n\n      if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n      if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n      const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n      image.currentX = newPositionX;\n      image.currentY = newPositionY; // Define if we need image drag\n\n      const scaledWidth = image.width * zoom.scale;\n      const scaledHeight = image.height * zoom.scale;\n      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n      image.maxX = -image.minX;\n      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n      image.maxY = -image.minY;\n      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n      gesture.$imageWrapEl\n        .transition(momentumDuration)\n        .transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);\n    }\n\n    function onTransitionEnd() {\n      const { zoom } = swiper;\n\n      if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {\n        if (gesture.$imageEl) {\n          gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');\n        }\n\n        if (gesture.$imageWrapEl) {\n          gesture.$imageWrapEl.transform('translate3d(0,0,0)');\n        }\n\n        zoom.scale = 1;\n        currentScale = 1;\n        gesture.$slideEl = undefined;\n        gesture.$imageEl = undefined;\n        gesture.$imageWrapEl = undefined;\n      }\n    }\n\n    function zoomIn(e) {\n      const { zoom } = swiper;\n      const params = swiper.params.zoom;\n\n      if (!gesture.$slideEl) {\n        if (e && e.target) {\n          gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);\n        }\n\n        if (!gesture.$slideEl) {\n          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n            gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);\n          } else {\n            gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n          }\n        }\n\n        gesture.$imageEl = gesture.$slideEl\n          .find(`.${params.containerClass}`)\n          .eq(0)\n          .find('picture, img, svg, canvas, .swiper-zoom-target')\n          .eq(0);\n        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n      }\n\n      if (\n        !gesture.$imageEl ||\n        gesture.$imageEl.length === 0 ||\n        !gesture.$imageWrapEl ||\n        gesture.$imageWrapEl.length === 0\n      ) {\n        return;\n      }\n\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.style.overflow = 'hidden';\n        swiper.wrapperEl.style.touchAction = 'none';\n      }\n\n      gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);\n      let touchX;\n      let touchY;\n      let offsetX;\n      let offsetY;\n      let diffX;\n      let diffY;\n      let translateX;\n      let translateY;\n      let imageWidth;\n      let imageHeight;\n      let scaledWidth;\n      let scaledHeight;\n      let translateMinX;\n      let translateMinY;\n      let translateMaxX;\n      let translateMaxY;\n      let slideWidth;\n      let slideHeight;\n\n      if (typeof image.touchesStart.x === 'undefined' && e) {\n        touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;\n        touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;\n      } else {\n        touchX = image.touchesStart.x;\n        touchY = image.touchesStart.y;\n      }\n\n      zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n      currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\n\n      if (e) {\n        slideWidth = gesture.$slideEl[0].offsetWidth;\n        slideHeight = gesture.$slideEl[0].offsetHeight;\n        offsetX = gesture.$slideEl.offset().left + window.scrollX;\n        offsetY = gesture.$slideEl.offset().top + window.scrollY;\n        diffX = offsetX + slideWidth / 2 - touchX;\n        diffY = offsetY + slideHeight / 2 - touchY;\n        imageWidth = gesture.$imageEl[0].offsetWidth;\n        imageHeight = gesture.$imageEl[0].offsetHeight;\n        scaledWidth = imageWidth * zoom.scale;\n        scaledHeight = imageHeight * zoom.scale;\n        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n        translateMaxX = -translateMinX;\n        translateMaxY = -translateMinY;\n        translateX = diffX * zoom.scale;\n        translateY = diffY * zoom.scale;\n\n        if (translateX < translateMinX) {\n          translateX = translateMinX;\n        }\n\n        if (translateX > translateMaxX) {\n          translateX = translateMaxX;\n        }\n\n        if (translateY < translateMinY) {\n          translateY = translateMinY;\n        }\n\n        if (translateY > translateMaxY) {\n          translateY = translateMaxY;\n        }\n      } else {\n        translateX = 0;\n        translateY = 0;\n      }\n\n      gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);\n      gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);\n    }\n\n    function zoomOut() {\n      const { zoom } = swiper;\n      const params = swiper.params.zoom;\n\n      if (!gesture.$slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);\n        } else {\n          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\n        }\n\n        gesture.$imageEl = gesture.$slideEl\n          .find(`.${params.containerClass}`)\n          .eq(0)\n          .find('picture, img, svg, canvas, .swiper-zoom-target')\n          .eq(0);\n        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);\n      }\n\n      if (\n        !gesture.$imageEl ||\n        gesture.$imageEl.length === 0 ||\n        !gesture.$imageWrapEl ||\n        gesture.$imageWrapEl.length === 0\n      ) {\n        return;\n      }\n\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.style.overflow = '';\n        swiper.wrapperEl.style.touchAction = '';\n      }\n\n      zoom.scale = 1;\n      currentScale = 1;\n      gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');\n      gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');\n      gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);\n      gesture.$slideEl = undefined;\n    } // Toggle Zoom\n\n    function zoomToggle(e) {\n      const { zoom } = swiper;\n\n      if (zoom.scale && zoom.scale !== 1) {\n        // Zoom Out\n        zoomOut();\n      } else {\n        // Zoom In\n        zoomIn(e);\n      }\n    }\n\n    function getListeners() {\n      const { support } = swiper;\n      const passiveListener =\n        swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners\n          ? {\n              passive: true,\n              capture: false,\n            }\n          : false;\n      const activeListenerWithCapture = support.passiveListener\n        ? {\n            passive: false,\n            capture: true,\n          }\n        : true;\n      return {\n        passiveListener,\n        activeListenerWithCapture,\n      };\n    }\n\n    function getSlideSelector() {\n      return `.${swiper.params.slideClass}`;\n    }\n\n    function toggleGestures(method) {\n      const { passiveListener } = getListeners();\n      const slideSelector = getSlideSelector();\n      swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);\n      swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);\n      swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);\n    }\n\n    function enableGestures() {\n      if (gesturesEnabled) return;\n      gesturesEnabled = true;\n      toggleGestures('on');\n    }\n\n    function disableGestures() {\n      if (!gesturesEnabled) return;\n      gesturesEnabled = false;\n      toggleGestures('off');\n    } // Attach/Detach Events\n\n    function enable() {\n      const { zoom } = swiper;\n      if (zoom.enabled) return;\n      zoom.enabled = true;\n      const { support } = swiper;\n      const { passiveListener, activeListenerWithCapture } = getListeners();\n      const slideSelector = getSlideSelector(); // Scale image\n\n      if (support.gestures) {\n        swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);\n        swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);\n      } else if (swiper.touchEvents.start === 'touchstart') {\n        swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);\n        swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);\n        swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);\n\n        if (swiper.touchEvents.cancel) {\n          swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);\n        }\n      } // Move image\n\n      swiper.$wrapperEl.on(\n        swiper.touchEvents.move,\n        `.${swiper.params.zoom.containerClass}`,\n        onTouchMove,\n        activeListenerWithCapture\n      );\n    }\n\n    function disable() {\n      const { zoom } = swiper;\n      if (!zoom.enabled) return;\n      const { support } = swiper;\n      zoom.enabled = false;\n      const { passiveListener, activeListenerWithCapture } = getListeners();\n      const slideSelector = getSlideSelector(); // Scale image\n\n      if (support.gestures) {\n        swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);\n        swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);\n      } else if (swiper.touchEvents.start === 'touchstart') {\n        swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);\n        swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);\n        swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);\n\n        if (swiper.touchEvents.cancel) {\n          swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);\n        }\n      } // Move image\n\n      swiper.$wrapperEl.off(\n        swiper.touchEvents.move,\n        `.${swiper.params.zoom.containerClass}`,\n        onTouchMove,\n        activeListenerWithCapture\n      );\n    }\n\n    on('init', () => {\n      if (swiper.params.zoom.enabled) {\n        enable();\n      }\n    });\n    on('destroy', () => {\n      disable();\n    });\n    on('touchStart', (_s, e) => {\n      if (!swiper.zoom.enabled) return;\n      onTouchStart(e);\n    });\n    on('touchEnd', (_s, e) => {\n      if (!swiper.zoom.enabled) return;\n      onTouchEnd();\n    });\n    on('doubleTap', (_s, e) => {\n      if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n        zoomToggle(e);\n      }\n    });\n    on('transitionEnd', () => {\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n        onTransitionEnd();\n      }\n    });\n    on('slideChange', () => {\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n        onTransitionEnd();\n      }\n    });\n    Object.assign(swiper.zoom, {\n      enable,\n      disable,\n      in: zoomIn,\n      out: zoomOut,\n      toggle: zoomToggle,\n    });\n  }\n\n  function Lazy(_ref) {\n    const { swiper, extendParams, on, emit } = _ref;\n    extendParams({\n      lazy: {\n        checkInView: false,\n        enabled: false,\n        loadPrevNext: false,\n        loadPrevNextAmount: 1,\n        loadOnTransitionStart: false,\n        scrollingElement: '',\n        elementClass: 'swiper-lazy',\n        loadingClass: 'swiper-lazy-loading',\n        loadedClass: 'swiper-lazy-loaded',\n        preloaderClass: 'swiper-lazy-preloader',\n      },\n    });\n    swiper.lazy = {};\n    let scrollHandlerAttached = false;\n    let initialImageLoaded = false;\n\n    function loadInSlide(index, loadInDuplicate) {\n      if (loadInDuplicate === void 0) {\n        loadInDuplicate = true;\n      }\n\n      const params = swiper.params.lazy;\n      if (typeof index === 'undefined') return;\n      if (swiper.slides.length === 0) return;\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      const $slideEl = isVirtual\n        ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${index}\"]`)\n        : swiper.slides.eq(index);\n      const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);\n\n      if (\n        $slideEl.hasClass(params.elementClass) &&\n        !$slideEl.hasClass(params.loadedClass) &&\n        !$slideEl.hasClass(params.loadingClass)\n      ) {\n        $images.push($slideEl[0]);\n      }\n\n      if ($images.length === 0) return;\n      $images.each((imageEl) => {\n        const $imageEl = $(imageEl);\n        $imageEl.addClass(params.loadingClass);\n        const background = $imageEl.attr('data-background');\n        const src = $imageEl.attr('data-src');\n        const srcset = $imageEl.attr('data-srcset');\n        const sizes = $imageEl.attr('data-sizes');\n        const $pictureEl = $imageEl.parent('picture');\n        swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {\n          if (\n            typeof swiper === 'undefined' ||\n            swiper === null ||\n            !swiper ||\n            (swiper && !swiper.params) ||\n            swiper.destroyed\n          ) {\n            return;\n          }\n\n          if (background) {\n            $imageEl.css('background-image', `url(\"${background}\")`);\n            $imageEl.removeAttr('data-background');\n          } else {\n            if (srcset) {\n              $imageEl.attr('srcset', srcset);\n              $imageEl.removeAttr('data-srcset');\n            }\n\n            if (sizes) {\n              $imageEl.attr('sizes', sizes);\n              $imageEl.removeAttr('data-sizes');\n            }\n\n            if ($pictureEl.length) {\n              $pictureEl.children('source').each((sourceEl) => {\n                const $source = $(sourceEl);\n\n                if ($source.attr('data-srcset')) {\n                  $source.attr('srcset', $source.attr('data-srcset'));\n                  $source.removeAttr('data-srcset');\n                }\n              });\n            }\n\n            if (src) {\n              $imageEl.attr('src', src);\n              $imageEl.removeAttr('data-src');\n            }\n          }\n\n          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);\n          $slideEl.find(`.${params.preloaderClass}`).remove();\n\n          if (swiper.params.loop && loadInDuplicate) {\n            const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');\n\n            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {\n              const originalSlide = swiper.$wrapperEl.children(\n                `[data-swiper-slide-index=\"${slideOriginalIndex}\"]:not(.${swiper.params.slideDuplicateClass})`\n              );\n              loadInSlide(originalSlide.index(), false);\n            } else {\n              const duplicatedSlide = swiper.$wrapperEl.children(\n                `.${swiper.params.slideDuplicateClass}[data-swiper-slide-index=\"${slideOriginalIndex}\"]`\n              );\n              loadInSlide(duplicatedSlide.index(), false);\n            }\n          }\n\n          emit('lazyImageReady', $slideEl[0], $imageEl[0]);\n\n          if (swiper.params.autoHeight) {\n            swiper.updateAutoHeight();\n          }\n        });\n        emit('lazyImageLoad', $slideEl[0], $imageEl[0]);\n      });\n    }\n\n    function load() {\n      const { $wrapperEl, params: swiperParams, slides, activeIndex } = swiper;\n      const isVirtual = swiper.virtual && swiperParams.virtual.enabled;\n      const params = swiperParams.lazy;\n      let { slidesPerView } = swiperParams;\n\n      if (slidesPerView === 'auto') {\n        slidesPerView = 0;\n      }\n\n      function slideExist(index) {\n        if (isVirtual) {\n          if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index=\"${index}\"]`).length) {\n            return true;\n          }\n        } else if (slides[index]) return true;\n\n        return false;\n      }\n\n      function slideIndex(slideEl) {\n        if (isVirtual) {\n          return $(slideEl).attr('data-swiper-slide-index');\n        }\n\n        return $(slideEl).index();\n      }\n\n      if (!initialImageLoaded) initialImageLoaded = true;\n\n      if (swiper.params.watchSlidesProgress) {\n        $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((slideEl) => {\n          const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();\n          loadInSlide(index);\n        });\n      } else if (slidesPerView > 1) {\n        for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {\n          if (slideExist(i)) loadInSlide(i);\n        }\n      } else {\n        loadInSlide(activeIndex);\n      }\n\n      if (params.loadPrevNext) {\n        if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {\n          const amount = params.loadPrevNextAmount;\n          const spv = Math.ceil(slidesPerView);\n          const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);\n          const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides\n\n          for (let i = activeIndex + spv; i < maxIndex; i += 1) {\n            if (slideExist(i)) loadInSlide(i);\n          } // Prev Slides\n\n          for (let i = minIndex; i < activeIndex; i += 1) {\n            if (slideExist(i)) loadInSlide(i);\n          }\n        } else {\n          const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);\n          if (nextSlide.length > 0) loadInSlide(slideIndex(nextSlide));\n          const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);\n          if (prevSlide.length > 0) loadInSlide(slideIndex(prevSlide));\n        }\n      }\n    }\n\n    function checkInViewOnLoad() {\n      const window = getWindow();\n      if (!swiper || swiper.destroyed) return;\n      const $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);\n      const isWindow = $scrollElement[0] === window;\n      const scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;\n      const scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;\n      const swiperOffset = swiper.$el.offset();\n      const { rtlTranslate: rtl } = swiper;\n      let inView = false;\n      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;\n      const swiperCoord = [\n        [swiperOffset.left, swiperOffset.top],\n        [swiperOffset.left + swiper.width, swiperOffset.top],\n        [swiperOffset.left, swiperOffset.top + swiper.height],\n        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],\n      ];\n\n      for (let i = 0; i < swiperCoord.length; i += 1) {\n        const point = swiperCoord[i];\n\n        if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {\n          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n\n          inView = true;\n        }\n      }\n\n      const passiveListener =\n        swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners\n          ? {\n              passive: true,\n              capture: false,\n            }\n          : false;\n\n      if (inView) {\n        load();\n        $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);\n      } else if (!scrollHandlerAttached) {\n        scrollHandlerAttached = true;\n        $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);\n      }\n    }\n\n    on('beforeInit', () => {\n      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {\n        swiper.params.preloadImages = false;\n      }\n    });\n    on('init', () => {\n      if (swiper.params.lazy.enabled) {\n        if (swiper.params.lazy.checkInView) {\n          checkInViewOnLoad();\n        } else {\n          load();\n        }\n      }\n    });\n    on('scroll', () => {\n      if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {\n        load();\n      }\n    });\n    on('scrollbarDragMove resize _freeModeNoMomentumRelease', () => {\n      if (swiper.params.lazy.enabled) {\n        if (swiper.params.lazy.checkInView) {\n          checkInViewOnLoad();\n        } else {\n          load();\n        }\n      }\n    });\n    on('transitionStart', () => {\n      if (swiper.params.lazy.enabled) {\n        if (\n          swiper.params.lazy.loadOnTransitionStart ||\n          (!swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded)\n        ) {\n          if (swiper.params.lazy.checkInView) {\n            checkInViewOnLoad();\n          } else {\n            load();\n          }\n        }\n      }\n    });\n    on('transitionEnd', () => {\n      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {\n        if (swiper.params.lazy.checkInView) {\n          checkInViewOnLoad();\n        } else {\n          load();\n        }\n      }\n    });\n    on('slideChange', () => {\n      const { lazy, cssMode, watchSlidesProgress, touchReleaseOnEdges, resistanceRatio } = swiper.params;\n\n      if (lazy.enabled && (cssMode || (watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0)))) {\n        load();\n      }\n    });\n    on('destroy', () => {\n      if (!swiper.$el) return;\n      swiper.$el.find(`.${swiper.params.lazy.loadingClass}`).removeClass(swiper.params.lazy.loadingClass);\n    });\n    Object.assign(swiper.lazy, {\n      load,\n      loadInSlide,\n    });\n  }\n\n  /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n  function Controller(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      controller: {\n        control: undefined,\n        inverse: false,\n        by: 'slide', // or 'container'\n      },\n    });\n    swiper.controller = {\n      control: undefined,\n    };\n\n    function LinearSpline(x, y) {\n      const binarySearch = (function search() {\n        let maxIndex;\n        let minIndex;\n        let guess;\n        return (array, val) => {\n          minIndex = -1;\n          maxIndex = array.length;\n\n          while (maxIndex - minIndex > 1) {\n            guess = (maxIndex + minIndex) >> 1;\n\n            if (array[guess] <= val) {\n              minIndex = guess;\n            } else {\n              maxIndex = guess;\n            }\n          }\n\n          return maxIndex;\n        };\n      })();\n\n      this.x = x;\n      this.y = y;\n      this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:\n      // (x1,y1) is the known point before given value,\n      // (x3,y3) is the known point after given value.\n\n      let i1;\n      let i3;\n\n      this.interpolate = function interpolate(x2) {\n        if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n\n        i3 = binarySearch(this.x, x2);\n        i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:\n        // y2 := ((x2x1)  (y3y1))  (x3x1) + y1\n\n        return ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1];\n      };\n\n      return this;\n    } // xxx: for now i will just save one spline function to to\n\n    function getInterpolateFunction(c) {\n      if (!swiper.controller.spline) {\n        swiper.controller.spline = swiper.params.loop\n          ? new LinearSpline(swiper.slidesGrid, c.slidesGrid)\n          : new LinearSpline(swiper.snapGrid, c.snapGrid);\n      }\n    }\n\n    function setTranslate(_t, byController) {\n      const controlled = swiper.controller.control;\n      let multiplier;\n      let controlledTranslate;\n      const Swiper = swiper.constructor;\n\n      function setControlledTranslate(c) {\n        // this will create an Interpolate function based on the snapGrids\n        // x is the Grid of the scrolled scroller and y will be the controlled scroller\n        // it makes sense to create this only once and recall it for the interpolation\n        // the function does a lot of value caching for performance\n        const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n\n        if (swiper.params.controller.by === 'slide') {\n          getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n          // but it did not work out\n\n          controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n        }\n\n        if (!controlledTranslate || swiper.params.controller.by === 'container') {\n          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n          controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n        }\n\n        if (swiper.params.controller.inverse) {\n          controlledTranslate = c.maxTranslate() - controlledTranslate;\n        }\n\n        c.updateProgress(controlledTranslate);\n        c.setTranslate(controlledTranslate, swiper);\n        c.updateActiveIndex();\n        c.updateSlidesClasses();\n      }\n\n      if (Array.isArray(controlled)) {\n        for (let i = 0; i < controlled.length; i += 1) {\n          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n            setControlledTranslate(controlled[i]);\n          }\n        }\n      } else if (controlled instanceof Swiper && byController !== controlled) {\n        setControlledTranslate(controlled);\n      }\n    }\n\n    function setTransition(duration, byController) {\n      const Swiper = swiper.constructor;\n      const controlled = swiper.controller.control;\n      let i;\n\n      function setControlledTransition(c) {\n        c.setTransition(duration, swiper);\n\n        if (duration !== 0) {\n          c.transitionStart();\n\n          if (c.params.autoHeight) {\n            nextTick(() => {\n              c.updateAutoHeight();\n            });\n          }\n\n          c.$wrapperEl.transitionEnd(() => {\n            if (!controlled) return;\n\n            if (c.params.loop && swiper.params.controller.by === 'slide') {\n              c.loopFix();\n            }\n\n            c.transitionEnd();\n          });\n        }\n      }\n\n      if (Array.isArray(controlled)) {\n        for (i = 0; i < controlled.length; i += 1) {\n          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n            setControlledTransition(controlled[i]);\n          }\n        }\n      } else if (controlled instanceof Swiper && byController !== controlled) {\n        setControlledTransition(controlled);\n      }\n    }\n\n    function removeSpline() {\n      if (!swiper.controller.control) return;\n\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    }\n\n    on('beforeInit', () => {\n      swiper.controller.control = swiper.params.controller.control;\n    });\n    on('update', () => {\n      removeSpline();\n    });\n    on('resize', () => {\n      removeSpline();\n    });\n    on('observerUpdate', () => {\n      removeSpline();\n    });\n    on('setTranslate', (_s, translate, byController) => {\n      if (!swiper.controller.control) return;\n      swiper.controller.setTranslate(translate, byController);\n    });\n    on('setTransition', (_s, duration, byController) => {\n      if (!swiper.controller.control) return;\n      swiper.controller.setTransition(duration, byController);\n    });\n    Object.assign(swiper.controller, {\n      setTranslate,\n      setTransition,\n    });\n  }\n\n  function A11y(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      a11y: {\n        enabled: true,\n        notificationClass: 'swiper-notification',\n        prevSlideMessage: 'Previous slide',\n        nextSlideMessage: 'Next slide',\n        firstSlideMessage: 'This is the first slide',\n        lastSlideMessage: 'This is the last slide',\n        paginationBulletMessage: 'Go to slide {{index}}',\n        slideLabelMessage: '{{index}} / {{slidesLength}}',\n        containerMessage: null,\n        containerRoleDescriptionMessage: null,\n        itemRoleDescriptionMessage: null,\n        slideRole: 'group',\n        id: null,\n      },\n    });\n    let liveRegion = null;\n\n    function notify(message) {\n      const notification = liveRegion;\n      if (notification.length === 0) return;\n      notification.html('');\n      notification.html(message);\n    }\n\n    function getRandomNumber(size) {\n      if (size === void 0) {\n        size = 16;\n      }\n\n      const randomChar = () => Math.round(16 * Math.random()).toString(16);\n\n      return 'x'.repeat(size).replace(/x/g, randomChar);\n    }\n\n    function makeElFocusable($el) {\n      $el.attr('tabIndex', '0');\n    }\n\n    function makeElNotFocusable($el) {\n      $el.attr('tabIndex', '-1');\n    }\n\n    function addElRole($el, role) {\n      $el.attr('role', role);\n    }\n\n    function addElRoleDescription($el, description) {\n      $el.attr('aria-roledescription', description);\n    }\n\n    function addElControls($el, controls) {\n      $el.attr('aria-controls', controls);\n    }\n\n    function addElLabel($el, label) {\n      $el.attr('aria-label', label);\n    }\n\n    function addElId($el, id) {\n      $el.attr('id', id);\n    }\n\n    function addElLive($el, live) {\n      $el.attr('aria-live', live);\n    }\n\n    function disableEl($el) {\n      $el.attr('aria-disabled', true);\n    }\n\n    function enableEl($el) {\n      $el.attr('aria-disabled', false);\n    }\n\n    function onEnterOrSpaceKey(e) {\n      if (e.keyCode !== 13 && e.keyCode !== 32) return;\n      const params = swiper.params.a11y;\n      const $targetEl = $(e.target);\n\n      if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {\n        if (!(swiper.isEnd && !swiper.params.loop)) {\n          swiper.slideNext();\n        }\n\n        if (swiper.isEnd) {\n          notify(params.lastSlideMessage);\n        } else {\n          notify(params.nextSlideMessage);\n        }\n      }\n\n      if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {\n        if (!(swiper.isBeginning && !swiper.params.loop)) {\n          swiper.slidePrev();\n        }\n\n        if (swiper.isBeginning) {\n          notify(params.firstSlideMessage);\n        } else {\n          notify(params.prevSlideMessage);\n        }\n      }\n\n      if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {\n        $targetEl[0].click();\n      }\n    }\n\n    function updateNavigation() {\n      if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n      const { $nextEl, $prevEl } = swiper.navigation;\n\n      if ($prevEl && $prevEl.length > 0) {\n        if (swiper.isBeginning) {\n          disableEl($prevEl);\n          makeElNotFocusable($prevEl);\n        } else {\n          enableEl($prevEl);\n          makeElFocusable($prevEl);\n        }\n      }\n\n      if ($nextEl && $nextEl.length > 0) {\n        if (swiper.isEnd) {\n          disableEl($nextEl);\n          makeElNotFocusable($nextEl);\n        } else {\n          enableEl($nextEl);\n          makeElFocusable($nextEl);\n        }\n      }\n    }\n\n    function hasPagination() {\n      return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n    }\n\n    function hasClickablePagination() {\n      return hasPagination() && swiper.params.pagination.clickable;\n    }\n\n    function updatePagination() {\n      const params = swiper.params.a11y;\n      if (!hasPagination()) return;\n      swiper.pagination.bullets.each((bulletEl) => {\n        const $bulletEl = $(bulletEl);\n\n        if (swiper.params.pagination.clickable) {\n          makeElFocusable($bulletEl);\n\n          if (!swiper.params.pagination.renderBullet) {\n            addElRole($bulletEl, 'button');\n            addElLabel($bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, $bulletEl.index() + 1));\n          }\n        }\n\n        if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {\n          $bulletEl.attr('aria-current', 'true');\n        } else {\n          $bulletEl.removeAttr('aria-current');\n        }\n      });\n    }\n\n    const initNavEl = ($el, wrapperId, message) => {\n      makeElFocusable($el);\n\n      if ($el[0].tagName !== 'BUTTON') {\n        addElRole($el, 'button');\n        $el.on('keydown', onEnterOrSpaceKey);\n      }\n\n      addElLabel($el, message);\n      addElControls($el, wrapperId);\n    };\n\n    const handleFocus = (e) => {\n      const slideEl = e.target.closest(`.${swiper.params.slideClass}`);\n      if (!slideEl || !swiper.slides.includes(slideEl)) return;\n      const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n      const isVisible =\n        swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n      if (isActive || isVisible) return;\n      swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n    };\n\n    const initSlides = () => {\n      const params = swiper.params.a11y;\n\n      if (params.itemRoleDescriptionMessage) {\n        addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);\n      }\n\n      if (params.slideRole) {\n        addElRole($(swiper.slides), params.slideRole);\n      }\n\n      const slidesLength = swiper.params.loop\n        ? swiper.slides.filter((el) => !el.classList.contains(swiper.params.slideDuplicateClass)).length\n        : swiper.slides.length;\n\n      if (params.slideLabelMessage) {\n        swiper.slides.each((slideEl, index) => {\n          const $slideEl = $(slideEl);\n          const slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;\n          const ariaLabelMessage = params.slideLabelMessage\n            .replace(/\\{\\{index\\}\\}/, slideIndex + 1)\n            .replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n          addElLabel($slideEl, ariaLabelMessage);\n        });\n      }\n    };\n\n    const init = () => {\n      const params = swiper.params.a11y;\n      swiper.$el.append(liveRegion); // Container\n\n      const $containerEl = swiper.$el;\n\n      if (params.containerRoleDescriptionMessage) {\n        addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);\n      }\n\n      if (params.containerMessage) {\n        addElLabel($containerEl, params.containerMessage);\n      } // Wrapper\n\n      const { $wrapperEl } = swiper;\n      const wrapperId = params.id || $wrapperEl.attr('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n      const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n      addElId($wrapperEl, wrapperId);\n      addElLive($wrapperEl, live); // Slide\n\n      initSlides(); // Navigation\n\n      let $nextEl;\n      let $prevEl;\n\n      if (swiper.navigation && swiper.navigation.$nextEl) {\n        $nextEl = swiper.navigation.$nextEl;\n      }\n\n      if (swiper.navigation && swiper.navigation.$prevEl) {\n        $prevEl = swiper.navigation.$prevEl;\n      }\n\n      if ($nextEl && $nextEl.length) {\n        initNavEl($nextEl, wrapperId, params.nextSlideMessage);\n      }\n\n      if ($prevEl && $prevEl.length) {\n        initNavEl($prevEl, wrapperId, params.prevSlideMessage);\n      } // Pagination\n\n      if (hasClickablePagination()) {\n        swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);\n      } // Tab focus\n\n      swiper.$el.on('focus', handleFocus, true);\n    };\n\n    function destroy() {\n      if (liveRegion && liveRegion.length > 0) liveRegion.remove();\n      let $nextEl;\n      let $prevEl;\n\n      if (swiper.navigation && swiper.navigation.$nextEl) {\n        $nextEl = swiper.navigation.$nextEl;\n      }\n\n      if (swiper.navigation && swiper.navigation.$prevEl) {\n        $prevEl = swiper.navigation.$prevEl;\n      }\n\n      if ($nextEl) {\n        $nextEl.off('keydown', onEnterOrSpaceKey);\n      }\n\n      if ($prevEl) {\n        $prevEl.off('keydown', onEnterOrSpaceKey);\n      } // Pagination\n\n      if (hasClickablePagination()) {\n        swiper.pagination.$el.off(\n          'keydown',\n          classesToSelector(swiper.params.pagination.bulletClass),\n          onEnterOrSpaceKey\n        );\n      } // Tab focus\n\n      swiper.$el.off('focus', handleFocus, true);\n    }\n\n    on('beforeInit', () => {\n      liveRegion = $(\n        `<span class=\"${swiper.params.a11y.notificationClass}\" aria-live=\"assertive\" aria-atomic=\"true\"></span>`\n      );\n    });\n    on('afterInit', () => {\n      if (!swiper.params.a11y.enabled) return;\n      init();\n    });\n    on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n      if (!swiper.params.a11y.enabled) return;\n      initSlides();\n    });\n    on('fromEdge toEdge afterInit lock unlock', () => {\n      if (!swiper.params.a11y.enabled) return;\n      updateNavigation();\n    });\n    on('paginationUpdate', () => {\n      if (!swiper.params.a11y.enabled) return;\n      updatePagination();\n    });\n    on('destroy', () => {\n      if (!swiper.params.a11y.enabled) return;\n      destroy();\n    });\n  }\n\n  function History(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      history: {\n        enabled: false,\n        root: '',\n        replaceState: false,\n        key: 'slides',\n        keepQuery: false,\n      },\n    });\n    let initialized = false;\n    let paths = {};\n\n    const slugify = (text) =>\n      text\n        .toString()\n        .replace(/\\s+/g, '-')\n        .replace(/[^\\w-]+/g, '')\n        .replace(/--+/g, '-')\n        .replace(/^-+/, '')\n        .replace(/-+$/, '');\n\n    const getPathValues = (urlOverride) => {\n      const window = getWindow();\n      let location;\n\n      if (urlOverride) {\n        location = new URL(urlOverride);\n      } else {\n        location = window.location;\n      }\n\n      const pathArray = location.pathname\n        .slice(1)\n        .split('/')\n        .filter((part) => part !== '');\n      const total = pathArray.length;\n      const key = pathArray[total - 2];\n      const value = pathArray[total - 1];\n      return {\n        key,\n        value,\n      };\n    };\n\n    const setHistory = (key, index) => {\n      const window = getWindow();\n      if (!initialized || !swiper.params.history.enabled) return;\n      let location;\n\n      if (swiper.params.url) {\n        location = new URL(swiper.params.url);\n      } else {\n        location = window.location;\n      }\n\n      const slide = swiper.slides.eq(index);\n      let value = slugify(slide.attr('data-history'));\n\n      if (swiper.params.history.root.length > 0) {\n        let { root } = swiper.params.history;\n        if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n        value = `${root}/${key}/${value}`;\n      } else if (!location.pathname.includes(key)) {\n        value = `${key}/${value}`;\n      }\n\n      if (swiper.params.history.keepQuery) {\n        value += location.search;\n      }\n\n      const currentState = window.history.state;\n\n      if (currentState && currentState.value === value) {\n        return;\n      }\n\n      if (swiper.params.history.replaceState) {\n        window.history.replaceState(\n          {\n            value,\n          },\n          null,\n          value\n        );\n      } else {\n        window.history.pushState(\n          {\n            value,\n          },\n          null,\n          value\n        );\n      }\n    };\n\n    const scrollToSlide = (speed, value, runCallbacks) => {\n      if (value) {\n        for (let i = 0, { length } = swiper.slides; i < length; i += 1) {\n          const slide = swiper.slides.eq(i);\n          const slideHistory = slugify(slide.attr('data-history'));\n\n          if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n            const index = slide.index();\n            swiper.slideTo(index, speed, runCallbacks);\n          }\n        }\n      } else {\n        swiper.slideTo(0, speed, runCallbacks);\n      }\n    };\n\n    const setHistoryPopState = () => {\n      paths = getPathValues(swiper.params.url);\n      scrollToSlide(swiper.params.speed, paths.value, false);\n    };\n\n    const init = () => {\n      const window = getWindow();\n      if (!swiper.params.history) return;\n\n      if (!window.history || !window.history.pushState) {\n        swiper.params.history.enabled = false;\n        swiper.params.hashNavigation.enabled = true;\n        return;\n      }\n\n      initialized = true;\n      paths = getPathValues(swiper.params.url);\n      if (!paths.key && !paths.value) return;\n      scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n\n      if (!swiper.params.history.replaceState) {\n        window.addEventListener('popstate', setHistoryPopState);\n      }\n    };\n\n    const destroy = () => {\n      const window = getWindow();\n\n      if (!swiper.params.history.replaceState) {\n        window.removeEventListener('popstate', setHistoryPopState);\n      }\n    };\n\n    on('init', () => {\n      if (swiper.params.history.enabled) {\n        init();\n      }\n    });\n    on('destroy', () => {\n      if (swiper.params.history.enabled) {\n        destroy();\n      }\n    });\n    on('transitionEnd _freeModeNoMomentumRelease', () => {\n      if (initialized) {\n        setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    });\n    on('slideChange', () => {\n      if (initialized && swiper.params.cssMode) {\n        setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    });\n  }\n\n  function HashNavigation(_ref) {\n    const { swiper, extendParams, emit, on } = _ref;\n    let initialized = false;\n    const document = getDocument();\n    const window = getWindow();\n    extendParams({\n      hashNavigation: {\n        enabled: false,\n        replaceState: false,\n        watchState: false,\n      },\n    });\n\n    const onHashChange = () => {\n      emit('hashChange');\n      const newHash = document.location.hash.replace('#', '');\n      const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');\n\n      if (newHash !== activeSlideHash) {\n        const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash=\"${newHash}\"]`).index();\n        if (typeof newIndex === 'undefined') return;\n        swiper.slideTo(newIndex);\n      }\n    };\n\n    const setHash = () => {\n      if (!initialized || !swiper.params.hashNavigation.enabled) return;\n\n      if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n        window.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || '');\n        emit('hashSet');\n      } else {\n        const slide = swiper.slides.eq(swiper.activeIndex);\n        const hash = slide.attr('data-hash') || slide.attr('data-history');\n        document.location.hash = hash || '';\n        emit('hashSet');\n      }\n    };\n\n    const init = () => {\n      if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;\n      initialized = true;\n      const hash = document.location.hash.replace('#', '');\n\n      if (hash) {\n        const speed = 0;\n\n        for (let i = 0, { length } = swiper.slides; i < length; i += 1) {\n          const slide = swiper.slides.eq(i);\n          const slideHash = slide.attr('data-hash') || slide.attr('data-history');\n\n          if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {\n            const index = slide.index();\n            swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);\n          }\n        }\n      }\n\n      if (swiper.params.hashNavigation.watchState) {\n        $(window).on('hashchange', onHashChange);\n      }\n    };\n\n    const destroy = () => {\n      if (swiper.params.hashNavigation.watchState) {\n        $(window).off('hashchange', onHashChange);\n      }\n    };\n\n    on('init', () => {\n      if (swiper.params.hashNavigation.enabled) {\n        init();\n      }\n    });\n    on('destroy', () => {\n      if (swiper.params.hashNavigation.enabled) {\n        destroy();\n      }\n    });\n    on('transitionEnd _freeModeNoMomentumRelease', () => {\n      if (initialized) {\n        setHash();\n      }\n    });\n    on('slideChange', () => {\n      if (initialized && swiper.params.cssMode) {\n        setHash();\n      }\n    });\n  }\n\n  /* eslint no-underscore-dangle: \"off\" */\n  function Autoplay(_ref) {\n    const { swiper, extendParams, on, emit } = _ref;\n    let timeout;\n    swiper.autoplay = {\n      running: false,\n      paused: false,\n    };\n    extendParams({\n      autoplay: {\n        enabled: false,\n        delay: 3000,\n        waitForTransition: true,\n        disableOnInteraction: true,\n        stopOnLastSlide: false,\n        reverseDirection: false,\n        pauseOnMouseEnter: false,\n      },\n    });\n\n    function run() {\n      const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\n      let { delay } = swiper.params.autoplay;\n\n      if ($activeSlideEl.attr('data-swiper-autoplay')) {\n        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\n      }\n\n      clearTimeout(timeout);\n      timeout = nextTick(() => {\n        let autoplayResult;\n\n        if (swiper.params.autoplay.reverseDirection) {\n          if (swiper.params.loop) {\n            swiper.loopFix();\n            autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\n            emit('autoplay');\n          } else if (!swiper.isBeginning) {\n            autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\n            emit('autoplay');\n          } else if (!swiper.params.autoplay.stopOnLastSlide) {\n            autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);\n            emit('autoplay');\n          } else {\n            stop();\n          }\n        } else if (swiper.params.loop) {\n          swiper.loopFix();\n          autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.isEnd) {\n          autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\n          emit('autoplay');\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\n          autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);\n          emit('autoplay');\n        } else {\n          stop();\n        }\n\n        if (swiper.params.cssMode && swiper.autoplay.running) run();\n        else if (autoplayResult === false) {\n          run();\n        }\n      }, delay);\n    }\n\n    function start() {\n      if (typeof timeout !== 'undefined') return false;\n      if (swiper.autoplay.running) return false;\n      swiper.autoplay.running = true;\n      emit('autoplayStart');\n      run();\n      return true;\n    }\n\n    function stop() {\n      if (!swiper.autoplay.running) return false;\n      if (typeof timeout === 'undefined') return false;\n\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = undefined;\n      }\n\n      swiper.autoplay.running = false;\n      emit('autoplayStop');\n      return true;\n    }\n\n    function pause(speed) {\n      if (!swiper.autoplay.running) return;\n      if (swiper.autoplay.paused) return;\n      if (timeout) clearTimeout(timeout);\n      swiper.autoplay.paused = true;\n\n      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {\n        swiper.autoplay.paused = false;\n        run();\n      } else {\n        ['transitionend', 'webkitTransitionEnd'].forEach((event) => {\n          swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);\n        });\n      }\n    }\n\n    function onVisibilityChange() {\n      const document = getDocument();\n\n      if (document.visibilityState === 'hidden' && swiper.autoplay.running) {\n        pause();\n      }\n\n      if (document.visibilityState === 'visible' && swiper.autoplay.paused) {\n        run();\n        swiper.autoplay.paused = false;\n      }\n    }\n\n    function onTransitionEnd(e) {\n      if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;\n      if (e.target !== swiper.$wrapperEl[0]) return;\n      ['transitionend', 'webkitTransitionEnd'].forEach((event) => {\n        swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);\n      });\n      swiper.autoplay.paused = false;\n\n      if (!swiper.autoplay.running) {\n        stop();\n      } else {\n        run();\n      }\n    }\n\n    function onMouseEnter() {\n      if (swiper.params.autoplay.disableOnInteraction) {\n        stop();\n      } else {\n        emit('autoplayPause');\n        pause();\n      }\n\n      ['transitionend', 'webkitTransitionEnd'].forEach((event) => {\n        swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);\n      });\n    }\n\n    function onMouseLeave() {\n      if (swiper.params.autoplay.disableOnInteraction) {\n        return;\n      }\n\n      swiper.autoplay.paused = false;\n      emit('autoplayResume');\n      run();\n    }\n\n    function attachMouseEvents() {\n      if (swiper.params.autoplay.pauseOnMouseEnter) {\n        swiper.$el.on('mouseenter', onMouseEnter);\n        swiper.$el.on('mouseleave', onMouseLeave);\n      }\n    }\n\n    function detachMouseEvents() {\n      swiper.$el.off('mouseenter', onMouseEnter);\n      swiper.$el.off('mouseleave', onMouseLeave);\n    }\n\n    on('init', () => {\n      if (swiper.params.autoplay.enabled) {\n        start();\n        const document = getDocument();\n        document.addEventListener('visibilitychange', onVisibilityChange);\n        attachMouseEvents();\n      }\n    });\n    on('beforeTransitionStart', (_s, speed, internal) => {\n      if (swiper.autoplay.running) {\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\n          swiper.autoplay.pause(speed);\n        } else {\n          stop();\n        }\n      }\n    });\n    on('sliderFirstMove', () => {\n      if (swiper.autoplay.running) {\n        if (swiper.params.autoplay.disableOnInteraction) {\n          stop();\n        } else {\n          pause();\n        }\n      }\n    });\n    on('touchEnd', () => {\n      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {\n        run();\n      }\n    });\n    on('destroy', () => {\n      detachMouseEvents();\n\n      if (swiper.autoplay.running) {\n        stop();\n      }\n\n      const document = getDocument();\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n    });\n    Object.assign(swiper.autoplay, {\n      pause,\n      run,\n      start,\n      stop,\n    });\n  }\n\n  function Thumb(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      thumbs: {\n        swiper: null,\n        multipleActiveThumbs: true,\n        autoScrollOffset: 0,\n        slideThumbActiveClass: 'swiper-slide-thumb-active',\n        thumbsContainerClass: 'swiper-thumbs',\n      },\n    });\n    let initialized = false;\n    let swiperCreated = false;\n    swiper.thumbs = {\n      swiper: null,\n    };\n\n    function onThumbClick() {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      const { clickedIndex } = thumbsSwiper;\n      const { clickedSlide } = thumbsSwiper;\n      if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;\n      if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n      let slideToIndex;\n\n      if (thumbsSwiper.params.loop) {\n        slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);\n      } else {\n        slideToIndex = clickedIndex;\n      }\n\n      if (swiper.params.loop) {\n        let currentIndex = swiper.activeIndex;\n\n        if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {\n          swiper.loopFix(); // eslint-disable-next-line\n\n          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\n          currentIndex = swiper.activeIndex;\n        }\n\n        const prevIndex = swiper.slides\n          .eq(currentIndex)\n          .prevAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`)\n          .eq(0)\n          .index();\n        const nextIndex = swiper.slides\n          .eq(currentIndex)\n          .nextAll(`[data-swiper-slide-index=\"${slideToIndex}\"]`)\n          .eq(0)\n          .index();\n        if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;\n        else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;\n        else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;\n        else slideToIndex = prevIndex;\n      }\n\n      swiper.slideTo(slideToIndex);\n    }\n\n    function init() {\n      const { thumbs: thumbsParams } = swiper.params;\n      if (initialized) return false;\n      initialized = true;\n      const SwiperClass = swiper.constructor;\n\n      if (thumbsParams.swiper instanceof SwiperClass) {\n        swiper.thumbs.swiper = thumbsParams.swiper;\n        Object.assign(swiper.thumbs.swiper.originalParams, {\n          watchSlidesProgress: true,\n          slideToClickedSlide: false,\n        });\n        Object.assign(swiper.thumbs.swiper.params, {\n          watchSlidesProgress: true,\n          slideToClickedSlide: false,\n        });\n      } else if (isObject(thumbsParams.swiper)) {\n        const thumbsSwiperParams = { ...thumbsParams.swiper };\n        Object.assign(thumbsSwiperParams, {\n          watchSlidesProgress: true,\n          slideToClickedSlide: false,\n        });\n        swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n        swiperCreated = true;\n      }\n\n      swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);\n      swiper.thumbs.swiper.on('tap', onThumbClick);\n      return true;\n    }\n\n    function update(initial) {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      const slidesPerView =\n        thumbsSwiper.params.slidesPerView === 'auto'\n          ? thumbsSwiper.slidesPerViewDynamic()\n          : thumbsSwiper.params.slidesPerView; // Activate thumbs\n\n      let thumbsToActivate = 1;\n      const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n\n      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n        thumbsToActivate = swiper.params.slidesPerView;\n      }\n\n      if (!swiper.params.thumbs.multipleActiveThumbs) {\n        thumbsToActivate = 1;\n      }\n\n      thumbsToActivate = Math.floor(thumbsToActivate);\n      thumbsSwiper.slides.removeClass(thumbActiveClass);\n\n      if (thumbsSwiper.params.loop || (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)) {\n        for (let i = 0; i < thumbsToActivate; i += 1) {\n          thumbsSwiper.$wrapperEl\n            .children(`[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`)\n            .addClass(thumbActiveClass);\n        }\n      } else {\n        for (let i = 0; i < thumbsToActivate; i += 1) {\n          thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);\n        }\n      }\n\n      const { autoScrollOffset } = swiper.params.thumbs;\n      const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n\n      if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n        let currentThumbsIndex = thumbsSwiper.activeIndex;\n        let newThumbsIndex;\n        let direction;\n\n        if (thumbsSwiper.params.loop) {\n          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {\n            thumbsSwiper.loopFix(); // eslint-disable-next-line\n\n            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;\n            currentThumbsIndex = thumbsSwiper.activeIndex;\n          } // Find actual thumbs index to slide to\n\n          const prevThumbsIndex = thumbsSwiper.slides\n            .eq(currentThumbsIndex)\n            .prevAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`)\n            .eq(0)\n            .index();\n          const nextThumbsIndex = thumbsSwiper.slides\n            .eq(currentThumbsIndex)\n            .nextAll(`[data-swiper-slide-index=\"${swiper.realIndex}\"]`)\n            .eq(0)\n            .index();\n\n          if (typeof prevThumbsIndex === 'undefined') {\n            newThumbsIndex = nextThumbsIndex;\n          } else if (typeof nextThumbsIndex === 'undefined') {\n            newThumbsIndex = prevThumbsIndex;\n          } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {\n            newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;\n          } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {\n            newThumbsIndex = nextThumbsIndex;\n          } else {\n            newThumbsIndex = prevThumbsIndex;\n          }\n\n          direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n        } else {\n          newThumbsIndex = swiper.realIndex;\n          direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n        }\n\n        if (useOffset) {\n          newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n        }\n\n        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n          if (thumbsSwiper.params.centeredSlides) {\n            if (newThumbsIndex > currentThumbsIndex) {\n              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n            } else {\n              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n            }\n          } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1);\n\n          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n        }\n      }\n    }\n\n    on('beforeInit', () => {\n      const { thumbs } = swiper.params;\n      if (!thumbs || !thumbs.swiper) return;\n      init();\n      update(true);\n    });\n    on('slideChange update resize observerUpdate', () => {\n      update();\n    });\n    on('setTransition', (_s, duration) => {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      thumbsSwiper.setTransition(duration);\n    });\n    on('beforeDestroy', () => {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n\n      if (swiperCreated) {\n        thumbsSwiper.destroy();\n      }\n    });\n    Object.assign(swiper.thumbs, {\n      init,\n      update,\n    });\n  }\n\n  function freeMode(_ref) {\n    const { swiper, extendParams, emit, once } = _ref;\n    extendParams({\n      freeMode: {\n        enabled: false,\n        momentum: true,\n        momentumRatio: 1,\n        momentumBounce: true,\n        momentumBounceRatio: 1,\n        momentumVelocityRatio: 1,\n        sticky: false,\n        minimumVelocity: 0.02,\n      },\n    });\n\n    function onTouchStart() {\n      const translate = swiper.getTranslate();\n      swiper.setTranslate(translate);\n      swiper.setTransition(0);\n      swiper.touchEventsData.velocities.length = 0;\n      swiper.freeMode.onTouchEnd({\n        currentPos: swiper.rtl ? swiper.translate : -swiper.translate,\n      });\n    }\n\n    function onTouchMove() {\n      const { touchEventsData: data, touches } = swiper; // Velocity\n\n      if (data.velocities.length === 0) {\n        data.velocities.push({\n          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n          time: data.touchStartTime,\n        });\n      }\n\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n        time: now(),\n      });\n    }\n\n    function onTouchEnd(_ref2) {\n      const { currentPos } = _ref2;\n      const { params, $wrapperEl, rtlTranslate: rtl, snapGrid, touchEventsData: data } = swiper; // Time diff\n\n      const touchEndTime = now();\n      const timeDiff = touchEndTime - data.touchStartTime;\n\n      if (currentPos < -swiper.minTranslate()) {\n        swiper.slideTo(swiper.activeIndex);\n        return;\n      }\n\n      if (currentPos > -swiper.maxTranslate()) {\n        if (swiper.slides.length < snapGrid.length) {\n          swiper.slideTo(snapGrid.length - 1);\n        } else {\n          swiper.slideTo(swiper.slides.length - 1);\n        }\n\n        return;\n      }\n\n      if (params.freeMode.momentum) {\n        if (data.velocities.length > 1) {\n          const lastMoveEvent = data.velocities.pop();\n          const velocityEvent = data.velocities.pop();\n          const distance = lastMoveEvent.position - velocityEvent.position;\n          const time = lastMoveEvent.time - velocityEvent.time;\n          swiper.velocity = distance / time;\n          swiper.velocity /= 2;\n\n          if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n            swiper.velocity = 0;\n          } // this implies that the user stopped moving a finger then released.\n          // There would be no events with distance zero, so the last event is stale.\n\n          if (time > 150 || now() - lastMoveEvent.time > 300) {\n            swiper.velocity = 0;\n          }\n        } else {\n          swiper.velocity = 0;\n        }\n\n        swiper.velocity *= params.freeMode.momentumVelocityRatio;\n        data.velocities.length = 0;\n        let momentumDuration = 1000 * params.freeMode.momentumRatio;\n        const momentumDistance = swiper.velocity * momentumDuration;\n        let newPosition = swiper.translate + momentumDistance;\n        if (rtl) newPosition = -newPosition;\n        let doBounce = false;\n        let afterBouncePosition;\n        const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n        let needsLoopFix;\n\n        if (newPosition < swiper.maxTranslate()) {\n          if (params.freeMode.momentumBounce) {\n            if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n              newPosition = swiper.maxTranslate() - bounceAmount;\n            }\n\n            afterBouncePosition = swiper.maxTranslate();\n            doBounce = true;\n            data.allowMomentumBounce = true;\n          } else {\n            newPosition = swiper.maxTranslate();\n          }\n\n          if (params.loop && params.centeredSlides) needsLoopFix = true;\n        } else if (newPosition > swiper.minTranslate()) {\n          if (params.freeMode.momentumBounce) {\n            if (newPosition - swiper.minTranslate() > bounceAmount) {\n              newPosition = swiper.minTranslate() + bounceAmount;\n            }\n\n            afterBouncePosition = swiper.minTranslate();\n            doBounce = true;\n            data.allowMomentumBounce = true;\n          } else {\n            newPosition = swiper.minTranslate();\n          }\n\n          if (params.loop && params.centeredSlides) needsLoopFix = true;\n        } else if (params.freeMode.sticky) {\n          let nextSlide;\n\n          for (let j = 0; j < snapGrid.length; j += 1) {\n            if (snapGrid[j] > -newPosition) {\n              nextSlide = j;\n              break;\n            }\n          }\n\n          if (\n            Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) ||\n            swiper.swipeDirection === 'next'\n          ) {\n            newPosition = snapGrid[nextSlide];\n          } else {\n            newPosition = snapGrid[nextSlide - 1];\n          }\n\n          newPosition = -newPosition;\n        }\n\n        if (needsLoopFix) {\n          once('transitionEnd', () => {\n            swiper.loopFix();\n          });\n        } // Fix duration\n\n        if (swiper.velocity !== 0) {\n          if (rtl) {\n            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n          } else {\n            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n          }\n\n          if (params.freeMode.sticky) {\n            // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n            // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n            // It's easy to see this when simulating touch with mouse events. To fix this,\n            // limit single-slide swipes to the default slide duration. This also has the\n            // nice side effect of matching slide speed if the user stopped moving before\n            // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n            // For faster swipes, also apply limits (albeit higher ones).\n            const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n            const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n            if (moveDistance < currentSlideSize) {\n              momentumDuration = params.speed;\n            } else if (moveDistance < 2 * currentSlideSize) {\n              momentumDuration = params.speed * 1.5;\n            } else {\n              momentumDuration = params.speed * 2.5;\n            }\n          }\n        } else if (params.freeMode.sticky) {\n          swiper.slideToClosest();\n          return;\n        }\n\n        if (params.freeMode.momentumBounce && doBounce) {\n          swiper.updateProgress(afterBouncePosition);\n          swiper.setTransition(momentumDuration);\n          swiper.setTranslate(newPosition);\n          swiper.transitionStart(true, swiper.swipeDirection);\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n            emit('momentumBounce');\n            swiper.setTransition(params.speed);\n            setTimeout(() => {\n              swiper.setTranslate(afterBouncePosition);\n              $wrapperEl.transitionEnd(() => {\n                if (!swiper || swiper.destroyed) return;\n                swiper.transitionEnd();\n              });\n            }, 0);\n          });\n        } else if (swiper.velocity) {\n          emit('_freeModeNoMomentumRelease');\n          swiper.updateProgress(newPosition);\n          swiper.setTransition(momentumDuration);\n          swiper.setTranslate(newPosition);\n          swiper.transitionStart(true, swiper.swipeDirection);\n\n          if (!swiper.animating) {\n            swiper.animating = true;\n            $wrapperEl.transitionEnd(() => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }\n        } else {\n          swiper.updateProgress(newPosition);\n        }\n\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      } else if (params.freeMode) {\n        emit('_freeModeNoMomentumRelease');\n      }\n\n      if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n    }\n\n    Object.assign(swiper, {\n      freeMode: {\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n      },\n    });\n  }\n\n  function Grid(_ref) {\n    const { swiper, extendParams } = _ref;\n    extendParams({\n      grid: {\n        rows: 1,\n        fill: 'column',\n      },\n    });\n    let slidesNumberEvenToRows;\n    let slidesPerRow;\n    let numFullColumns;\n\n    const initSlides = (slidesLength) => {\n      const { slidesPerView } = swiper.params;\n      const { rows, fill } = swiper.params.grid;\n      slidesPerRow = slidesNumberEvenToRows / rows;\n      numFullColumns = Math.floor(slidesLength / rows);\n\n      if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n        slidesNumberEvenToRows = slidesLength;\n      } else {\n        slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n      }\n\n      if (slidesPerView !== 'auto' && fill === 'row') {\n        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n      }\n    };\n\n    const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {\n      const { slidesPerGroup, spaceBetween } = swiper.params;\n      const { rows, fill } = swiper.params.grid; // Set slides order\n\n      let newSlideOrderIndex;\n      let column;\n      let row;\n\n      if (fill === 'row' && slidesPerGroup > 1) {\n        const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n        const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n        const columnsInGroup =\n          groupIndex === 0\n            ? slidesPerGroup\n            : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n        row = Math.floor(slideIndexInGroup / columnsInGroup);\n        column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n        newSlideOrderIndex = column + (row * slidesNumberEvenToRows) / rows;\n        slide.css({\n          '-webkit-order': newSlideOrderIndex,\n          order: newSlideOrderIndex,\n        });\n      } else if (fill === 'column') {\n        column = Math.floor(i / rows);\n        row = i - column * rows;\n\n        if (column > numFullColumns || (column === numFullColumns && row === rows - 1)) {\n          row += 1;\n\n          if (row >= rows) {\n            row = 0;\n            column += 1;\n          }\n        }\n      } else {\n        row = Math.floor(i / slidesPerRow);\n        column = i - row * slidesPerRow;\n      }\n\n      slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && `${spaceBetween}px` : '');\n    };\n\n    const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n      const { spaceBetween, centeredSlides, roundLengths } = swiper.params;\n      const { rows } = swiper.params.grid;\n      swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n      swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n      swiper.$wrapperEl.css({\n        [getDirectionLabel('width')]: `${swiper.virtualSize + spaceBetween}px`,\n      });\n\n      if (centeredSlides) {\n        snapGrid.splice(0, snapGrid.length);\n        const newSlidesGrid = [];\n\n        for (let i = 0; i < snapGrid.length; i += 1) {\n          let slidesGridItem = snapGrid[i];\n          if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n          if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n        }\n\n        snapGrid.push(...newSlidesGrid);\n      }\n    };\n\n    swiper.grid = {\n      initSlides,\n      updateSlide,\n      updateWrapperSize,\n    };\n  }\n\n  function appendSlide(slides) {\n    const swiper = this;\n    const { $wrapperEl, params } = swiper;\n\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) $wrapperEl.append(slides[i]);\n      }\n    } else {\n      $wrapperEl.append(slides);\n    }\n\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n\n    if (!params.observer) {\n      swiper.update();\n    }\n  }\n\n  function prependSlide(slides) {\n    const swiper = this;\n    const { params, $wrapperEl, activeIndex } = swiper;\n\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    let newActiveIndex = activeIndex + 1;\n\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) $wrapperEl.prepend(slides[i]);\n      }\n\n      newActiveIndex = activeIndex + slides.length;\n    } else {\n      $wrapperEl.prepend(slides);\n    }\n\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n\n    if (!params.observer) {\n      swiper.update();\n    }\n\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n\n  function addSlide(index, slides) {\n    const swiper = this;\n    const { $wrapperEl, params, activeIndex } = swiper;\n    let activeIndexBuffer = activeIndex;\n\n    if (params.loop) {\n      activeIndexBuffer -= swiper.loopedSlides;\n      swiper.loopDestroy();\n      swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n    }\n\n    const baseLength = swiper.slides.length;\n\n    if (index <= 0) {\n      swiper.prependSlide(slides);\n      return;\n    }\n\n    if (index >= baseLength) {\n      swiper.appendSlide(slides);\n      return;\n    }\n\n    let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n    const slidesBuffer = [];\n\n    for (let i = baseLength - 1; i >= index; i -= 1) {\n      const currentSlide = swiper.slides.eq(i);\n      currentSlide.remove();\n      slidesBuffer.unshift(currentSlide);\n    }\n\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) $wrapperEl.append(slides[i]);\n      }\n\n      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n    } else {\n      $wrapperEl.append(slides);\n    }\n\n    for (let i = 0; i < slidesBuffer.length; i += 1) {\n      $wrapperEl.append(slidesBuffer[i]);\n    }\n\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n\n    if (!params.observer) {\n      swiper.update();\n    }\n\n    if (params.loop) {\n      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n    } else {\n      swiper.slideTo(newActiveIndex, 0, false);\n    }\n  }\n\n  function removeSlide(slidesIndexes) {\n    const swiper = this;\n    const { params, $wrapperEl, activeIndex } = swiper;\n    let activeIndexBuffer = activeIndex;\n\n    if (params.loop) {\n      activeIndexBuffer -= swiper.loopedSlides;\n      swiper.loopDestroy();\n      swiper.slides = $wrapperEl.children(`.${params.slideClass}`);\n    }\n\n    let newActiveIndex = activeIndexBuffer;\n    let indexToRemove;\n\n    if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n      for (let i = 0; i < slidesIndexes.length; i += 1) {\n        indexToRemove = slidesIndexes[i];\n        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n      }\n\n      newActiveIndex = Math.max(newActiveIndex, 0);\n    } else {\n      indexToRemove = slidesIndexes;\n      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n      newActiveIndex = Math.max(newActiveIndex, 0);\n    }\n\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n\n    if (!params.observer) {\n      swiper.update();\n    }\n\n    if (params.loop) {\n      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n    } else {\n      swiper.slideTo(newActiveIndex, 0, false);\n    }\n  }\n\n  function removeAllSlides() {\n    const swiper = this;\n    const slidesIndexes = [];\n\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      slidesIndexes.push(i);\n    }\n\n    swiper.removeSlide(slidesIndexes);\n  }\n\n  function Manipulation(_ref) {\n    const { swiper } = _ref;\n    Object.assign(swiper, {\n      appendSlide: appendSlide.bind(swiper),\n      prependSlide: prependSlide.bind(swiper),\n      addSlide: addSlide.bind(swiper),\n      removeSlide: removeSlide.bind(swiper),\n      removeAllSlides: removeAllSlides.bind(swiper),\n    });\n  }\n\n  function effectInit(params) {\n    const {\n      effect,\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      overwriteParams,\n      perspective,\n      recreateShadows,\n      getEffectParams,\n    } = params;\n    on('beforeInit', () => {\n      if (swiper.params.effect !== effect) return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n\n      if (perspective && perspective()) {\n        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n      }\n\n      const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n      Object.assign(swiper.params, overwriteParamsResult);\n      Object.assign(swiper.originalParams, overwriteParamsResult);\n    });\n    on('setTranslate', () => {\n      if (swiper.params.effect !== effect) return;\n      setTranslate();\n    });\n    on('setTransition', (_s, duration) => {\n      if (swiper.params.effect !== effect) return;\n      setTransition(duration);\n    });\n    on('transitionEnd', () => {\n      if (swiper.params.effect !== effect) return;\n\n      if (recreateShadows) {\n        if (!getEffectParams || !getEffectParams().slideShadows) return; // remove shadows\n\n        swiper.slides.each((slideEl) => {\n          const $slideEl = swiper.$(slideEl);\n          $slideEl\n            .find(\n              '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left'\n            )\n            .remove();\n        }); // create new one\n\n        recreateShadows();\n      }\n    });\n    let requireUpdateOnVirtual;\n    on('virtualUpdate', () => {\n      if (swiper.params.effect !== effect) return;\n\n      if (!swiper.slides.length) {\n        requireUpdateOnVirtual = true;\n      }\n\n      requestAnimationFrame(() => {\n        if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n          setTranslate();\n          requireUpdateOnVirtual = false;\n        }\n      });\n    });\n  }\n\n  function effectTarget(effectParams, $slideEl) {\n    if (effectParams.transformEl) {\n      return $slideEl.find(effectParams.transformEl).css({\n        'backface-visibility': 'hidden',\n        '-webkit-backface-visibility': 'hidden',\n      });\n    }\n\n    return $slideEl;\n  }\n\n  function effectVirtualTransitionEnd(_ref) {\n    const { swiper, duration, transformEl, allSlides } = _ref;\n    const { slides, activeIndex, $wrapperEl } = swiper;\n\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      let eventTriggered = false;\n      let $transitionEndTarget;\n\n      if (allSlides) {\n        $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;\n      } else {\n        $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);\n      }\n\n      $transitionEndTarget.transitionEnd(() => {\n        if (eventTriggered) return;\n        if (!swiper || swiper.destroyed) return;\n        eventTriggered = true;\n        swiper.animating = false;\n        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n\n        for (let i = 0; i < triggerEvents.length; i += 1) {\n          $wrapperEl.trigger(triggerEvents[i]);\n        }\n      });\n    }\n  }\n\n  function EffectFade(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      fadeEffect: {\n        crossFade: false,\n        transformEl: null,\n      },\n    });\n\n    const setTranslate = () => {\n      const { slides } = swiper;\n      const params = swiper.params.fadeEffect;\n\n      for (let i = 0; i < slides.length; i += 1) {\n        const $slideEl = swiper.slides.eq(i);\n        const offset = $slideEl[0].swiperSlideOffset;\n        let tx = -offset;\n        if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n        let ty = 0;\n\n        if (!swiper.isHorizontal()) {\n          ty = tx;\n          tx = 0;\n        }\n\n        const slideOpacity = swiper.params.fadeEffect.crossFade\n          ? Math.max(1 - Math.abs($slideEl[0].progress), 0)\n          : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\n        const $targetEl = effectTarget(params, $slideEl);\n        $targetEl\n          .css({\n            opacity: slideOpacity,\n          })\n          .transform(`translate3d(${tx}px, ${ty}px, 0px)`);\n      }\n    };\n\n    const setTransition = (duration) => {\n      const { transformEl } = swiper.params.fadeEffect;\n      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n      $transitionElements.transition(duration);\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformEl,\n        allSlides: true,\n      });\n    };\n\n    effectInit({\n      effect: 'fade',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: !swiper.params.cssMode,\n      }),\n    });\n  }\n\n  function EffectCube(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      cubeEffect: {\n        slideShadows: true,\n        shadow: true,\n        shadowOffset: 20,\n        shadowScale: 0.94,\n      },\n    });\n\n    const createSlideShadows = ($slideEl, progress, isHorizontal) => {\n      let shadowBefore = isHorizontal\n        ? $slideEl.find('.swiper-slide-shadow-left')\n        : $slideEl.find('.swiper-slide-shadow-top');\n      let shadowAfter = isHorizontal\n        ? $slideEl.find('.swiper-slide-shadow-right')\n        : $slideEl.find('.swiper-slide-shadow-bottom');\n\n      if (shadowBefore.length === 0) {\n        shadowBefore = $(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}\"></div>`);\n        $slideEl.append(shadowBefore);\n      }\n\n      if (shadowAfter.length === 0) {\n        shadowAfter = $(`<div class=\"swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}\"></div>`);\n        $slideEl.append(shadowAfter);\n      }\n\n      if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n      if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n    };\n\n    const recreateShadows = () => {\n      // create new ones\n      const isHorizontal = swiper.isHorizontal();\n      swiper.slides.each((slideEl) => {\n        const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n        createSlideShadows($(slideEl), progress, isHorizontal);\n      });\n    };\n\n    const setTranslate = () => {\n      const {\n        $el,\n        $wrapperEl,\n        slides,\n        width: swiperWidth,\n        height: swiperHeight,\n        rtlTranslate: rtl,\n        size: swiperSize,\n        browser,\n      } = swiper;\n      const params = swiper.params.cubeEffect;\n      const isHorizontal = swiper.isHorizontal();\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      let wrapperRotate = 0;\n      let $cubeShadowEl;\n\n      if (params.shadow) {\n        if (isHorizontal) {\n          $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');\n\n          if ($cubeShadowEl.length === 0) {\n            $cubeShadowEl = $('<div class=\"swiper-cube-shadow\"></div>');\n            $wrapperEl.append($cubeShadowEl);\n          }\n\n          $cubeShadowEl.css({\n            height: `${swiperWidth}px`,\n          });\n        } else {\n          $cubeShadowEl = $el.find('.swiper-cube-shadow');\n\n          if ($cubeShadowEl.length === 0) {\n            $cubeShadowEl = $('<div class=\"swiper-cube-shadow\"></div>');\n            $el.append($cubeShadowEl);\n          }\n        }\n      }\n\n      for (let i = 0; i < slides.length; i += 1) {\n        const $slideEl = slides.eq(i);\n        let slideIndex = i;\n\n        if (isVirtual) {\n          slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);\n        }\n\n        let slideAngle = slideIndex * 90;\n        let round = Math.floor(slideAngle / 360);\n\n        if (rtl) {\n          slideAngle = -slideAngle;\n          round = Math.floor(-slideAngle / 360);\n        }\n\n        const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n        let tx = 0;\n        let ty = 0;\n        let tz = 0;\n\n        if (slideIndex % 4 === 0) {\n          tx = -round * 4 * swiperSize;\n          tz = 0;\n        } else if ((slideIndex - 1) % 4 === 0) {\n          tx = 0;\n          tz = -round * 4 * swiperSize;\n        } else if ((slideIndex - 2) % 4 === 0) {\n          tx = swiperSize + round * 4 * swiperSize;\n          tz = swiperSize;\n        } else if ((slideIndex - 3) % 4 === 0) {\n          tx = -swiperSize;\n          tz = 3 * swiperSize + swiperSize * 4 * round;\n        }\n\n        if (rtl) {\n          tx = -tx;\n        }\n\n        if (!isHorizontal) {\n          ty = tx;\n          tx = 0;\n        }\n\n        const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${\n          isHorizontal ? slideAngle : 0\n        }deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n\n        if (progress <= 1 && progress > -1) {\n          wrapperRotate = slideIndex * 90 + progress * 90;\n          if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n        }\n\n        $slideEl.transform(transform);\n\n        if (params.slideShadows) {\n          createSlideShadows($slideEl, progress, isHorizontal);\n        }\n      }\n\n      $wrapperEl.css({\n        '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,\n        'transform-origin': `50% 50% -${swiperSize / 2}px`,\n      });\n\n      if (params.shadow) {\n        if (isHorizontal) {\n          $cubeShadowEl.transform(\n            `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${\n              -swiperWidth / 2\n            }px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`\n          );\n        } else {\n          const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n          const multiplier =\n            1.5 - (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2 + Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2);\n          const scale1 = params.shadowScale;\n          const scale2 = params.shadowScale / multiplier;\n          const offset = params.shadowOffset;\n          $cubeShadowEl.transform(\n            `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${\n              -swiperHeight / 2 / scale2\n            }px) rotateX(-90deg)`\n          );\n        }\n      }\n\n      const zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;\n      $wrapperEl.transform(\n        `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${\n          swiper.isHorizontal() ? -wrapperRotate : 0\n        }deg)`\n      );\n      $wrapperEl[0].style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n    };\n\n    const setTransition = (duration) => {\n      const { $el, slides } = swiper;\n      slides\n        .transition(duration)\n        .find(\n          '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left'\n        )\n        .transition(duration);\n\n      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n        $el.find('.swiper-cube-shadow').transition(duration);\n      }\n    };\n\n    effectInit({\n      effect: 'cube',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      recreateShadows,\n      getEffectParams: () => swiper.params.cubeEffect,\n      perspective: () => true,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        resistanceRatio: 0,\n        spaceBetween: 0,\n        centeredSlides: false,\n        virtualTranslate: true,\n      }),\n    });\n  }\n\n  function createShadow(params, $slideEl, side) {\n    const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;\n    const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;\n    let $shadowEl = $shadowContainer.children(`.${shadowClass}`);\n\n    if (!$shadowEl.length) {\n      $shadowEl = $(`<div class=\"swiper-slide-shadow${side ? `-${side}` : ''}\"></div>`);\n      $shadowContainer.append($shadowEl);\n    }\n\n    return $shadowEl;\n  }\n\n  function EffectFlip(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      flipEffect: {\n        slideShadows: true,\n        limitRotation: true,\n        transformEl: null,\n      },\n    });\n\n    const createSlideShadows = ($slideEl, progress, params) => {\n      let shadowBefore = swiper.isHorizontal()\n        ? $slideEl.find('.swiper-slide-shadow-left')\n        : $slideEl.find('.swiper-slide-shadow-top');\n      let shadowAfter = swiper.isHorizontal()\n        ? $slideEl.find('.swiper-slide-shadow-right')\n        : $slideEl.find('.swiper-slide-shadow-bottom');\n\n      if (shadowBefore.length === 0) {\n        shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');\n      }\n\n      if (shadowAfter.length === 0) {\n        shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n      }\n\n      if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);\n      if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);\n    };\n\n    const recreateShadows = () => {\n      // Set shadows\n      const params = swiper.params.flipEffect;\n      swiper.slides.each((slideEl) => {\n        const $slideEl = $(slideEl);\n        let { progress } = $slideEl[0];\n\n        if (swiper.params.flipEffect.limitRotation) {\n          progress = Math.max(Math.min(slideEl.progress, 1), -1);\n        }\n\n        createSlideShadows($slideEl, progress, params);\n      });\n    };\n\n    const setTranslate = () => {\n      const { slides, rtlTranslate: rtl } = swiper;\n      const params = swiper.params.flipEffect;\n\n      for (let i = 0; i < slides.length; i += 1) {\n        const $slideEl = slides.eq(i);\n        let { progress } = $slideEl[0];\n\n        if (swiper.params.flipEffect.limitRotation) {\n          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\n        }\n\n        const offset = $slideEl[0].swiperSlideOffset;\n        const rotate = -180 * progress;\n        let rotateY = rotate;\n        let rotateX = 0;\n        let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n        let ty = 0;\n\n        if (!swiper.isHorizontal()) {\n          ty = tx;\n          tx = 0;\n          rotateX = -rotateY;\n          rotateY = 0;\n        } else if (rtl) {\n          rotateY = -rotateY;\n        }\n\n        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n\n        if (params.slideShadows) {\n          createSlideShadows($slideEl, progress, params);\n        }\n\n        const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n        const $targetEl = effectTarget(params, $slideEl);\n        $targetEl.transform(transform);\n      }\n    };\n\n    const setTransition = (duration) => {\n      const { transformEl } = swiper.params.flipEffect;\n      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n      $transitionElements\n        .transition(duration)\n        .find(\n          '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left'\n        )\n        .transition(duration);\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformEl,\n      });\n    };\n\n    effectInit({\n      effect: 'flip',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      recreateShadows,\n      getEffectParams: () => swiper.params.flipEffect,\n      perspective: () => true,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: !swiper.params.cssMode,\n      }),\n    });\n  }\n\n  function EffectCoverflow(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      coverflowEffect: {\n        rotate: 50,\n        stretch: 0,\n        depth: 100,\n        scale: 1,\n        modifier: 1,\n        slideShadows: true,\n        transformEl: null,\n      },\n    });\n\n    const setTranslate = () => {\n      const { width: swiperWidth, height: swiperHeight, slides, slidesSizesGrid } = swiper;\n      const params = swiper.params.coverflowEffect;\n      const isHorizontal = swiper.isHorizontal();\n      const transform = swiper.translate;\n      const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n      const rotate = isHorizontal ? params.rotate : -params.rotate;\n      const translate = params.depth; // Each slide offset from center\n\n      for (let i = 0, { length } = slides; i < length; i += 1) {\n        const $slideEl = slides.eq(i);\n        const slideSize = slidesSizesGrid[i];\n        const slideOffset = $slideEl[0].swiperSlideOffset;\n        const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n        const offsetMultiplier =\n          typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;\n        let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n        let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0\n\n        let translateZ = -translate * Math.abs(offsetMultiplier);\n        let { stretch } = params; // Allow percentage to make a relative stretch for responsive sliders\n\n        if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n          stretch = (parseFloat(params.stretch) / 100) * slideSize;\n        }\n\n        let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n        let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n        let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values\n\n        if (Math.abs(translateX) < 0.001) translateX = 0;\n        if (Math.abs(translateY) < 0.001) translateY = 0;\n        if (Math.abs(translateZ) < 0.001) translateZ = 0;\n        if (Math.abs(rotateY) < 0.001) rotateY = 0;\n        if (Math.abs(rotateX) < 0.001) rotateX = 0;\n        if (Math.abs(scale) < 0.001) scale = 0;\n        const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n        const $targetEl = effectTarget(params, $slideEl);\n        $targetEl.transform(slideTransform);\n        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n\n        if (params.slideShadows) {\n          // Set shadows\n          let $shadowBeforeEl = isHorizontal\n            ? $slideEl.find('.swiper-slide-shadow-left')\n            : $slideEl.find('.swiper-slide-shadow-top');\n          let $shadowAfterEl = isHorizontal\n            ? $slideEl.find('.swiper-slide-shadow-right')\n            : $slideEl.find('.swiper-slide-shadow-bottom');\n\n          if ($shadowBeforeEl.length === 0) {\n            $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');\n          }\n\n          if ($shadowAfterEl.length === 0) {\n            $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');\n          }\n\n          if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n          if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n        }\n      }\n    };\n\n    const setTransition = (duration) => {\n      const { transformEl } = swiper.params.coverflowEffect;\n      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n      $transitionElements\n        .transition(duration)\n        .find(\n          '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left'\n        )\n        .transition(duration);\n    };\n\n    effectInit({\n      effect: 'coverflow',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      perspective: () => true,\n      overwriteParams: () => ({\n        watchSlidesProgress: true,\n      }),\n    });\n  }\n\n  function EffectCreative(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      creativeEffect: {\n        transformEl: null,\n        limitProgress: 1,\n        shadowPerProgress: false,\n        progressMultiplier: 1,\n        perspective: true,\n        prev: {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          opacity: 1,\n          scale: 1,\n        },\n        next: {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          opacity: 1,\n          scale: 1,\n        },\n      },\n    });\n\n    const getTranslateValue = (value) => {\n      if (typeof value === 'string') return value;\n      return `${value}px`;\n    };\n\n    const setTranslate = () => {\n      const { slides, $wrapperEl, slidesSizesGrid } = swiper;\n      const params = swiper.params.creativeEffect;\n      const { progressMultiplier: multiplier } = params;\n      const isCenteredSlides = swiper.params.centeredSlides;\n\n      if (isCenteredSlides) {\n        const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n        $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);\n      }\n\n      for (let i = 0; i < slides.length; i += 1) {\n        const $slideEl = slides.eq(i);\n        const slideProgress = $slideEl[0].progress;\n        const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);\n        let originalProgress = progress;\n\n        if (!isCenteredSlides) {\n          originalProgress = Math.min(\n            Math.max($slideEl[0].originalProgress, -params.limitProgress),\n            params.limitProgress\n          );\n        }\n\n        const offset = $slideEl[0].swiperSlideOffset;\n        const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n        const r = [0, 0, 0];\n        let custom = false;\n\n        if (!swiper.isHorizontal()) {\n          t[1] = t[0];\n          t[0] = 0;\n        }\n\n        let data = {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          scale: 1,\n          opacity: 1,\n        };\n\n        if (progress < 0) {\n          data = params.next;\n          custom = true;\n        } else if (progress > 0) {\n          data = params.prev;\n          custom = true;\n        } // set translate\n\n        t.forEach((value, index) => {\n          t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(\n            progress * multiplier\n          )}))`;\n        }); // set rotates\n\n        r.forEach((value, index) => {\n          r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n        });\n        $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n        const translateString = t.join(', ');\n        const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n        const scaleString =\n          originalProgress < 0\n            ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})`\n            : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n        const opacityString =\n          originalProgress < 0\n            ? 1 + (1 - data.opacity) * originalProgress * multiplier\n            : 1 - (1 - data.opacity) * originalProgress * multiplier;\n        const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`; // Set shadows\n\n        if ((custom && data.shadow) || !custom) {\n          let $shadowEl = $slideEl.children('.swiper-slide-shadow');\n\n          if ($shadowEl.length === 0 && data.shadow) {\n            $shadowEl = createShadow(params, $slideEl);\n          }\n\n          if ($shadowEl.length) {\n            const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n            $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n          }\n        }\n\n        const $targetEl = effectTarget(params, $slideEl);\n        $targetEl.transform(transform).css({\n          opacity: opacityString,\n        });\n\n        if (data.origin) {\n          $targetEl.css('transform-origin', data.origin);\n        }\n      }\n    };\n\n    const setTransition = (duration) => {\n      const { transformEl } = swiper.params.creativeEffect;\n      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n      $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformEl,\n        allSlides: true,\n      });\n    };\n\n    effectInit({\n      effect: 'creative',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      perspective: () => swiper.params.creativeEffect.perspective,\n      overwriteParams: () => ({\n        watchSlidesProgress: true,\n        virtualTranslate: !swiper.params.cssMode,\n      }),\n    });\n  }\n\n  function EffectCards(_ref) {\n    const { swiper, extendParams, on } = _ref;\n    extendParams({\n      cardsEffect: {\n        slideShadows: true,\n        transformEl: null,\n        rotate: true,\n      },\n    });\n\n    const setTranslate = () => {\n      const { slides, activeIndex } = swiper;\n      const params = swiper.params.cardsEffect;\n      const { startTranslate, isTouched } = swiper.touchEventsData;\n      const currentTranslate = swiper.translate;\n\n      for (let i = 0; i < slides.length; i += 1) {\n        const $slideEl = slides.eq(i);\n        const slideProgress = $slideEl[0].progress;\n        const progress = Math.min(Math.max(slideProgress, -4), 4);\n        let offset = $slideEl[0].swiperSlideOffset;\n\n        if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n          swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);\n        }\n\n        if (swiper.params.centeredSlides && swiper.params.cssMode) {\n          offset -= slides[0].swiperSlideOffset;\n        }\n\n        let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n        let tY = 0;\n        const tZ = -100 * Math.abs(progress);\n        let scale = 1;\n        let rotate = -2 * progress;\n        let tXAdd = 8 - Math.abs(progress) * 0.75;\n        const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n        const isSwipeToNext =\n          (slideIndex === activeIndex || slideIndex === activeIndex - 1) &&\n          progress > 0 &&\n          progress < 1 &&\n          (isTouched || swiper.params.cssMode) &&\n          currentTranslate < startTranslate;\n        const isSwipeToPrev =\n          (slideIndex === activeIndex || slideIndex === activeIndex + 1) &&\n          progress < 0 &&\n          progress > -1 &&\n          (isTouched || swiper.params.cssMode) &&\n          currentTranslate > startTranslate;\n\n        if (isSwipeToNext || isSwipeToPrev) {\n          const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n          rotate += -28 * progress * subProgress;\n          scale += -0.5 * subProgress;\n          tXAdd += 96 * subProgress;\n          tY = `${-25 * subProgress * Math.abs(progress)}%`;\n        }\n\n        if (progress < 0) {\n          // next\n          tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;\n        } else if (progress > 0) {\n          // prev\n          tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;\n        } else {\n          tX = `${tX}px`;\n        }\n\n        if (!swiper.isHorizontal()) {\n          const prevY = tY;\n          tY = tX;\n          tX = prevY;\n        }\n\n        const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n        const transform = `\n\t\t\ttranslate3d(${tX}, ${tY}, ${tZ}px)\n\t\t\trotateZ(${params.rotate ? rotate : 0}deg)\n\t\t\tscale(${scaleString})\n\t\t`;\n\n        if (params.slideShadows) {\n          // Set shadows\n          let $shadowEl = $slideEl.find('.swiper-slide-shadow');\n\n          if ($shadowEl.length === 0) {\n            $shadowEl = createShadow(params, $slideEl);\n          }\n\n          if ($shadowEl.length) $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n        }\n\n        $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n        const $targetEl = effectTarget(params, $slideEl);\n        $targetEl.transform(transform);\n      }\n    };\n\n    const setTransition = (duration) => {\n      const { transformEl } = swiper.params.cardsEffect;\n      const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n      $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformEl,\n      });\n    };\n\n    effectInit({\n      effect: 'cards',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      perspective: () => true,\n      overwriteParams: () => ({\n        watchSlidesProgress: true,\n        virtualTranslate: !swiper.params.cssMode,\n      }),\n    });\n  }\n\n  // Swiper Class\n  const modules = [\n    Virtual,\n    Keyboard,\n    Mousewheel,\n    Navigation,\n    Pagination,\n    Scrollbar,\n    Parallax,\n    Zoom,\n    Lazy,\n    Controller,\n    A11y,\n    History,\n    HashNavigation,\n    Autoplay,\n    Thumb,\n    freeMode,\n    Grid,\n    Manipulation,\n    EffectFade,\n    EffectCube,\n    EffectFlip,\n    EffectCoverflow,\n    EffectCreative,\n    EffectCards,\n  ];\n  Swiper.use(modules);\n\n  return Swiper;\n});\n// # sourceMappingURL=swiper-bundle.js.map\n\n\n//# sourceURL=webpack://boarding-houses/./src/js/libs/swipers.js?");

/***/ }),

/***/ "./src/js/modules/gulp.js":
/*!********************************!*\
  !*** ./src/js/modules/gulp.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isWebp: () => (/* binding */ isWebp)\n/* harmony export */ });\nfunction isWebp() {\n  function testWebp(callback) {\n    const webp = new Image();\n    webp.onload = webp.onerror = function () {\n      callback(webp.height == 2);\n    };\n    webp.src =\n      'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';\n  }\n\n  testWebp((support) => {\n    const className = support === true ? 'webp' : 'no-webp';\n    document.documentElement.classList.add(className);\n  });\n}\n\n\n//# sourceURL=webpack://boarding-houses/./src/js/modules/gulp.js?");

/***/ }),

/***/ "./src/js/scripts/datalist.js":
/*!************************************!*\
  !*** ./src/js/scripts/datalist.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// input.onfocus = function () {\n//   browsers.style.display = 'block';\n//   input.style.borderRadius = '5px 5px 0 0';\n// };\n// for (const option of browsers.options) {\n//   option.onclick = function () {\n//     input.value = option.value;\n//     browsers.style.display = 'none';\n//     input.style.borderRadius = '5px';\n//     console.log(document.querySelector('[name=\"locatio\"]').value);\n//   };\n// }\n\n// input.oninput = function () {\n//   currentFocus = -1;\n//   const text = input.value.toUpperCase();\n//   for (const option of browsers.options) {\n//     if (option.value.toUpperCase().indexOf(text) > -1) {\n//       option.style.display = 'block';\n//     } else {\n//       option.style.display = 'none';\n//     }\n//   }\n// };\n// var currentFocus = -1;\n// input.onkeydown = function (e) {\n//   if (e.keyCode == 40) {\n//     currentFocus++;\n//     addActive(browsers.options);\n//   } else if (e.keyCode == 38) {\n//     currentFocus--;\n//     addActive(browsers.options);\n//   } else if (e.keyCode == 13) {\n//     e.preventDefault();\n//     if (currentFocus > -1) {\n//       /* and simulate a click on the \"active\" item: */\n//       if (browsers.options) browsers.options[currentFocus].click();\n//     }\n//   }\n// };\n\n// function addActive(x) {\n//   if (!x) return false;\n//   removeActive(x);\n//   if (currentFocus >= x.length) currentFocus = 0;\n//   if (currentFocus < 0) currentFocus = x.length - 1;\n//   x[currentFocus].classList.add('active');\n// }\n// function removeActive(x) {\n//   for (let i = 0; i < x.length; i++) {\n//     x[i].classList.remove('active');\n//   }\n// }\n\n\n//# sourceURL=webpack://boarding-houses/./src/js/scripts/datalist.js?");

/***/ }),

/***/ "./src/js/scripts/dropdown.js":
/*!************************************!*\
  !*** ./src/js/scripts/dropdown.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nconst dropdowns = document.querySelectorAll('.js-dropdown');\n\ndropdowns.forEach((dropdown) => {\n  const inner = dropdown.querySelector('.js-dropdown-inner');\n  const title = dropdown.querySelector('.js-dropdown-value');\n  const labels = dropdown.querySelectorAll('.js-dropdown-label');\n\n  inner.addEventListener('click', () => {\n    if (dropdown.classList.contains('active')) {\n      dropdown.classList.remove('active');\n    } else {\n      dropdown.classList.add('active');\n    }\n  });\n\n  for (let index = 0; index < labels.length; index += 1) {\n    labels[index].addEventListener('click', (e) => {\n      title.textContent = e.target.textContent;\n      dropdown.classList.remove('active');\n    });\n  }\n});\n\n\n//# sourceURL=webpack://boarding-houses/./src/js/scripts/dropdown.js?");

/***/ }),

/***/ "./src/js/scripts/modal.js":
/*!*********************************!*\
  !*** ./src/js/scripts/modal.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\ndocument.addEventListener('DOMContentLoaded', () => {\n  function getWidthScrol() {\n    const div = document.createElement('div');\n\n    div.style.overflowY = 'scroll';\n    div.style.width = '50px';\n    div.style.height = '50px';\n\n    document.body.append(div);\n    const scrollWidth = div.offsetWidth - div.clientWidth;\n\n    div.remove();\n\n    return scrollWidth;\n  }\n\n  class Modal {\n    constructor(name) {\n      this.name = name;\n      this.modal = document.querySelector(`[data-modal=\"${name}\"]`);\n      this.triggers = document.querySelectorAll(`[data-modal-el=\"${name}\"]`);\n      this.body = document.querySelector('body');\n      this.openHendler();\n    }\n\n    open() {\n      this.modal.classList.remove('success', 'error');\n      this.modal.classList.add('active');\n      document.body.style.overflow = 'hidden';\n      document.body.style.width = `${document.body.clientWidth - getWidthScrol()}px`;\n      this.modal.addEventListener('click', this.closeHendler);\n    }\n\n    close() {\n      this.modal.classList.remove('active');\n      document.body.style.overflow = 'unset';\n      document.body.style.width = 'auto';\n      this.modal.removeEventListener('click', this.closeHendler);\n    }\n\n    success() {\n      this.modal.classList.remove('error');\n      this.modal.classList.add('success');\n    }\n\n    error() {\n      this.modal.classList.remove('success');\n      this.modal.classList.add('error');\n    }\n\n    update() {\n      this.modal = document.querySelector(`[data-modal=\"${this.name}\"]`);\n      this.triggers = document.querySelectorAll(`[data-modal-el=\"${this.name}\"]`);\n      this.openHendler();\n    }\n\n    openHendler = () => {\n      this.triggers.forEach((item) => {\n        item.addEventListener('click', (event) => {\n          event.preventDefault();\n          this.open();\n        });\n      });\n    };\n\n    closeHendler = (event) => {\n      if (event.target.classList.contains('close-x')) {\n        this.close();\n      }\n    };\n  }\n\n  const costServices = document.querySelector('[data-modal=\"cost-services\"]') ? new Modal('cost-services') : null;\n  const notFoundBoard = document.querySelector('[data-modal=\"not-found-board\"]') ? new Modal('not-found-board') : null;\n});\n\n\n//# sourceURL=webpack://boarding-houses/./src/js/scripts/modal.js?");

/***/ }),

/***/ "./src/js/scripts/script.js":
/*!**********************************!*\
  !*** ./src/js/scripts/script.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\ndocument.addEventListener('DOMContentLoaded', () => {\n  function clickToogle() {\n    const toggleElements = document.querySelectorAll('.js-toggle');\n\n    toggleElements.forEach((element) => {\n      element.addEventListener('click', () => {\n        element.classList.toggle('active');\n      });\n    });\n  }\n\n  function setPhoneMask() {\n    const phoneInputs = document.querySelectorAll('input[type=\"tel\"]');\n    phoneInputs.forEach((phoneInput) => {\n      const im = new Inputmask('+7 (999) 999-99-99');\n      im.mask(phoneInput);\n    });\n  }\n\n  setPhoneMask();\n  clickToogle();\n});\n\n\n//# sourceURL=webpack://boarding-houses/./src/js/scripts/script.js?");

/***/ }),

/***/ "./src/js/scripts/swiper.js":
/*!**********************************!*\
  !*** ./src/js/scripts/swiper.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\ndocument.addEventListener('DOMContentLoaded', () => {\n  //   \n  document.querySelectorAll('.js-cards').forEach((cards) => {\n    cards.querySelectorAll('.js-card__slider').forEach((card) => {\n      const slider = card.querySelector('.js-card__swiper');\n      const pagination = card.querySelector('.js-card__bullets');\n\n      const cardSwiper = new Swiper(slider, {\n        slidesPerView: 1,\n        allowTouchMove: true,\n        pagination: {\n          el: pagination,\n          clickable: true,\n        },\n      });\n    });\n  });\n\n  //  \n  document.querySelectorAll('.js-cards').forEach((cards) => {\n    const slider = cards;\n    const pagination = cards.querySelector('.js-cards__bullets');\n    const btnPrev = cards.querySelector('.js-cards-prev');\n    const btnNext = cards.querySelector('.js-cards-next');\n\n    const cardSwiper = new Swiper(slider, {\n      slidesPerView: 3,\n      allowTouchMove: true,\n      spaceBetween: 30,\n      navigation: {\n        nextEl: btnNext,\n        prevEl: btnPrev,\n      },\n      pagination: {\n        el: pagination,\n        clickable: true,\n        renderBullet(index, className) {\n          const total = this.slides.length - 2;\n          if (index === 0) {\n            return `\n\t\t\t\t\t\t\t<span class=\"${className}\">${index + 1}</span>\n\t\t\t\t\t\t`;\n          }\n          if (index === total - 1) {\n            return `\n\t\t\t\t\t\t\t<span class=\"${className}\">${index + 1}</span>\n\t\t\t\t\t\t`;\n          }\n          return `<span class=\"${className}\">${index + 1}</span>`;\n        },\n      },\n      on: {\n        paginationUpdate() {\n          const dots = this.pagination.bullets;\n          dots.forEach((dot) => dot.classList.remove('hide'));\n\n          const current = this.activeIndex;\n          const total = this.slides.length - 2;\n\n          const start = 0;\n          const end = total - 1;\n\n          if (total > 7) {\n            if (current === start || current === start + 1) {\n              for (let i = 3; i < end; i++) {\n                dots[i].classList.add('hide');\n              }\n              dots[start].classList.remove('show');\n              dots[end].classList.add('show');\n            } else if (current === start + 2 || current === start + 3) {\n              dots.forEach((dot) => dot.classList.add('hide'));\n              dots[start].classList.remove('show');\n              dots[end].classList.add('show');\n              dots[start].classList.remove('hide');\n              dots[end].classList.remove('hide');\n              for (let i = current - 2; i <= current + 1; i++) {\n                dots[i].classList.remove('hide');\n              }\n            } else if (current === end) {\n              for (let i = start + 1; i < end - 2; i++) {\n                dots[i].classList.add('hide');\n              }\n              dots[start].classList.add('show');\n              dots[end].classList.remove('show');\n            } else if (current === end - 3 || current === end - 2 || current === end - 1) {\n              for (let i = start + 1; i < current - 1; i++) {\n                dots[i].classList.add('hide');\n              }\n              dots[start].classList.add('show');\n              dots[end].classList.remove('show');\n            } else {\n              dots.forEach((dot) => dot.classList.add('hide'));\n              dots[start].classList.add('show');\n              dots[end].classList.add('show');\n              dots[start].classList.remove('hide');\n              dots[end].classList.remove('hide');\n              for (let i = current - 1; i <= current + 1; i++) {\n                dots[i].classList.remove('hide');\n              }\n            }\n          }\n        },\n      },\n    });\n  });\n});\n\n\n//# sourceURL=webpack://boarding-houses/./src/js/scripts/swiper.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;